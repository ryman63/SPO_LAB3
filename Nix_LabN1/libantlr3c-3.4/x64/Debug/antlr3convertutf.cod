; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
trailingBytesForUTF8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
firstByteMark DB 00H
	DB	00H
	DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
CONST	ENDS
PUBLIC	ConvertUTF8toUTF16
PUBLIC	ConvertUTF16toUTF8
PUBLIC	ConvertUTF8toUTF32
PUBLIC	ConvertUTF32toUTF8
PUBLIC	ConvertUTF16toUTF32
PUBLIC	ConvertUTF32toUTF16
PUBLIC	isLegalUTF8Sequence
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF8toUTF16 DD imagerel $LN28
	DD	imagerel $LN28+996
	DD	imagerel $unwind$ConvertUTF8toUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF16toUTF8 DD imagerel $LN29
	DD	imagerel $LN29+838
	DD	imagerel $unwind$ConvertUTF16toUTF8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF8toUTF32 DD imagerel $LN23
	DD	imagerel $LN23+788
	DD	imagerel $unwind$ConvertUTF8toUTF32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF32toUTF8 DD imagerel $LN22
	DD	imagerel $LN22+660
	DD	imagerel $unwind$ConvertUTF32toUTF8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF16toUTF32 DD imagerel $LN15
	DD	imagerel $LN15+431
	DD	imagerel $unwind$ConvertUTF16toUTF32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertUTF32toUTF16 DD imagerel $LN17
	DD	imagerel $LN17+466
	DD	imagerel $unwind$ConvertUTF32toUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isLegalUTF8Sequence DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$isLegalUTF8Sequence
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isLegalUTF8 DD imagerel isLegalUTF8
	DD	imagerel isLegalUTF8+416
	DD	imagerel $unwind$isLegalUTF8
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isLegalUTF8 DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isLegalUTF8Sequence DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF32toUTF16 DD 021901H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF16toUTF32 DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF32toUTF8 DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF8toUTF32 DD 021901H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF16toUTF8 DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertUTF8toUTF16 DD 021901H
	DD	070159219H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT isLegalUTF8
_TEXT	SEGMENT
a$ = 0
srcptr$ = 8
tv66 = 16
tv81 = 20
source$ = 48
length$ = 56
isLegalUTF8 PROC					; COMDAT

; 287  : isLegalUTF8(const UTF8 *source, int length) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 288  :     UTF8 a;
; 289  :     const UTF8 *srcptr = source+length;

  0000e	48 63 44 24 38	 movsxd	 rax, DWORD PTR length$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR source$[rsp]
  00018	48 03 c8	 add	 rcx, rax
  0001b	48 8b c1	 mov	 rax, rcx
  0001e	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax

; 290  :     switch (length) {

  00023	8b 44 24 38	 mov	 eax, DWORD PTR length$[rsp]
  00027	89 44 24 10	 mov	 DWORD PTR tv66[rsp], eax
  0002b	83 7c 24 10 01	 cmp	 DWORD PTR tv66[rsp], 1
  00030	0f 84 2d 01 00
	00		 je	 $LN25@isLegalUTF
  00036	83 7c 24 10 02	 cmp	 DWORD PTR tv66[rsp], 2
  0003b	74 7f		 je	 SHORT $LN13@isLegalUTF
  0003d	83 7c 24 10 03	 cmp	 DWORD PTR tv66[rsp], 3
  00042	74 43		 je	 SHORT $LN10@isLegalUTF
  00044	83 7c 24 10 04	 cmp	 DWORD PTR tv66[rsp], 4
  00049	74 07		 je	 SHORT $LN7@isLegalUTF

; 291  :     default: return false;

  0004b	32 c0		 xor	 al, al
  0004d	e9 48 01 00 00	 jmp	 $LN1@isLegalUTF
$LN7@isLegalUTF:

; 292  : 	/* Everything else falls through when "true"... */
; 293  :     case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  00052	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  00057	48 ff c8	 dec	 rax
  0005a	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax
  0005f	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  00064	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00067	88 04 24	 mov	 BYTE PTR a$[rsp], al
  0006a	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  0006e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00073	7c 0b		 jl	 SHORT $LN9@isLegalUTF
  00075	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00079	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  0007e	7e 07		 jle	 SHORT $LN8@isLegalUTF
$LN9@isLegalUTF:
  00080	32 c0		 xor	 al, al
  00082	e9 13 01 00 00	 jmp	 $LN1@isLegalUTF
$LN8@isLegalUTF:
$LN10@isLegalUTF:

; 294  :     case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;

  00087	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  0008c	48 ff c8	 dec	 rax
  0008f	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax
  00094	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  00099	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009c	88 04 24	 mov	 BYTE PTR a$[rsp], al
  0009f	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  000a3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000a8	7c 0b		 jl	 SHORT $LN12@isLegalUTF
  000aa	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  000ae	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000b3	7e 07		 jle	 SHORT $LN11@isLegalUTF
$LN12@isLegalUTF:
  000b5	32 c0		 xor	 al, al
  000b7	e9 de 00 00 00	 jmp	 $LN1@isLegalUTF
$LN11@isLegalUTF:
$LN13@isLegalUTF:

; 295  :     case 2: if ((a = (*--srcptr)) > 0xBF) return false;

  000bc	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  000c1	48 ff c8	 dec	 rax
  000c4	48 89 44 24 08	 mov	 QWORD PTR srcptr$[rsp], rax
  000c9	48 8b 44 24 08	 mov	 rax, QWORD PTR srcptr$[rsp]
  000ce	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d1	88 04 24	 mov	 BYTE PTR a$[rsp], al
  000d4	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  000d8	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000dd	7e 07		 jle	 SHORT $LN14@isLegalUTF
  000df	32 c0		 xor	 al, al
  000e1	e9 b4 00 00 00	 jmp	 $LN1@isLegalUTF
$LN14@isLegalUTF:

; 296  : 
; 297  : 	switch (*source) {

  000e6	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  000eb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ee	88 44 24 14	 mov	 BYTE PTR tv81[rsp], al
  000f2	80 7c 24 14 e0	 cmp	 BYTE PTR tv81[rsp], 224	; 000000e0H
  000f7	74 17		 je	 SHORT $LN15@isLegalUTF
  000f9	80 7c 24 14 ed	 cmp	 BYTE PTR tv81[rsp], 237	; 000000edH
  000fe	74 21		 je	 SHORT $LN17@isLegalUTF
  00100	80 7c 24 14 f0	 cmp	 BYTE PTR tv81[rsp], 240	; 000000f0H
  00105	74 2b		 je	 SHORT $LN19@isLegalUTF
  00107	80 7c 24 14 f4	 cmp	 BYTE PTR tv81[rsp], 244	; 000000f4H
  0010c	74 35		 je	 SHORT $LN21@isLegalUTF
  0010e	eb 44		 jmp	 SHORT $LN23@isLegalUTF
$LN15@isLegalUTF:

; 298  : 	    /* no fall-through in this inner switch */
; 299  : 	    case 0xE0: if (a < 0xA0) return false; break;

  00110	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00114	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00119	7d 04		 jge	 SHORT $LN16@isLegalUTF
  0011b	32 c0		 xor	 al, al
  0011d	eb 7b		 jmp	 SHORT $LN1@isLegalUTF
$LN16@isLegalUTF:
  0011f	eb 42		 jmp	 SHORT $LN4@isLegalUTF
$LN17@isLegalUTF:

; 300  : 	    case 0xED: if (a > 0x9F) return false; break;

  00121	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00125	3d 9f 00 00 00	 cmp	 eax, 159		; 0000009fH
  0012a	7e 04		 jle	 SHORT $LN18@isLegalUTF
  0012c	32 c0		 xor	 al, al
  0012e	eb 6a		 jmp	 SHORT $LN1@isLegalUTF
$LN18@isLegalUTF:
  00130	eb 31		 jmp	 SHORT $LN4@isLegalUTF
$LN19@isLegalUTF:

; 301  : 	    case 0xF0: if (a < 0x90) return false; break;

  00132	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00136	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  0013b	7d 04		 jge	 SHORT $LN20@isLegalUTF
  0013d	32 c0		 xor	 al, al
  0013f	eb 59		 jmp	 SHORT $LN1@isLegalUTF
$LN20@isLegalUTF:
  00141	eb 20		 jmp	 SHORT $LN4@isLegalUTF
$LN21@isLegalUTF:

; 302  : 	    case 0xF4: if (a > 0x8F) return false; break;

  00143	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00147	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  0014c	7e 04		 jle	 SHORT $LN22@isLegalUTF
  0014e	32 c0		 xor	 al, al
  00150	eb 48		 jmp	 SHORT $LN1@isLegalUTF
$LN22@isLegalUTF:
  00152	eb 0f		 jmp	 SHORT $LN4@isLegalUTF
$LN23@isLegalUTF:

; 303  : 	    default:   if (a < 0x80) return false;

  00154	0f b6 04 24	 movzx	 eax, BYTE PTR a$[rsp]
  00158	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0015d	7d 04		 jge	 SHORT $LN24@isLegalUTF
  0015f	32 c0		 xor	 al, al
  00161	eb 37		 jmp	 SHORT $LN1@isLegalUTF
$LN24@isLegalUTF:
$LN4@isLegalUTF:
$LN25@isLegalUTF:

; 304  : 	}
; 305  : 
; 306  :     case 1: if (*source >= 0x80 && *source < 0xC2) return false;

  00163	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  00168	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00170	7c 13		 jl	 SHORT $LN26@isLegalUTF
  00172	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  00177	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017a	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  0017f	7d 04		 jge	 SHORT $LN26@isLegalUTF
  00181	32 c0		 xor	 al, al
  00183	eb 15		 jmp	 SHORT $LN1@isLegalUTF
$LN26@isLegalUTF:

; 307  :     }
; 308  :     if (*source > 0xF4) return false;

  00185	48 8b 44 24 30	 mov	 rax, QWORD PTR source$[rsp]
  0018a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018d	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  00192	7e 04		 jle	 SHORT $LN27@isLegalUTF
  00194	32 c0		 xor	 al, al
  00196	eb 02		 jmp	 SHORT $LN1@isLegalUTF
$LN27@isLegalUTF:

; 309  :     return true;

  00198	b0 01		 mov	 al, 1
$LN1@isLegalUTF:

; 310  : }

  0019a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019e	5f		 pop	 rdi
  0019f	c3		 ret	 0
isLegalUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT isLegalUTF8Sequence
_TEXT	SEGMENT
length$ = 32
source$ = 64
sourceEnd$ = 72
isLegalUTF8Sequence PROC				; COMDAT

; 319  : isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 320  :     int length = trailingBytesForUTF8[*source]+1;

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR source$[rsp]
  00014	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  0001e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00022	ff c0		 inc	 eax
  00024	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 321  :     if (source+length > sourceEnd) {

  00028	48 63 44 24 20	 movsxd	 rax, DWORD PTR length$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 3b 44 24 48	 cmp	 rax, QWORD PTR sourceEnd$[rsp]
  0003d	76 04		 jbe	 SHORT $LN2@isLegalUTF

; 322  : 	return false;

  0003f	32 c0		 xor	 al, al
  00041	eb 0e		 jmp	 SHORT $LN1@isLegalUTF
$LN2@isLegalUTF:

; 323  :     }
; 324  :     return isLegalUTF8(source, length);

  00043	8b 54 24 20	 mov	 edx, DWORD PTR length$[rsp]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR source$[rsp]
  0004c	e8 00 00 00 00	 call	 isLegalUTF8
$LN1@isLegalUTF:

; 325  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
isLegalUTF8Sequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF32toUTF16
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$1 = 24
sourceStart$ = 48
sourceEnd$ = 56
targetStart$ = 64
targetEnd$ = 72
flags$ = 80
ConvertUTF32toUTF16 PROC				; COMDAT

; 54   : 	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 55   :     ConversionResult result = conversionOK;

  00019	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 56   :     const UTF32* source = *sourceStart;

  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 57   :     UTF16* target = *targetStart;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR targetStart$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 58   :     while (source < sourceEnd) {

  0003a	48 8b 44 24 38	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  0003f	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00044	0f 83 65 01 00
	00		 jae	 $LN3@ConvertUTF

; 59   : 	UTF32 ch;
; 60   : 	if (target >= targetEnd) {

  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR targetEnd$[rsp]
  0004f	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  00054	72 0c		 jb	 SHORT $LN4@ConvertUTF

; 61   : 	    result = targetExhausted; break;

  00056	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  0005d	e9 4d 01 00 00	 jmp	 $LN3@ConvertUTF
$LN4@ConvertUTF:

; 62   : 	}
; 63   : 	ch = *source++;

  00062	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00067	8b 00		 mov	 eax, DWORD PTR [rax]
  00069	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
  0006d	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00072	48 83 c0 04	 add	 rax, 4
  00076	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 64   : 	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  0007b	81 7c 24 18 ff
	ff 00 00	 cmp	 DWORD PTR ch$1[rsp], 65535 ; 0000ffffH
  00083	77 74		 ja	 SHORT $LN5@ConvertUTF

; 65   : 	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
; 66   : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00085	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  0008d	72 4a		 jb	 SHORT $LN7@ConvertUTF
  0008f	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  00097	77 40		 ja	 SHORT $LN7@ConvertUTF

; 67   : 		if (flags == strictConversion) {

  00099	83 7c 24 50 00	 cmp	 DWORD PTR flags$[rsp], 0
  0009e	75 1c		 jne	 SHORT $LN9@ConvertUTF

; 68   : 		    --source; /* return to the illegal value itself */

  000a0	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000a5	48 83 e8 04	 sub	 rax, 4
  000a9	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 69   : 		    result = sourceIllegal;

  000ae	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 70   : 		    break;

  000b5	e9 f5 00 00 00	 jmp	 $LN3@ConvertUTF

; 71   : 		} else {

  000ba	eb 1b		 jmp	 SHORT $LN10@ConvertUTF
$LN9@ConvertUTF:

; 72   : 		    *target++ = UNI_REPLACEMENT_CHAR;

  000bc	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  000c1	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  000c6	66 89 01	 mov	 WORD PTR [rcx], ax
  000c9	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  000ce	48 83 c0 02	 add	 rax, 2
  000d2	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN10@ConvertUTF:

; 73   : 		}
; 74   : 	    } else {

  000d7	eb 1b		 jmp	 SHORT $LN8@ConvertUTF
$LN7@ConvertUTF:

; 75   : 		*target++ = (UTF16)ch; /* normal case */

  000d9	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  000de	0f b7 4c 24 18	 movzx	 ecx, WORD PTR ch$1[rsp]
  000e3	66 89 08	 mov	 WORD PTR [rax], cx
  000e6	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  000eb	48 83 c0 02	 add	 rax, 2
  000ef	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN8@ConvertUTF:

; 76   : 	    }

  000f4	e9 b1 00 00 00	 jmp	 $LN6@ConvertUTF
$LN5@ConvertUTF:

; 77   : 	} else if (ch > UNI_MAX_LEGAL_UTF32) {

  000f9	81 7c 24 18 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  00101	76 2d		 jbe	 SHORT $LN11@ConvertUTF

; 78   : 	    if (flags == strictConversion) {

  00103	83 7c 24 50 00	 cmp	 DWORD PTR flags$[rsp], 0
  00108	75 09		 jne	 SHORT $LN13@ConvertUTF

; 79   : 		result = sourceIllegal;

  0010a	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 80   : 	    } else {

  00111	eb 1b		 jmp	 SHORT $LN14@ConvertUTF
$LN13@ConvertUTF:

; 81   : 		*target++ = UNI_REPLACEMENT_CHAR;

  00113	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  00118	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0011d	66 89 01	 mov	 WORD PTR [rcx], ax
  00120	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00125	48 83 c0 02	 add	 rax, 2
  00129	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN14@ConvertUTF:

; 82   : 	    }
; 83   : 	} else {

  0012e	eb 7a		 jmp	 SHORT $LN12@ConvertUTF
$LN11@ConvertUTF:

; 84   : 	    /* target is a character in range 0xFFFF - 0x10FFFF. */
; 85   : 	    if (target + 1 >= targetEnd) {

  00130	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00135	48 83 c0 02	 add	 rax, 2
  00139	48 3b 44 24 48	 cmp	 rax, QWORD PTR targetEnd$[rsp]
  0013e	72 17		 jb	 SHORT $LN15@ConvertUTF

; 86   : 		--source; /* Back up source pointer! */

  00140	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00145	48 83 e8 04	 sub	 rax, 4
  00149	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 87   : 		result = targetExhausted; break;

  0014e	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  00155	eb 58		 jmp	 SHORT $LN3@ConvertUTF
$LN15@ConvertUTF:

; 88   : 	    }
; 89   : 	    ch -= halfBase;

  00157	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  0015b	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  00160	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax

; 90   : 	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  00164	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  00168	c1 e8 0a	 shr	 eax, 10
  0016b	05 00 d8 00 00	 add	 eax, 55296		; 0000d800H
  00170	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00175	66 89 01	 mov	 WORD PTR [rcx], ax
  00178	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  0017d	48 83 c0 02	 add	 rax, 2
  00181	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 91   : 	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  00186	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  0018a	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0018f	05 00 dc 00 00	 add	 eax, 56320		; 0000dc00H
  00194	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00199	66 89 01	 mov	 WORD PTR [rcx], ax
  0019c	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  001a1	48 83 c0 02	 add	 rax, 2
  001a5	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN12@ConvertUTF:
$LN6@ConvertUTF:

; 92   : 	}
; 93   :     }

  001aa	e9 8b fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 94   :     *sourceStart = source;

  001af	48 8b 44 24 30	 mov	 rax, QWORD PTR sourceStart$[rsp]
  001b4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  001b9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 95   :     *targetStart = target;

  001bc	48 8b 44 24 40	 mov	 rax, QWORD PTR targetStart$[rsp]
  001c1	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001c6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 96   :     return result;

  001c9	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 97   : }

  001cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d0	5f		 pop	 rdi
  001d1	c3		 ret	 0
ConvertUTF32toUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF16toUTF32
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$ = 24
ch2$ = 28
oldSource$1 = 32
sourceStart$ = 64
sourceEnd$ = 72
targetStart$ = 80
targetEnd$ = 88
flags$ = 96
ConvertUTF16toUTF32 PROC				; COMDAT

; 103  : 	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 104  :     ConversionResult result = conversionOK;

  00019	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 105  :     const UTF16* source = *sourceStart;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 106  :     UTF32* target = *targetStart;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 107  :     UTF32 ch, ch2;
; 108  :     while (source < sourceEnd) {

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  0003f	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00044	0f 83 42 01 00
	00		 jae	 $LN3@ConvertUTF

; 109  : 	const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */

  0004a	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0004f	48 89 44 24 20	 mov	 QWORD PTR oldSource$1[rsp], rax

; 110  : 	ch = *source++;

  00054	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00059	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0005c	89 44 24 18	 mov	 DWORD PTR ch$[rsp], eax
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00065	48 83 c0 02	 add	 rax, 2
  00069	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 111  : 	/* If we have a surrogate pair, convert to UTF32 first. */
; 112  : 	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  0006e	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  00076	0f 82 a1 00 00
	00		 jb	 $LN4@ConvertUTF
  0007c	81 7c 24 18 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00084	0f 87 93 00 00
	00		 ja	 $LN4@ConvertUTF

; 113  : 	    /* If the 16 bits following the high surrogate are in the source buffer... */
; 114  : 	    if (source < sourceEnd) {

  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  0008f	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00094	73 6e		 jae	 SHORT $LN6@ConvertUTF

; 115  : 		ch2 = *source;

  00096	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0009b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0009e	89 44 24 1c	 mov	 DWORD PTR ch2$[rsp], eax

; 116  : 		/* If it's a low surrogate, convert to UTF32. */
; 117  : 		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  000a2	81 7c 24 1c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000aa	72 35		 jb	 SHORT $LN8@ConvertUTF
  000ac	81 7c 24 1c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000b4	77 2b		 ja	 SHORT $LN8@ConvertUTF

; 118  : 		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  000b6	8b 44 24 18	 mov	 eax, DWORD PTR ch$[rsp]
  000ba	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  000bf	c1 e0 0a	 shl	 eax, 10
  000c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR ch2$[rsp]
  000c6	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  000cd	89 44 24 18	 mov	 DWORD PTR ch$[rsp], eax

; 119  : 			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
; 120  : 		    ++source;

  000d1	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000d6	48 83 c0 02	 add	 rax, 2
  000da	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax
  000df	eb 21		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 121  : 		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  000e1	83 7c 24 60 00	 cmp	 DWORD PTR flags$[rsp], 0
  000e6	75 1a		 jne	 SHORT $LN10@ConvertUTF

; 122  : 		    --source; /* return to the illegal value itself */

  000e8	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000ed	48 83 e8 02	 sub	 rax, 2
  000f1	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 123  : 		    result = sourceIllegal;

  000f6	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 124  : 		    break;

  000fd	e9 8a 00 00 00	 jmp	 $LN3@ConvertUTF
$LN10@ConvertUTF:
$LN9@ConvertUTF:

; 125  : 		}
; 126  : 	    } else { /* We don't have the 16 bits following the high surrogate. */

  00102	eb 17		 jmp	 SHORT $LN7@ConvertUTF
$LN6@ConvertUTF:

; 127  : 		--source; /* return to the high surrogate */

  00104	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00109	48 83 e8 02	 sub	 rax, 2
  0010d	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 128  : 		result = sourceExhausted;

  00112	c7 04 24 01 00
	00 00		 mov	 DWORD PTR result$[rsp], 1

; 129  : 		break;

  00119	eb 71		 jmp	 SHORT $LN3@ConvertUTF
$LN7@ConvertUTF:

; 130  : 	    }

  0011b	eb 32		 jmp	 SHORT $LN5@ConvertUTF
$LN4@ConvertUTF:

; 131  : 	} else if (flags == strictConversion) {

  0011d	83 7c 24 60 00	 cmp	 DWORD PTR flags$[rsp], 0
  00122	75 2b		 jne	 SHORT $LN11@ConvertUTF

; 132  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 133  : 	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  00124	81 7c 24 18 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  0012c	72 21		 jb	 SHORT $LN12@ConvertUTF
  0012e	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  00136	77 17		 ja	 SHORT $LN12@ConvertUTF

; 134  : 		--source; /* return to the illegal value itself */

  00138	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0013d	48 83 e8 02	 sub	 rax, 2
  00141	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 135  : 		result = sourceIllegal;

  00146	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 136  : 		break;

  0014d	eb 3d		 jmp	 SHORT $LN3@ConvertUTF
$LN12@ConvertUTF:
$LN11@ConvertUTF:
$LN5@ConvertUTF:

; 137  : 	    }
; 138  : 	}
; 139  : 	if (target >= targetEnd) {

  0014f	48 8b 44 24 58	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00154	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  00159	72 13		 jb	 SHORT $LN13@ConvertUTF

; 140  : 	    source = oldSource; /* Back up source pointer! */

  0015b	48 8b 44 24 20	 mov	 rax, QWORD PTR oldSource$1[rsp]
  00160	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 141  : 	    result = targetExhausted; break;

  00165	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  0016c	eb 1e		 jmp	 SHORT $LN3@ConvertUTF
$LN13@ConvertUTF:

; 142  : 	}
; 143  : 	*target++ = ch;

  0016e	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00173	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$[rsp]
  00177	89 08		 mov	 DWORD PTR [rax], ecx
  00179	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  0017e	48 83 c0 04	 add	 rax, 4
  00182	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 144  :     }

  00187	e9 ae fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 145  :     *sourceStart = source;

  0018c	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00191	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  00196	48 89 08	 mov	 QWORD PTR [rax], rcx

; 146  :     *targetStart = target;

  00199	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  0019e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001a3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 147  : #ifdef CVTUTF_DEBUG
; 148  : if (result == sourceIllegal) {
; 149  :     ANTLR3_FPRINTF(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
; 150  :     fflush(stderr);
; 151  : }
; 152  : #endif
; 153  :     return result;

  001a6	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 154  : }

  001a9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ad	5f		 pop	 rdi
  001ae	c3		 ret	 0
ConvertUTF16toUTF32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF32toUTF8
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$1 = 24
bytesToWrite$2 = 28
byteMask$3 = 32
byteMark$4 = 36
tv81 = 40
sourceStart$ = 64
sourceEnd$ = 72
targetStart$ = 80
targetEnd$ = 88
flags$ = 96
ConvertUTF32toUTF8 PROC					; COMDAT

; 404  : 	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

$LN22:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 405  :     ConversionResult result = conversionOK;

  00019	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 406  :     const UTF32* source = *sourceStart;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 407  :     UTF8* target = *targetStart;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 408  :     while (source < sourceEnd) {

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  0003f	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00044	0f 83 27 02 00
	00		 jae	 $LN3@ConvertUTF

; 409  : 	UTF32 ch;
; 410  : 	unsigned short bytesToWrite = 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 411  : 	const UTF32 byteMask = 0xBF;

  00051	c7 44 24 20 bf
	00 00 00	 mov	 DWORD PTR byteMask$3[rsp], 191 ; 000000bfH

; 412  : 	const UTF32 byteMark = 0x80; 

  00059	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR byteMark$4[rsp], 128 ; 00000080H

; 413  : 	ch = *source++;

  00061	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00066	8b 00		 mov	 eax, DWORD PTR [rax]
  00068	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
  0006c	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00071	48 83 c0 04	 add	 rax, 4
  00075	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 414  : 	if (flags == strictConversion ) {

  0007a	83 7c 24 60 00	 cmp	 DWORD PTR flags$[rsp], 0
  0007f	75 2e		 jne	 SHORT $LN6@ConvertUTF

; 415  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 416  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00081	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  00089	72 24		 jb	 SHORT $LN7@ConvertUTF
  0008b	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  00093	77 1a		 ja	 SHORT $LN7@ConvertUTF

; 417  : 		--source; /* return to the illegal value itself */

  00095	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0009a	48 83 e8 04	 sub	 rax, 4
  0009e	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 418  : 		result = sourceIllegal;

  000a3	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 419  : 		break;

  000aa	e9 c2 01 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:
$LN6@ConvertUTF:

; 420  : 	    }
; 421  : 	}
; 422  : 	/*
; 423  : 	 * Figure out how many bytes the result will require. Turn any
; 424  : 	 * illegally large UTF32 things (> Plane 17) into replacement chars.
; 425  : 	 */
; 426  : 	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;

  000af	81 7c 24 18 80
	00 00 00	 cmp	 DWORD PTR ch$1[rsp], 128 ; 00000080H
  000b7	73 0c		 jae	 SHORT $LN8@ConvertUTF
  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  000c3	eb 5b		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 427  : 	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  000c5	81 7c 24 18 00
	08 00 00	 cmp	 DWORD PTR ch$1[rsp], 2048 ; 00000800H
  000cd	73 0c		 jae	 SHORT $LN10@ConvertUTF
  000cf	b8 02 00 00 00	 mov	 eax, 2
  000d4	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  000d9	eb 45		 jmp	 SHORT $LN11@ConvertUTF
$LN10@ConvertUTF:

; 428  : 	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  000db	81 7c 24 18 00
	00 01 00	 cmp	 DWORD PTR ch$1[rsp], 65536 ; 00010000H
  000e3	73 0c		 jae	 SHORT $LN12@ConvertUTF
  000e5	b8 03 00 00 00	 mov	 eax, 3
  000ea	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  000ef	eb 2f		 jmp	 SHORT $LN13@ConvertUTF
$LN12@ConvertUTF:

; 429  : 	} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;

  000f1	81 7c 24 18 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  000f9	77 0c		 ja	 SHORT $LN14@ConvertUTF
  000fb	b8 04 00 00 00	 mov	 eax, 4
  00100	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  00105	eb 19		 jmp	 SHORT $LN15@ConvertUTF
$LN14@ConvertUTF:

; 430  : 	} else {			    bytesToWrite = 3;

  00107	b8 03 00 00 00	 mov	 eax, 3
  0010c	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 431  : 					    ch = UNI_REPLACEMENT_CHAR;

  00111	c7 44 24 18 fd
	ff 00 00	 mov	 DWORD PTR ch$1[rsp], 65533 ; 0000fffdH

; 432  : 					    result = sourceIllegal;

  00119	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3
$LN15@ConvertUTF:
$LN13@ConvertUTF:
$LN11@ConvertUTF:
$LN9@ConvertUTF:

; 433  : 	}
; 434  : 	
; 435  : 	target += bytesToWrite;

  00120	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00125	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 436  : 	if (target > targetEnd) {

  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR targetEnd$[rsp]
  0013a	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  0013f	76 2f		 jbe	 SHORT $LN16@ConvertUTF

; 437  : 	    --source; /* Back up source pointer! */

  00141	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00146	48 83 e8 04	 sub	 rax, 4
  0014a	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 438  : 	    target -= bytesToWrite; result = targetExhausted; break;

  0014f	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00154	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00159	48 2b c8	 sub	 rcx, rax
  0015c	48 8b c1	 mov	 rax, rcx
  0015f	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  00164	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  0016b	e9 01 01 00 00	 jmp	 $LN3@ConvertUTF
$LN16@ConvertUTF:

; 439  : 	}
; 440  : 	switch (bytesToWrite) { /* note: everything falls through. */

  00170	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00175	89 44 24 28	 mov	 DWORD PTR tv81[rsp], eax
  00179	83 7c 24 28 01	 cmp	 DWORD PTR tv81[rsp], 1
  0017e	0f 84 a7 00 00
	00		 je	 $LN20@ConvertUTF
  00184	83 7c 24 28 02	 cmp	 DWORD PTR tv81[rsp], 2
  00189	74 71		 je	 SHORT $LN19@ConvertUTF
  0018b	83 7c 24 28 03	 cmp	 DWORD PTR tv81[rsp], 3
  00190	74 3b		 je	 SHORT $LN18@ConvertUTF
  00192	83 7c 24 28 04	 cmp	 DWORD PTR tv81[rsp], 4
  00197	74 05		 je	 SHORT $LN17@ConvertUTF
  00199	e9 b9 00 00 00	 jmp	 $LN4@ConvertUTF
$LN17@ConvertUTF:

; 441  : 	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  0019e	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  001a3	48 ff c8	 dec	 rax
  001a6	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  001ab	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  001af	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  001b3	0b c8		 or	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  001bb	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001c0	88 01		 mov	 BYTE PTR [rcx], al
  001c2	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  001c6	c1 e8 06	 shr	 eax, 6
  001c9	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN18@ConvertUTF:

; 442  : 	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  001cd	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  001d2	48 ff c8	 dec	 rax
  001d5	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  001da	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  001de	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  001e2	0b c8		 or	 ecx, eax
  001e4	8b c1		 mov	 eax, ecx
  001e6	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  001ea	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001ef	88 01		 mov	 BYTE PTR [rcx], al
  001f1	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  001f5	c1 e8 06	 shr	 eax, 6
  001f8	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN19@ConvertUTF:

; 443  : 	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  001fc	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00201	48 ff c8	 dec	 rax
  00204	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  00209	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  0020d	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00211	0b c8		 or	 ecx, eax
  00213	8b c1		 mov	 eax, ecx
  00215	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  00219	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0021e	88 01		 mov	 BYTE PTR [rcx], al
  00220	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  00224	c1 e8 06	 shr	 eax, 6
  00227	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN20@ConvertUTF:

; 444  : 	    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);

  0022b	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00230	48 ff c8	 dec	 rax
  00233	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  00238	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstByteMark
  00244	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00248	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  0024c	0b c8		 or	 ecx, eax
  0024e	8b c1		 mov	 eax, ecx
  00250	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00255	88 01		 mov	 BYTE PTR [rcx], al
$LN4@ConvertUTF:

; 445  : 	}
; 446  : 	target += bytesToWrite;

  00257	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  0025c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00261	48 03 c8	 add	 rcx, rax
  00264	48 8b c1	 mov	 rax, rcx
  00267	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 447  :     }

  0026c	e9 c9 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 448  :     *sourceStart = source;

  00271	48 8b 44 24 40	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00276	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  0027b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 449  :     *targetStart = target;

  0027e	48 8b 44 24 50	 mov	 rax, QWORD PTR targetStart$[rsp]
  00283	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00288	48 89 08	 mov	 QWORD PTR [rax], rcx

; 450  :     return result;

  0028b	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 451  : }

  0028e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00292	5f		 pop	 rdi
  00293	c3		 ret	 0
ConvertUTF32toUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF8toUTF32
_TEXT	SEGMENT
result$ = 32
source$ = 40
target$ = 48
ch$1 = 56
extraBytesToRead$2 = 60
tv80 = 64
sourceStart$ = 96
sourceEnd$ = 104
targetStart$ = 112
targetEnd$ = 120
flags$ = 128
ConvertUTF8toUTF32 PROC					; COMDAT

; 457  : 	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

$LN23:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 458  :     ConversionResult result = conversionOK;

  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 459  :     const UTF8* source = *sourceStart;

  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 460  :     UTF32* target = *targetStart;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 461  :     while (source < sourceEnd) {

  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00040	48 39 44 24 28	 cmp	 QWORD PTR source$[rsp], rax
  00045	0f 83 8b 02 00
	00		 jae	 $LN3@ConvertUTF

; 462  : 	UTF32 ch = 0;

  0004b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ch$1[rsp], 0

; 463  : 	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00058	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00062	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  00067	66 89 44 24 3c	 mov	 WORD PTR extraBytesToRead$2[rsp], ax

; 464  : 	if (source + extraBytesToRead >= sourceEnd) {

  0006c	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 3b 44 24 68	 cmp	 rax, QWORD PTR sourceEnd$[rsp]
  00081	72 0d		 jb	 SHORT $LN6@ConvertUTF

; 465  : 	    result = sourceExhausted; break;

  00083	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1
  0008b	e9 46 02 00 00	 jmp	 $LN3@ConvertUTF
$LN6@ConvertUTF:

; 466  : 	}
; 467  : 	/* Do this check whether lenient or strict */
; 468  : 	if (! isLegalUTF8(source, extraBytesToRead+1)) {

  00090	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00095	ff c0		 inc	 eax
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  0009e	e8 00 00 00 00	 call	 isLegalUTF8
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	85 c0		 test	 eax, eax
  000a8	75 0d		 jne	 SHORT $LN7@ConvertUTF

; 469  : 	    result = sourceIllegal;

  000aa	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 470  : 	    break;

  000b2	e9 1f 02 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 471  : 	}
; 472  : 	/*
; 473  : 	 * The cases all fall through. See "Note A" below.
; 474  : 	 */
; 475  : 	switch (extraBytesToRead) {

  000b7	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  000bc	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  000c0	83 7c 24 40 05	 cmp	 DWORD PTR tv80[rsp], 5
  000c5	0f 87 15 01 00
	00		 ja	 $LN4@ConvertUTF
  000cb	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv80[rsp]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000d7	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN22@ConvertUTF[rcx+rax*4]
  000de	48 03 c1	 add	 rax, rcx
  000e1	ff e0		 jmp	 rax
$LN8@ConvertUTF:

; 476  : 	    case 5: ch += *source++; ch <<= 6;

  000e3	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  000e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000eb	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  000ef	03 c8		 add	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00104	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00108	c1 e0 06	 shl	 eax, 6
  0010b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN9@ConvertUTF:

; 477  : 	    case 4: ch += *source++; ch <<= 6;

  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00114	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00117	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0011b	03 c8		 add	 ecx, eax
  0011d	8b c1		 mov	 eax, ecx
  0011f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00128	48 ff c0	 inc	 rax
  0012b	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00130	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00134	c1 e0 06	 shl	 eax, 6
  00137	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN10@ConvertUTF:

; 478  : 	    case 3: ch += *source++; ch <<= 6;

  0013b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00140	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00143	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00147	03 c8		 add	 ecx, eax
  00149	8b c1		 mov	 eax, ecx
  0014b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0014f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00154	48 ff c0	 inc	 rax
  00157	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  0015c	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00160	c1 e0 06	 shl	 eax, 6
  00163	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN11@ConvertUTF:

; 479  : 	    case 2: ch += *source++; ch <<= 6;

  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  0016c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016f	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00173	03 c8		 add	 ecx, eax
  00175	8b c1		 mov	 eax, ecx
  00177	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00180	48 ff c0	 inc	 rax
  00183	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00188	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  0018c	c1 e0 06	 shl	 eax, 6
  0018f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN12@ConvertUTF:

; 480  : 	    case 1: ch += *source++; ch <<= 6;

  00193	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00198	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019b	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0019f	03 c8		 add	 ecx, eax
  001a1	8b c1		 mov	 eax, ecx
  001a3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001ac	48 ff c0	 inc	 rax
  001af	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  001b4	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  001b8	c1 e0 06	 shl	 eax, 6
  001bb	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN13@ConvertUTF:

; 481  : 	    case 0: ch += *source++;

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001c4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c7	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001cb	03 c8		 add	 ecx, eax
  001cd	8b c1		 mov	 eax, ecx
  001cf	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001d8	48 ff c0	 inc	 rax
  001db	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
$LN4@ConvertUTF:

; 482  : 	}
; 483  : 	ch -= offsetsFromUTF8[extraBytesToRead];

  001e0	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  001ec	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001ef	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001f3	2b c8		 sub	 ecx, eax
  001f5	8b c1		 mov	 eax, ecx
  001f7	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax

; 484  : 
; 485  : 	if (target >= targetEnd) {

  001fb	48 8b 44 24 78	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00200	48 39 44 24 30	 cmp	 QWORD PTR target$[rsp], rax
  00205	72 26		 jb	 SHORT $LN14@ConvertUTF

; 486  : 	    source -= (extraBytesToRead+1); /* Back up the source pointer! */

  00207	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  0020c	ff c0		 inc	 eax
  0020e	48 98		 cdqe
  00210	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00215	48 2b c8	 sub	 rcx, rax
  00218	48 8b c1	 mov	 rax, rcx
  0021b	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 487  : 	    result = targetExhausted; break;

  00220	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2
  00228	e9 a9 00 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 488  : 	}
; 489  : 	if (ch <= UNI_MAX_LEGAL_UTF32) {

  0022d	81 7c 24 38 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  00235	77 79		 ja	 SHORT $LN15@ConvertUTF

; 490  : 	    /*
; 491  : 	     * UTF-16 surrogate values are illegal in UTF-32, and anything
; 492  : 	     * over Plane 17 (> 0x10FFFF) is illegal.
; 493  : 	     */
; 494  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00237	81 7c 24 38 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  0023f	72 54		 jb	 SHORT $LN17@ConvertUTF
  00241	81 7c 24 38 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  00249	77 4a		 ja	 SHORT $LN17@ConvertUTF

; 495  : 		if (flags == strictConversion) {

  0024b	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  00253	75 25		 jne	 SHORT $LN19@ConvertUTF

; 496  : 		    source -= (extraBytesToRead+1); /* return to the illegal value itself */

  00255	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  0025a	ff c0		 inc	 eax
  0025c	48 98		 cdqe
  0025e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00263	48 2b c8	 sub	 rcx, rax
  00266	48 8b c1	 mov	 rax, rcx
  00269	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 497  : 		    result = sourceIllegal;

  0026e	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 498  : 		    break;

  00276	eb 5e		 jmp	 SHORT $LN3@ConvertUTF

; 499  : 		} else {

  00278	eb 19		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 500  : 		    *target++ = UNI_REPLACEMENT_CHAR;

  0027a	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  0027f	c7 00 fd ff 00
	00		 mov	 DWORD PTR [rax], 65533	; 0000fffdH
  00285	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  0028a	48 83 c0 04	 add	 rax, 4
  0028e	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN20@ConvertUTF:

; 501  : 		}
; 502  : 	    } else {

  00293	eb 19		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 503  : 		*target++ = ch;

  00295	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  0029a	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0029e	89 08		 mov	 DWORD PTR [rax], ecx
  002a0	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002a5	48 83 c0 04	 add	 rax, 4
  002a9	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN18@ConvertUTF:

; 504  : 	    }
; 505  : 	} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */

  002ae	eb 21		 jmp	 SHORT $LN16@ConvertUTF
$LN15@ConvertUTF:

; 506  : 	    result = sourceIllegal;

  002b0	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 507  : 	    *target++ = UNI_REPLACEMENT_CHAR;

  002b8	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002bd	c7 00 fd ff 00
	00		 mov	 DWORD PTR [rax], 65533	; 0000fffdH
  002c3	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002c8	48 83 c0 04	 add	 rax, 4
  002cc	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN16@ConvertUTF:

; 508  : 	}
; 509  :     }

  002d1	e9 65 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 510  :     *sourceStart = source;

  002d6	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  002db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  002e0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 511  :     *targetStart = target;

  002e3	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  002e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  002ed	48 89 08	 mov	 QWORD PTR [rax], rcx

; 512  :     return result;

  002f0	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 513  : }

  002f4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002f8	5f		 pop	 rdi
  002f9	c3		 ret	 0
  002fa	66 90		 npad	 2
$LN22@ConvertUTF:
  002fc	00 00 00 00	 DD	 $LN13@ConvertUTF
  00300	00 00 00 00	 DD	 $LN12@ConvertUTF
  00304	00 00 00 00	 DD	 $LN11@ConvertUTF
  00308	00 00 00 00	 DD	 $LN10@ConvertUTF
  0030c	00 00 00 00	 DD	 $LN9@ConvertUTF
  00310	00 00 00 00	 DD	 $LN8@ConvertUTF
ConvertUTF8toUTF32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF16toUTF8
_TEXT	SEGMENT
result$ = 0
source$ = 8
target$ = 16
ch$1 = 24
bytesToWrite$2 = 28
byteMask$3 = 32
byteMark$4 = 36
oldSource$5 = 40
ch2$6 = 48
tv128 = 52
sourceStart$ = 80
sourceEnd$ = 88
targetStart$ = 96
targetEnd$ = 104
flags$ = 112
ConvertUTF16toUTF8 PROC					; COMDAT

; 207  : 	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

$LN29:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 208  :     ConversionResult result = conversionOK;

  00019	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 209  :     const UTF16* source = *sourceStart;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 210  :     UTF8* target = *targetStart;

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR targetStart$[rsp]
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 211  :     while (source < sourceEnd) {

  0003a	48 8b 44 24 58	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  0003f	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  00044	0f 83 d9 02 00
	00		 jae	 $LN3@ConvertUTF

; 212  : 	UTF32 ch;
; 213  : 	unsigned short bytesToWrite = 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 214  : 	const UTF32 byteMask = 0xBF;

  00051	c7 44 24 20 bf
	00 00 00	 mov	 DWORD PTR byteMask$3[rsp], 191 ; 000000bfH

; 215  : 	const UTF32 byteMark = 0x80; 

  00059	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR byteMark$4[rsp], 128 ; 00000080H

; 216  : 	const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */

  00061	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00066	48 89 44 24 28	 mov	 QWORD PTR oldSource$5[rsp], rax

; 217  : 	ch = *source++;

  0006b	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00070	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00073	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  0007c	48 83 c0 02	 add	 rax, 2
  00080	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 218  : 	/* If we have a surrogate pair, convert to UTF32 first. */
; 219  : 	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00085	81 7c 24 18 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  0008d	0f 82 a4 00 00
	00		 jb	 $LN6@ConvertUTF
  00093	81 7c 24 18 ff
	db 00 00	 cmp	 DWORD PTR ch$1[rsp], 56319 ; 0000dbffH
  0009b	0f 87 96 00 00
	00		 ja	 $LN6@ConvertUTF

; 220  : 	    /* If the 16 bits following the high surrogate are in the source buffer... */
; 221  : 	    if (source < sourceEnd) {

  000a1	48 8b 44 24 58	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  000a6	48 39 44 24 08	 cmp	 QWORD PTR source$[rsp], rax
  000ab	73 6e		 jae	 SHORT $LN8@ConvertUTF

; 222  : 		UTF32 ch2 = *source;

  000ad	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000b2	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000b5	89 44 24 30	 mov	 DWORD PTR ch2$6[rsp], eax

; 223  : 		/* If it's a low surrogate, convert to UTF32. */
; 224  : 		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  000b9	81 7c 24 30 00
	dc 00 00	 cmp	 DWORD PTR ch2$6[rsp], 56320 ; 0000dc00H
  000c1	72 35		 jb	 SHORT $LN10@ConvertUTF
  000c3	81 7c 24 30 ff
	df 00 00	 cmp	 DWORD PTR ch2$6[rsp], 57343 ; 0000dfffH
  000cb	77 2b		 ja	 SHORT $LN10@ConvertUTF

; 225  : 		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  000cd	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  000d1	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  000d6	c1 e0 0a	 shl	 eax, 10
  000d9	8b 4c 24 30	 mov	 ecx, DWORD PTR ch2$6[rsp]
  000dd	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  000e4	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax

; 226  : 			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
; 227  : 		    ++source;

  000e8	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  000ed	48 83 c0 02	 add	 rax, 2
  000f1	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax
  000f6	eb 21		 jmp	 SHORT $LN11@ConvertUTF
$LN10@ConvertUTF:

; 228  : 		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  000f8	83 7c 24 70 00	 cmp	 DWORD PTR flags$[rsp], 0
  000fd	75 1a		 jne	 SHORT $LN12@ConvertUTF

; 229  : 		    --source; /* return to the illegal value itself */

  000ff	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00104	48 83 e8 02	 sub	 rax, 2
  00108	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 230  : 		    result = sourceIllegal;

  0010d	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 231  : 		    break;

  00114	e9 0a 02 00 00	 jmp	 $LN3@ConvertUTF
$LN12@ConvertUTF:
$LN11@ConvertUTF:

; 232  : 		}
; 233  : 	    } else { /* We don't have the 16 bits following the high surrogate. */

  00119	eb 1a		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 234  : 		--source; /* return to the high surrogate */

  0011b	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00120	48 83 e8 02	 sub	 rax, 2
  00124	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 235  : 		result = sourceExhausted;

  00129	c7 04 24 01 00
	00 00		 mov	 DWORD PTR result$[rsp], 1

; 236  : 		break;

  00130	e9 ee 01 00 00	 jmp	 $LN3@ConvertUTF
$LN9@ConvertUTF:

; 237  : 	    }

  00135	eb 35		 jmp	 SHORT $LN7@ConvertUTF
$LN6@ConvertUTF:

; 238  :         } else if (flags == strictConversion) {

  00137	83 7c 24 70 00	 cmp	 DWORD PTR flags$[rsp], 0
  0013c	75 2e		 jne	 SHORT $LN13@ConvertUTF

; 239  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 240  : 	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  0013e	81 7c 24 18 00
	dc 00 00	 cmp	 DWORD PTR ch$1[rsp], 56320 ; 0000dc00H
  00146	72 24		 jb	 SHORT $LN14@ConvertUTF
  00148	81 7c 24 18 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  00150	77 1a		 ja	 SHORT $LN14@ConvertUTF

; 241  : 		--source; /* return to the illegal value itself */

  00152	48 8b 44 24 08	 mov	 rax, QWORD PTR source$[rsp]
  00157	48 83 e8 02	 sub	 rax, 2
  0015b	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 242  : 		result = sourceIllegal;

  00160	c7 04 24 03 00
	00 00		 mov	 DWORD PTR result$[rsp], 3

; 243  : 		break;

  00167	e9 b7 01 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:
$LN13@ConvertUTF:
$LN7@ConvertUTF:

; 244  : 	    }
; 245  : 	}
; 246  : 	/* Figure out how many bytes the result will require */
; 247  : 	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;

  0016c	81 7c 24 18 80
	00 00 00	 cmp	 DWORD PTR ch$1[rsp], 128 ; 00000080H
  00174	73 0c		 jae	 SHORT $LN15@ConvertUTF
  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  00180	eb 54		 jmp	 SHORT $LN16@ConvertUTF
$LN15@ConvertUTF:

; 248  : 	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  00182	81 7c 24 18 00
	08 00 00	 cmp	 DWORD PTR ch$1[rsp], 2048 ; 00000800H
  0018a	73 0c		 jae	 SHORT $LN17@ConvertUTF
  0018c	b8 02 00 00 00	 mov	 eax, 2
  00191	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  00196	eb 3e		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 249  : 	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  00198	81 7c 24 18 00
	00 01 00	 cmp	 DWORD PTR ch$1[rsp], 65536 ; 00010000H
  001a0	73 0c		 jae	 SHORT $LN19@ConvertUTF
  001a2	b8 03 00 00 00	 mov	 eax, 3
  001a7	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  001ac	eb 28		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 250  : 	} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;

  001ae	81 7c 24 18 00
	00 11 00	 cmp	 DWORD PTR ch$1[rsp], 1114112 ; 00110000H
  001b6	73 0c		 jae	 SHORT $LN21@ConvertUTF
  001b8	b8 04 00 00 00	 mov	 eax, 4
  001bd	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax
  001c2	eb 12		 jmp	 SHORT $LN22@ConvertUTF
$LN21@ConvertUTF:

; 251  : 	} else {			    bytesToWrite = 3;

  001c4	b8 03 00 00 00	 mov	 eax, 3
  001c9	66 89 44 24 1c	 mov	 WORD PTR bytesToWrite$2[rsp], ax

; 252  : 					    ch = UNI_REPLACEMENT_CHAR;

  001ce	c7 44 24 18 fd
	ff 00 00	 mov	 DWORD PTR ch$1[rsp], 65533 ; 0000fffdH
$LN22@ConvertUTF:
$LN20@ConvertUTF:
$LN18@ConvertUTF:
$LN16@ConvertUTF:

; 253  : 	}
; 254  : 
; 255  : 	target += bytesToWrite;

  001d6	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  001db	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  001e0	48 03 c8	 add	 rcx, rax
  001e3	48 8b c1	 mov	 rax, rcx
  001e6	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 256  : 	if (target > targetEnd) {

  001eb	48 8b 44 24 68	 mov	 rax, QWORD PTR targetEnd$[rsp]
  001f0	48 39 44 24 10	 cmp	 QWORD PTR target$[rsp], rax
  001f5	76 2b		 jbe	 SHORT $LN23@ConvertUTF

; 257  : 	    source = oldSource; /* Back up source pointer! */

  001f7	48 8b 44 24 28	 mov	 rax, QWORD PTR oldSource$5[rsp]
  001fc	48 89 44 24 08	 mov	 QWORD PTR source$[rsp], rax

; 258  : 	    target -= bytesToWrite; result = targetExhausted; break;

  00201	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00206	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0020b	48 2b c8	 sub	 rcx, rax
  0020e	48 8b c1	 mov	 rax, rcx
  00211	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  00216	c7 04 24 02 00
	00 00		 mov	 DWORD PTR result$[rsp], 2
  0021d	e9 01 01 00 00	 jmp	 $LN3@ConvertUTF
$LN23@ConvertUTF:

; 259  : 	}
; 260  : 	switch (bytesToWrite) { /* note: everything falls through. */

  00222	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  00227	89 44 24 34	 mov	 DWORD PTR tv128[rsp], eax
  0022b	83 7c 24 34 01	 cmp	 DWORD PTR tv128[rsp], 1
  00230	0f 84 a7 00 00
	00		 je	 $LN27@ConvertUTF
  00236	83 7c 24 34 02	 cmp	 DWORD PTR tv128[rsp], 2
  0023b	74 71		 je	 SHORT $LN26@ConvertUTF
  0023d	83 7c 24 34 03	 cmp	 DWORD PTR tv128[rsp], 3
  00242	74 3b		 je	 SHORT $LN25@ConvertUTF
  00244	83 7c 24 34 04	 cmp	 DWORD PTR tv128[rsp], 4
  00249	74 05		 je	 SHORT $LN24@ConvertUTF
  0024b	e9 b9 00 00 00	 jmp	 $LN4@ConvertUTF
$LN24@ConvertUTF:

; 261  : 	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00250	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00255	48 ff c8	 dec	 rax
  00258	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  0025d	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  00261	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00265	0b c8		 or	 ecx, eax
  00267	8b c1		 mov	 eax, ecx
  00269	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  0026d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00272	88 01		 mov	 BYTE PTR [rcx], al
  00274	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  00278	c1 e8 06	 shr	 eax, 6
  0027b	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN25@ConvertUTF:

; 262  : 	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  0027f	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  00284	48 ff c8	 dec	 rax
  00287	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  0028c	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  00290	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  00294	0b c8		 or	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  0029c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  002a1	88 01		 mov	 BYTE PTR [rcx], al
  002a3	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  002a7	c1 e8 06	 shr	 eax, 6
  002aa	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN26@ConvertUTF:

; 263  : 	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  002ae	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  002b3	48 ff c8	 dec	 rax
  002b6	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  002bb	8b 44 24 24	 mov	 eax, DWORD PTR byteMark$4[rsp]
  002bf	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  002c3	0b c8		 or	 ecx, eax
  002c5	8b c1		 mov	 eax, ecx
  002c7	23 44 24 20	 and	 eax, DWORD PTR byteMask$3[rsp]
  002cb	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  002d0	88 01		 mov	 BYTE PTR [rcx], al
  002d2	8b 44 24 18	 mov	 eax, DWORD PTR ch$1[rsp]
  002d6	c1 e8 06	 shr	 eax, 6
  002d9	89 44 24 18	 mov	 DWORD PTR ch$1[rsp], eax
$LN27@ConvertUTF:

; 264  : 	    case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);

  002dd	48 8b 44 24 10	 mov	 rax, QWORD PTR target$[rsp]
  002e2	48 ff c8	 dec	 rax
  002e5	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax
  002ea	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  002ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:firstByteMark
  002f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002fa	8b 4c 24 18	 mov	 ecx, DWORD PTR ch$1[rsp]
  002fe	0b c8		 or	 ecx, eax
  00300	8b c1		 mov	 eax, ecx
  00302	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00307	88 01		 mov	 BYTE PTR [rcx], al
$LN4@ConvertUTF:

; 265  : 	}
; 266  : 	target += bytesToWrite;

  00309	0f b7 44 24 1c	 movzx	 eax, WORD PTR bytesToWrite$2[rsp]
  0030e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  00313	48 03 c8	 add	 rcx, rax
  00316	48 8b c1	 mov	 rax, rcx
  00319	48 89 44 24 10	 mov	 QWORD PTR target$[rsp], rax

; 267  :     }

  0031e	e9 17 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 268  :     *sourceStart = source;

  00323	48 8b 44 24 50	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00328	48 8b 4c 24 08	 mov	 rcx, QWORD PTR source$[rsp]
  0032d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 269  :     *targetStart = target;

  00330	48 8b 44 24 60	 mov	 rax, QWORD PTR targetStart$[rsp]
  00335	48 8b 4c 24 10	 mov	 rcx, QWORD PTR target$[rsp]
  0033a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 270  :     return result;

  0033d	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 271  : }

  00340	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00344	5f		 pop	 rdi
  00345	c3		 ret	 0
ConvertUTF16toUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3convertutf.c
;	COMDAT ConvertUTF8toUTF16
_TEXT	SEGMENT
result$ = 32
source$ = 40
target$ = 48
ch$1 = 56
extraBytesToRead$2 = 60
tv80 = 64
sourceStart$ = 96
sourceEnd$ = 104
targetStart$ = 112
targetEnd$ = 120
flags$ = 128
ConvertUTF8toUTF16 PROC					; COMDAT

; 331  : 	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

$LN28:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 332  :     ConversionResult result = conversionOK;

  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 333  :     const UTF8* source = *sourceStart;

  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 334  :     UTF16* target = *targetStart;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN2@ConvertUTF:

; 335  :     while (source < sourceEnd) {

  0003b	48 8b 44 24 68	 mov	 rax, QWORD PTR sourceEnd$[rsp]
  00040	48 39 44 24 28	 cmp	 QWORD PTR source$[rsp], rax
  00045	0f 83 5a 03 00
	00		 jae	 $LN3@ConvertUTF

; 336  : 	UTF32 ch = 0;

  0004b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ch$1[rsp], 0

; 337  : 	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00058	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00062	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  00067	66 89 44 24 3c	 mov	 WORD PTR extraBytesToRead$2[rsp], ax

; 338  : 	if (source + extraBytesToRead >= sourceEnd) {

  0006c	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 3b 44 24 68	 cmp	 rax, QWORD PTR sourceEnd$[rsp]
  00081	72 0d		 jb	 SHORT $LN6@ConvertUTF

; 339  : 	    result = sourceExhausted; break;

  00083	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1
  0008b	e9 15 03 00 00	 jmp	 $LN3@ConvertUTF
$LN6@ConvertUTF:

; 340  : 	}
; 341  : 	/* Do this check whether lenient or strict */
; 342  : 	if (! isLegalUTF8(source, extraBytesToRead+1)) {

  00090	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  00095	ff c0		 inc	 eax
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  0009e	e8 00 00 00 00	 call	 isLegalUTF8
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	85 c0		 test	 eax, eax
  000a8	75 0d		 jne	 SHORT $LN7@ConvertUTF

; 343  : 	    result = sourceIllegal;

  000aa	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 344  : 	    break;

  000b2	e9 ee 02 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 345  : 	}
; 346  : 	/*
; 347  : 	 * The cases all fall through. See "Note A" below.
; 348  : 	 */
; 349  : 	switch (extraBytesToRead) {

  000b7	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  000bc	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  000c0	83 7c 24 40 05	 cmp	 DWORD PTR tv80[rsp], 5
  000c5	0f 87 15 01 00
	00		 ja	 $LN4@ConvertUTF
  000cb	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv80[rsp]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000d7	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@ConvertUTF[rcx+rax*4]
  000de	48 03 c1	 add	 rax, rcx
  000e1	ff e0		 jmp	 rax
$LN8@ConvertUTF:

; 350  : 	    case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  000e3	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  000e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000eb	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  000ef	03 c8		 add	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00104	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00108	c1 e0 06	 shl	 eax, 6
  0010b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN9@ConvertUTF:

; 351  : 	    case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00114	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00117	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0011b	03 c8		 add	 ecx, eax
  0011d	8b c1		 mov	 eax, ecx
  0011f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00128	48 ff c0	 inc	 rax
  0012b	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00130	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00134	c1 e0 06	 shl	 eax, 6
  00137	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN10@ConvertUTF:

; 352  : 	    case 3: ch += *source++; ch <<= 6;

  0013b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00140	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00143	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00147	03 c8		 add	 ecx, eax
  00149	8b c1		 mov	 eax, ecx
  0014b	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0014f	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00154	48 ff c0	 inc	 rax
  00157	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  0015c	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00160	c1 e0 06	 shl	 eax, 6
  00163	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN11@ConvertUTF:

; 353  : 	    case 2: ch += *source++; ch <<= 6;

  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  0016c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016f	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  00173	03 c8		 add	 ecx, eax
  00175	8b c1		 mov	 eax, ecx
  00177	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00180	48 ff c0	 inc	 rax
  00183	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  00188	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  0018c	c1 e0 06	 shl	 eax, 6
  0018f	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN12@ConvertUTF:

; 354  : 	    case 1: ch += *source++; ch <<= 6;

  00193	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  00198	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019b	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  0019f	03 c8		 add	 ecx, eax
  001a1	8b c1		 mov	 eax, ecx
  001a3	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001ac	48 ff c0	 inc	 rax
  001af	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
  001b4	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  001b8	c1 e0 06	 shl	 eax, 6
  001bb	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
$LN13@ConvertUTF:

; 355  : 	    case 0: ch += *source++;

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001c4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c7	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001cb	03 c8		 add	 ecx, eax
  001cd	8b c1		 mov	 eax, ecx
  001cf	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax
  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR source$[rsp]
  001d8	48 ff c0	 inc	 rax
  001db	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax
$LN4@ConvertUTF:

; 356  : 	}
; 357  : 	ch -= offsetsFromUTF8[extraBytesToRead];

  001e0	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  001ec	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001ef	8b 4c 24 38	 mov	 ecx, DWORD PTR ch$1[rsp]
  001f3	2b c8		 sub	 ecx, eax
  001f5	8b c1		 mov	 eax, ecx
  001f7	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax

; 358  : 
; 359  : 	if (target >= targetEnd) {

  001fb	48 8b 44 24 78	 mov	 rax, QWORD PTR targetEnd$[rsp]
  00200	48 39 44 24 30	 cmp	 QWORD PTR target$[rsp], rax
  00205	72 26		 jb	 SHORT $LN14@ConvertUTF

; 360  : 	    source -= (extraBytesToRead+1); /* Back up source pointer! */

  00207	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  0020c	ff c0		 inc	 eax
  0020e	48 98		 cdqe
  00210	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00215	48 2b c8	 sub	 rcx, rax
  00218	48 8b c1	 mov	 rax, rcx
  0021b	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 361  : 	    result = targetExhausted; break;

  00220	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2
  00228	e9 78 01 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 362  : 	}
; 363  : 	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  0022d	81 7c 24 38 ff
	ff 00 00	 cmp	 DWORD PTR ch$1[rsp], 65535 ; 0000ffffH
  00235	0f 87 83 00 00
	00		 ja	 $LN15@ConvertUTF

; 364  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 365  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0023b	81 7c 24 38 00
	d8 00 00	 cmp	 DWORD PTR ch$1[rsp], 55296 ; 0000d800H
  00243	72 59		 jb	 SHORT $LN17@ConvertUTF
  00245	81 7c 24 38 ff
	df 00 00	 cmp	 DWORD PTR ch$1[rsp], 57343 ; 0000dfffH
  0024d	77 4f		 ja	 SHORT $LN17@ConvertUTF

; 366  : 		if (flags == strictConversion) {

  0024f	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  00257	75 28		 jne	 SHORT $LN19@ConvertUTF

; 367  : 		    source -= (extraBytesToRead+1); /* return to the illegal value itself */

  00259	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  0025e	ff c0		 inc	 eax
  00260	48 98		 cdqe
  00262	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00267	48 2b c8	 sub	 rcx, rax
  0026a	48 8b c1	 mov	 rax, rcx
  0026d	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 368  : 		    result = sourceIllegal;

  00272	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 369  : 		    break;

  0027a	e9 26 01 00 00	 jmp	 $LN3@ConvertUTF

; 370  : 		} else {

  0027f	eb 1b		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 371  : 		    *target++ = UNI_REPLACEMENT_CHAR;

  00281	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  00286	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  0028b	66 89 01	 mov	 WORD PTR [rcx], ax
  0028e	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00293	48 83 c0 02	 add	 rax, 2
  00297	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN20@ConvertUTF:

; 372  : 		}
; 373  : 	    } else {

  0029c	eb 1b		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 374  : 		*target++ = (UTF16)ch; /* normal case */

  0029e	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002a3	0f b7 4c 24 38	 movzx	 ecx, WORD PTR ch$1[rsp]
  002a8	66 89 08	 mov	 WORD PTR [rax], cx
  002ab	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  002b0	48 83 c0 02	 add	 rax, 2
  002b4	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN18@ConvertUTF:

; 375  : 	    }

  002b9	e9 e2 00 00 00	 jmp	 $LN16@ConvertUTF
$LN15@ConvertUTF:

; 376  : 	} else if (ch > UNI_MAX_UTF16) {

  002be	81 7c 24 38 ff
	ff 10 00	 cmp	 DWORD PTR ch$1[rsp], 1114111 ; 0010ffffH
  002c6	76 52		 jbe	 SHORT $LN21@ConvertUTF

; 377  : 	    if (flags == strictConversion) {

  002c8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR flags$[rsp], 0
  002d0	75 28		 jne	 SHORT $LN23@ConvertUTF

; 378  : 		result = sourceIllegal;

  002d2	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR result$[rsp], 3

; 379  : 		source -= (extraBytesToRead+1); /* return to the start */

  002da	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  002df	ff c0		 inc	 eax
  002e1	48 98		 cdqe
  002e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  002e8	48 2b c8	 sub	 rcx, rax
  002eb	48 8b c1	 mov	 rax, rcx
  002ee	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 380  : 		break; /* Bail out; shouldn't continue */

  002f3	e9 ad 00 00 00	 jmp	 $LN3@ConvertUTF

; 381  : 	    } else {

  002f8	eb 1b		 jmp	 SHORT $LN24@ConvertUTF
$LN23@ConvertUTF:

; 382  : 		*target++ = UNI_REPLACEMENT_CHAR;

  002fa	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH
  002ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  00304	66 89 01	 mov	 WORD PTR [rcx], ax
  00307	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  0030c	48 83 c0 02	 add	 rax, 2
  00310	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN24@ConvertUTF:

; 383  : 	    }
; 384  : 	} else {

  00315	e9 86 00 00 00	 jmp	 $LN22@ConvertUTF
$LN21@ConvertUTF:

; 385  : 	    /* target is a character in range 0xFFFF - 0x10FFFF. */
; 386  : 	    if (target + 1 >= targetEnd) {

  0031a	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  0031f	48 83 c0 02	 add	 rax, 2
  00323	48 3b 44 24 78	 cmp	 rax, QWORD PTR targetEnd$[rsp]
  00328	72 23		 jb	 SHORT $LN25@ConvertUTF

; 387  : 		source -= (extraBytesToRead+1); /* Back up source pointer! */

  0032a	0f b7 44 24 3c	 movzx	 eax, WORD PTR extraBytesToRead$2[rsp]
  0032f	ff c0		 inc	 eax
  00331	48 98		 cdqe
  00333	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  00338	48 2b c8	 sub	 rcx, rax
  0033b	48 8b c1	 mov	 rax, rcx
  0033e	48 89 44 24 28	 mov	 QWORD PTR source$[rsp], rax

; 388  : 		result = targetExhausted; break;

  00343	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR result$[rsp], 2
  0034b	eb 58		 jmp	 SHORT $LN3@ConvertUTF
$LN25@ConvertUTF:

; 389  : 	    }
; 390  : 	    ch -= halfBase;

  0034d	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00351	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  00356	89 44 24 38	 mov	 DWORD PTR ch$1[rsp], eax

; 391  : 	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  0035a	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  0035e	c1 e8 0a	 shr	 eax, 10
  00361	05 00 d8 00 00	 add	 eax, 55296		; 0000d800H
  00366	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  0036b	66 89 01	 mov	 WORD PTR [rcx], ax
  0036e	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00373	48 83 c0 02	 add	 rax, 2
  00377	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax

; 392  : 	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  0037c	8b 44 24 38	 mov	 eax, DWORD PTR ch$1[rsp]
  00380	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00385	05 00 dc 00 00	 add	 eax, 56320		; 0000dc00H
  0038a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  0038f	66 89 01	 mov	 WORD PTR [rcx], ax
  00392	48 8b 44 24 30	 mov	 rax, QWORD PTR target$[rsp]
  00397	48 83 c0 02	 add	 rax, 2
  0039b	48 89 44 24 30	 mov	 QWORD PTR target$[rsp], rax
$LN22@ConvertUTF:
$LN16@ConvertUTF:

; 393  : 	}
; 394  :     }

  003a0	e9 96 fc ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 395  :     *sourceStart = source;

  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR sourceStart$[rsp]
  003aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR source$[rsp]
  003af	48 89 08	 mov	 QWORD PTR [rax], rcx

; 396  :     *targetStart = target;

  003b2	48 8b 44 24 70	 mov	 rax, QWORD PTR targetStart$[rsp]
  003b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR target$[rsp]
  003bc	48 89 08	 mov	 QWORD PTR [rax], rcx

; 397  :     return result;

  003bf	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 398  : }

  003c3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003c7	5f		 pop	 rdi
  003c8	c3		 ret	 0
  003c9	0f 1f 00	 npad	 3
$LN27@ConvertUTF:
  003cc	00 00 00 00	 DD	 $LN13@ConvertUTF
  003d0	00 00 00 00	 DD	 $LN12@ConvertUTF
  003d4	00 00 00 00	 DD	 $LN11@ConvertUTF
  003d8	00 00 00 00	 DD	 $LN10@ConvertUTF
  003dc	00 00 00 00	 DD	 $LN9@ConvertUTF
  003e0	00 00 00 00	 DD	 $LN8@ConvertUTF
ConvertUTF8toUTF16 ENDP
_TEXT	ENDS
END
