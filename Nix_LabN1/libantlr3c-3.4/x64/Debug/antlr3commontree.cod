; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3CommonTreeNew
PUBLIC	antlr3CommonTreeNewFromToken
PUBLIC	antlr3ArboretumNew
PUBLIC	antlr3SetCTAPI
PUBLIC	??_C@_03ILAMHENH@nil@				; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	antlr3VectorFactoryNew:PROC
EXTRN	antlr3StackNew:PROC
EXTRN	antlr3BaseTreeNew:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTreeNew DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$antlr3CommonTreeNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTreeNewFromToken DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$antlr3CommonTreeNewFromToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ArboretumNew DD imagerel $LN5
	DD	imagerel $LN5+278
	DD	imagerel $unwind$antlr3ArboretumNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3SetCTAPI DD imagerel $LN3
	DD	imagerel $LN3+432
	DD	imagerel $unwind$antlr3SetCTAPI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getToken DD imagerel getToken
	DD	imagerel getToken+20
	DD	imagerel $unwind$getToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupNode DD imagerel dupNode
	DD	imagerel dupNode+58
	DD	imagerel $unwind$dupNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isNilNode DD imagerel isNilNode
	DD	imagerel isNilNode+31
	DD	imagerel $unwind$isNilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+71
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+32
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+149
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+137
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toString DD imagerel toString
	DD	imagerel toString+123
	DD	imagerel $unwind$toString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getParent DD imagerel getParent
	DD	imagerel getParent+24
	DD	imagerel $unwind$getParent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setParent DD imagerel setParent
	DD	imagerel setParent+71
	DD	imagerel $unwind$setParent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChildIndex DD imagerel setChildIndex
	DD	imagerel setChildIndex+27
	DD	imagerel $unwind$setChildIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildIndex DD imagerel getChildIndex
	DD	imagerel getChildIndex+19
	DD	imagerel $unwind$getChildIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createChildrenList DD imagerel createChildrenList
	DD	imagerel createChildrenList+79
	DD	imagerel $unwind$createChildrenList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reuse DD	imagerel reuse
	DD	imagerel reuse+130
	DD	imagerel $unwind$reuse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPool DD imagerel newPool
	DD	imagerel newPool+120
	DD	imagerel $unwind$newPool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPoolTree DD imagerel newPoolTree
	DD	imagerel newPoolTree+244
	DD	imagerel $unwind$newPoolTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newFromTree DD imagerel newFromTree
	DD	imagerel newFromTree+98
	DD	imagerel $unwind$newFromTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newFromToken DD imagerel newFromToken
	DD	imagerel newFromToken+76
	DD	imagerel $unwind$newFromToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$factoryClose DD imagerel factoryClose
	DD	imagerel factoryClose+193
	DD	imagerel $unwind$factoryClose
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_03ILAMHENH@nil@
CONST	SEGMENT
??_C@_03ILAMHENH@nil@ DB 'nil', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factoryClose DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newFromToken DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newFromTree DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPoolTree DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPool DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reuse DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createChildrenList DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildIndex DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChildIndex DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setParent DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getParent DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toString DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isNilNode DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupNode DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getToken DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3SetCTAPI DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ArboretumNew DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTreeNewFromToken DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTreeNew DD 020601H
	DD	070025206H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT factoryClose
_TEXT	SEGMENT
poolCount$ = 32
factory$ = 64
factoryClose PROC					; COMDAT

; 253  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 254  : 	ANTLR3_INT32	    poolCount;
; 255  : 
; 256  : 	// First close the vector factory that supplied all the child pointer
; 257  : 	// vectors.
; 258  : 	//
; 259  : 	factory->vFactory->close(factory->vFactory);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0001b	48 8b 89 48 01
	00 00		 mov	 rcx, QWORD PTR [rcx+328]
  00022	ff 90 78 01 00
	00		 call	 QWORD PTR [rax+376]

; 260  : 
; 261  :     if  (factory->nilStack !=  NULL)

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0002d	48 83 b8 50 01
	00 00 00	 cmp	 QWORD PTR [rax+336], 0
  00035	74 1b		 je	 SHORT $LN5@factoryClo

; 262  :     {
; 263  :         factory->nilStack->free(factory->nilStack);

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0003c	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00048	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  0004f	ff 50 10	 call	 QWORD PTR [rax+16]
$LN5@factoryClo:

; 264  :     }
; 265  : 
; 266  : 	// We now JUST free the pools because the C runtime CommonToken based tree
; 267  : 	// cannot contain anything that was not made by this factory.
; 268  : 	//
; 269  : 	for	(poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  00052	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  0005a	eb 0a		 jmp	 SHORT $LN4@factoryClo
$LN2@factoryClo:
  0005c	8b 44 24 20	 mov	 eax, DWORD PTR poolCount$[rsp]
  00060	ff c0		 inc	 eax
  00062	89 44 24 20	 mov	 DWORD PTR poolCount$[rsp], eax
$LN4@factoryClo:
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0006b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006e	39 44 24 20	 cmp	 DWORD PTR poolCount$[rsp], eax
  00072	7f 2e		 jg	 SHORT $LN3@factoryClo

; 270  : 	{
; 271  : 		// We can now free this pool allocation
; 272  : 		//
; 273  : 		ANTLR3_FREE(factory->pools[poolCount]);

  00074	48 63 44 24 20	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 274  : 		factory->pools[poolCount] = NULL;

  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00095	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00098	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 275  : 	}

  000a0	eb ba		 jmp	 SHORT $LN2@factoryClo
$LN3@factoryClo:

; 276  : 
; 277  : 	// All the pools are deallocated we can free the pointers to the pools
; 278  : 	// now.
; 279  : 	//
; 280  : 	ANTLR3_FREE(factory->pools);

  000a2	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000a7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 281  : 
; 282  : 	// Finally, we can free the space for the factory itself
; 283  : 	//
; 284  : 	ANTLR3_FREE(factory);

  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 285  : }

  000bb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
factoryClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT newFromToken
_TEXT	SEGMENT
newTree$ = 32
factory$ = 64
token$ = 72
newFromToken PROC					; COMDAT

; 234  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 235  : 	pANTLR3_BASE_TREE	newTree;
; 236  : 
; 237  : 	newTree = factory->newTree(factory);

  0000f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00019	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  0001f	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 238  : 
; 239  : 	if	(newTree == NULL)

  00024	48 83 7c 24 20
	00		 cmp	 QWORD PTR newTree$[rsp], 0
  0002a	75 04		 jne	 SHORT $LN2@newFromTok

; 240  : 	{
; 241  : 		return	NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 16		 jmp	 SHORT $LN1@newFromTok
$LN2@newFromTok:

; 242  : 	}
; 243  : 
; 244  : 	// Pick up the payload we had in the supplied tree
; 245  : 	//
; 246  : 	((pANTLR3_COMMON_TREE)(newTree->super))->token = token;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 8b 4c 24 48	 mov	 rcx, QWORD PTR token$[rsp]
  0003d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 247  : 
; 248  : 	return newTree;

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
$LN1@newFromTok:

; 249  : }

  00046	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
newFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT newFromTree
_TEXT	SEGMENT
newTree$ = 32
factory$ = 64
tree$ = 72
newFromTree PROC					; COMDAT

; 214  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 215  : 	pANTLR3_BASE_TREE	newTree;
; 216  : 
; 217  : 	newTree = factory->newTree(factory);

  0000f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00019	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  0001f	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 218  : 
; 219  : 	if	(newTree == NULL)

  00024	48 83 7c 24 20
	00		 cmp	 QWORD PTR newTree$[rsp], 0
  0002a	75 04		 jne	 SHORT $LN2@newFromTre

; 220  : 	{
; 221  : 		return	NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 2c		 jmp	 SHORT $LN1@newFromTre
$LN2@newFromTre:

; 222  : 	}
; 223  : 
; 224  : 	// Pick up the payload we had in the supplied tree
; 225  : 	//
; 226  : 	((pANTLR3_COMMON_TREE)(newTree->super))->token   = tree->token;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tree$[rsp]
  0003d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00041	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 227  : 	newTree->u		    = tree->baseTree.u;							// Copy any user pointer

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tree$[rsp]
  0004f	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00053	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 228  : 
; 229  : 	return  newTree;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
$LN1@newFromTre:

; 230  : }

  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
newFromTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT newPoolTree
_TEXT	SEGMENT
tree$ = 32
factory$ = 64
newPoolTree PROC					; COMDAT

; 155  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 156  : 	pANTLR3_COMMON_TREE    tree;
; 157  : 
; 158  :     // If we have anything on the re claim stack, reuse that sucker first
; 159  :     //
; 160  :     tree = factory->nilStack->peek(factory->nilStack);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0001b	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  00022	ff 50 38	 call	 QWORD PTR [rax+56]
  00025	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 161  : 
; 162  :     if  (tree != NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR tree$[rsp], 0
  00030	74 25		 je	 SHORT $LN2@newPoolTre

; 163  :     {
; 164  :         // Cool we got something we could reuse, it will have been cleaned up by
; 165  :         // whatever put it back on the stack (for instance if it had a child vector,
; 166  :         // that will have been cleared to hold zero entries and that vector will get reused too.
; 167  :         // It is the basetree pointer that is placed on the stack of course
; 168  :         //
; 169  :         factory->nilStack->pop(factory->nilStack);

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00037	48 8b 80 50 01
	00 00		 mov	 rax, QWORD PTR [rax+336]
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00043	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  0004a	ff 50 18	 call	 QWORD PTR [rax+24]

; 170  :         return (pANTLR3_BASE_TREE)tree;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  00052	e9 97 00 00 00	 jmp	 $LN1@newPoolTre
$LN2@newPoolTre:

; 171  : 
; 172  :     }
; 173  : 	// See if we need a new tree pool before allocating a new tree
; 174  : 	//
; 175  : 	if	(factory->nextTree >= ANTLR3_FACTORY_POOL_SIZE)

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0005c	81 78 0c 00 04
	00 00		 cmp	 DWORD PTR [rax+12], 1024 ; 00000400H
  00063	72 0a		 jb	 SHORT $LN3@newPoolTre

; 176  : 	{
; 177  : 		// We ran out of tokens in the current pool, so we need a new pool
; 178  : 		//
; 179  : 		newPool(factory);

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0006a	e8 00 00 00 00	 call	 newPool
$LN3@newPoolTre:

; 180  : 	}
; 181  : 
; 182  : 	// Assuming everything went well - we are trying for performance here so doing minimal
; 183  : 	// error checking - then we can work out what the pointer is to the next commontree.
; 184  : 	//
; 185  : 	tree   = factory->pools[factory->thisPool] + factory->nextTree;

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00074	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0007d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00080	48 8b 54 24 40	 mov	 rdx, QWORD PTR factory$[rsp]
  00085	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  00088	48 69 d2 38 01
	00 00		 imul	 rdx, rdx, 312		; 00000138H
  0008f	48 03 14 c1	 add	 rdx, QWORD PTR [rcx+rax*8]
  00093	48 8b c2	 mov	 rax, rdx
  00096	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 186  : 	factory->nextTree++;

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000a0	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a3	ff c0		 inc	 eax
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000aa	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 187  : 
; 188  : 	// We have our token pointer now, so we can initialize it to the predefined model.
; 189  : 	//
; 190  :     antlr3SetCTAPI(tree);

  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  000b2	e8 00 00 00 00	 call	 antlr3SetCTAPI

; 191  : 
; 192  :     // Set some initial variables for future copying, including a string factory
; 193  :     // that we can use later for converting trees to strings.
; 194  :     //
; 195  : 	tree->factory				= factory;

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000c1	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 196  :     tree->baseTree.strFactory	= factory->unTruc.baseTree.strFactory;

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000cf	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000d3	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 197  : 
; 198  : 	// The super points to the common tree so we must override the one used by
; 199  : 	// by the pre-built tree as otherwise we will always poitn to the same initial
; 200  : 	// common tree and we might spend 3 hours trying to debug why - this would never
; 201  : 	// happen to me of course! :-(
; 202  : 	//
; 203  : 	tree->baseTree.super	= tree;

  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  000e1	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 204  : 
; 205  : 
; 206  : 	// And we are done
; 207  : 	//
; 208  : 	return  &(tree->baseTree);

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  000ea	48 83 c0 38	 add	 rax, 56			; 00000038H
$LN1@newPoolTre:

; 209  : }

  000ee	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
newPoolTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT newPool
_TEXT	SEGMENT
factory$ = 48
newPool	PROC						; COMDAT

; 125  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 126  :     // Increment factory count
; 127  :     //
; 128  :     factory->thisPool++;

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	ff c0		 inc	 eax
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00019	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 129  : 
; 130  :     // Ensure we have enough pointers allocated
; 131  :     //
; 132  :     factory->pools = (pANTLR3_COMMON_TREE *)

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	ff c0		 inc	 eax
  00026	48 98		 cdqe
  00028	48 c1 e0 03	 shl	 rax, 3
  0002c	8b c0		 mov	 eax, eax
  0002e	8b d0		 mov	 edx, eax
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00043	48 89 01	 mov	 QWORD PTR [rcx], rax

; 133  : 					ANTLR3_REALLOC(	(void *)factory->pools,										// Current pools pointer (starts at NULL)
; 134  : 					(ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TREE *))	// Memory for new pool pointers
; 135  : 					);
; 136  : 
; 137  :     // Allocate a new pool for the factory
; 138  :     //
; 139  :     factory->pools[factory->thisPool]	=

  00046	b9 00 e0 04 00	 mov	 ecx, 319488		; 0004e000H
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00056	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  0005a	48 8b 54 24 30	 mov	 rdx, QWORD PTR factory$[rsp]
  0005f	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00062	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 140  : 			    (pANTLR3_COMMON_TREE) 
; 141  : 				ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_COMMON_TREE) * ANTLR3_FACTORY_POOL_SIZE));
; 142  : 
; 143  : 
; 144  :     // Reset the counters
; 145  :     //
; 146  :     factory->nextTree	= 0;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0006b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 147  :   
; 148  :     // Done
; 149  :     //
; 150  :     return;
; 151  : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
newPool	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT reuse
_TEXT	SEGMENT
cTree$ = 32
tv76 = 40
tree$ = 64
reuse	PROC						; COMDAT

; 531  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 532  :     pANTLR3_COMMON_TREE	    cTree;
; 533  : 
; 534  : 	cTree   = (pANTLR3_COMMON_TREE)(tree->super);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 89 44 24 20	 mov	 QWORD PTR cTree$[rsp], rax

; 535  : 
; 536  :     if  (cTree->factory != NULL)

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR cTree$[rsp]
  0001c	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00021	74 59		 je	 SHORT $LN2@reuse

; 537  :     {
; 538  : 
; 539  :         if  (cTree->baseTree.children != NULL)

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR cTree$[rsp]
  00028	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  0002d	74 18		 je	 SHORT $LN3@reuse

; 540  :         {
; 541  :             
; 542  :             cTree->baseTree.children->clear(cTree->baseTree.children);

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR cTree$[rsp]
  00034	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cTree$[rsp]
  0003d	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00041	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
$LN3@reuse:

; 543  :         }
; 544  :        cTree->factory->nilStack->push(cTree->factory->nilStack, tree, NULL);

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR cTree$[rsp]
  0004c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cTree$[rsp]
  00055	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00059	48 8b 89 50 01
	00 00		 mov	 rcx, QWORD PTR [rcx+336]
  00060	48 89 4c 24 28	 mov	 QWORD PTR tv76[rsp], rcx
  00065	45 33 c0	 xor	 r8d, r8d
  00068	48 8b 54 24 40	 mov	 rdx, QWORD PTR tree$[rsp]
  0006d	48 8b 88 50 01
	00 00		 mov	 rcx, QWORD PTR [rax+336]
  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR tv76[rsp]
  00079	ff 50 28	 call	 QWORD PTR [rax+40]
$LN2@reuse:

; 545  :        
; 546  :     }
; 547  : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
reuse	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT createChildrenList
_TEXT	SEGMENT
tv74 = 32
tree$ = 64
createChildrenList PROC					; COMDAT

; 375  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 376  : 	tree->children = ((pANTLR3_COMMON_TREE)(tree->super))->factory->vFactory->newVector(((pANTLR3_COMMON_TREE)(tree->super))->factory->vFactory);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0001b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00022	48 8b 89 48 01
	00 00		 mov	 rcx, QWORD PTR [rcx+328]
  00029	48 89 4c 24 20	 mov	 QWORD PTR tv74[rsp], rcx
  0002e	48 8b 88 48 01
	00 00		 mov	 rcx, QWORD PTR [rax+328]
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR tv74[rsp]
  0003a	ff 90 80 01 00
	00		 call	 QWORD PTR [rax+384]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00045	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 377  : }

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
createChildrenList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getChildIndex
_TEXT	SEGMENT
tree$ = 16
getChildIndex PROC					; COMDAT

; 522  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 523  : 	return ((pANTLR3_COMMON_TREE)(tree->super))->childIndex;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]

; 524  : }

  00011	5f		 pop	 rdi
  00012	c3		 ret	 0
getChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT setChildIndex
_TEXT	SEGMENT
tree$ = 16
i$ = 24
setChildIndex PROC					; COMDAT

; 517  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 518  : 	((pANTLR3_COMMON_TREE)(tree->super))->childIndex = i;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	8b 4c 24 18	 mov	 ecx, DWORD PTR i$[rsp]
  00016	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 519  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT setParent
_TEXT	SEGMENT
tv69 = 0
tree$ = 32
parent$ = 40
setParent PROC						; COMDAT

; 511  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 512  : 	((pANTLR3_COMMON_TREE)(tree->super))->parent = parent == NULL ? NULL : ((pANTLR3_COMMON_TREE)(parent->super))->parent;

  0000f	48 83 7c 24 28
	00		 cmp	 QWORD PTR parent$[rsp], 0
  00015	75 0a		 jne	 SHORT $LN3@setParent
  00017	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR tv69[rsp], 0
  0001f	eb 10		 jmp	 SHORT $LN4@setParent
$LN3@setParent:
  00021	48 8b 44 24 28	 mov	 rax, QWORD PTR parent$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0002d	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
$LN4@setParent:
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  00036	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00039	48 8b 0c 24	 mov	 rcx, QWORD PTR tv69[rsp]
  0003d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 513  : }

  00041	48 83 c4 10	 add	 rsp, 16
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
setParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getParent
_TEXT	SEGMENT
tree$ = 16
getParent PROC						; COMDAT

; 505  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 506  : 	return & (((pANTLR3_COMMON_TREE)(tree->super))->parent->baseTree);

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00012	48 83 c0 38	 add	 rax, 56			; 00000038H

; 507  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
getParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT toString
_TEXT	SEGMENT
nilNode$1 = 32
tv83 = 40
tree$ = 64
toString PROC						; COMDAT

; 490  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 491  : 	if  (tree->isNilNode(tree) == ANTLR3_TRUE)

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00014	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 2e		 jne	 SHORT $LN2@toString

; 492  : 	{
; 493  : 		pANTLR3_STRING  nilNode;
; 494  : 
; 495  : 		nilNode	= tree->strFactory->newPtr(tree->strFactory, (pANTLR3_UINT8)"nil", 3);

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00027	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0002b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ILAMHENH@nil@
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0003d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00041	ff 50 20	 call	 QWORD PTR [rax+32]
  00044	48 89 44 24 20	 mov	 QWORD PTR nilNode$1[rsp], rax

; 496  : 
; 497  : 		return nilNode;

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR nilNode$1[rsp]
  0004e	eb 25		 jmp	 SHORT $LN1@toString
$LN2@toString:

; 498  : 	}
; 499  : 
; 500  : 	return	((pANTLR3_COMMON_TREE)(tree->super))->token->getText(((pANTLR3_COMMON_TREE)(tree->super))->token);

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0005d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00060	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00064	48 89 4c 24 28	 mov	 QWORD PTR tv83[rsp], rcx
  00069	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv83[rsp]
  00072	ff 50 78	 call	 QWORD PTR [rax+120]
$LN1@toString:

; 501  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
token$ = 32
child$1 = 40
tree$ = 64
getCharPositionInLine PROC				; COMDAT

; 469  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 470  : 	pANTLR3_COMMON_TOKEN    token;
; 471  : 
; 472  : 	token   = ((pANTLR3_COMMON_TREE)(tree->super))->token;

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00016	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 473  : 
; 474  : 	if	(token == NULL || token->getCharPositionInLine(token) == -1)

  0001b	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  00021	74 15		 je	 SHORT $LN3@getCharPos
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0002d	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00033	83 f8 ff	 cmp	 eax, -1
  00036	75 3b		 jne	 SHORT $LN2@getCharPos
$LN3@getCharPos:

; 475  : 	{
; 476  : 		if  (tree->getChildCount(tree) > 0)

  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00042	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00048	85 c0		 test	 eax, eax
  0004a	76 23		 jbe	 SHORT $LN4@getCharPos

; 477  : 		{
; 478  : 			pANTLR3_BASE_TREE	child;
; 479  : 
; 480  : 			child   = (pANTLR3_BASE_TREE)tree->getChild(tree, 0);

  0004c	33 d2		 xor	 edx, edx
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00058	ff 50 70	 call	 QWORD PTR [rax+112]
  0005b	48 89 44 24 28	 mov	 QWORD PTR child$1[rsp], rax

; 481  : 
; 482  : 			return child->getCharPositionInLine(child);

  00060	48 8b 4c 24 28	 mov	 rcx, QWORD PTR child$1[rsp]
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR child$1[rsp]
  0006a	ff 50 68	 call	 QWORD PTR [rax+104]
  0006d	eb 14		 jmp	 SHORT $LN1@getCharPos
$LN4@getCharPos:

; 483  : 		}
; 484  : 		return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 10		 jmp	 SHORT $LN1@getCharPos
$LN2@getCharPos:

; 485  : 	}
; 486  : 	return  token->getCharPositionInLine(token);

  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0007d	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
$LN1@getCharPos:

; 487  : }

  00083	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getLine
_TEXT	SEGMENT
cTree$ = 32
token$ = 40
child$1 = 48
tree$ = 80
getLine	PROC						; COMDAT

; 446  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 447  : 	pANTLR3_COMMON_TREE	    cTree;
; 448  : 	pANTLR3_COMMON_TOKEN    token;
; 449  : 
; 450  : 	cTree   = (pANTLR3_COMMON_TREE)(tree->super);

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 89 44 24 20	 mov	 QWORD PTR cTree$[rsp], rax

; 451  : 
; 452  : 	token   = cTree->token;

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR cTree$[rsp]
  0001c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00020	48 89 44 24 28	 mov	 QWORD PTR token$[rsp], rax

; 453  : 
; 454  : 	if	(token == NULL || token->getLine(token) == 0)

  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR token$[rsp], 0
  0002b	74 14		 je	 SHORT $LN3@getLine
  0002d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR token$[rsp]
  00032	48 8b 44 24 28	 mov	 rax, QWORD PTR token$[rsp]
  00037	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  0003d	85 c0		 test	 eax, eax
  0003f	75 3e		 jne	 SHORT $LN2@getLine
$LN3@getLine:

; 455  : 	{
; 456  : 		if  (tree->getChildCount(tree) > 0)

  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0004b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00051	85 c0		 test	 eax, eax
  00053	76 26		 jbe	 SHORT $LN4@getLine

; 457  : 		{
; 458  : 			pANTLR3_BASE_TREE	child;
; 459  : 
; 460  : 			child   = (pANTLR3_BASE_TREE)tree->getChild(tree, 0);

  00055	33 d2		 xor	 edx, edx
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0005c	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00061	ff 50 70	 call	 QWORD PTR [rax+112]
  00064	48 89 44 24 30	 mov	 QWORD PTR child$1[rsp], rax

; 461  : 			return child->getLine(child);

  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR child$1[rsp]
  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR child$1[rsp]
  00073	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00079	eb 14		 jmp	 SHORT $LN1@getLine
$LN4@getLine:

; 462  : 		}
; 463  : 		return 0;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 10		 jmp	 SHORT $LN1@getLine
$LN2@getLine:

; 464  : 	}
; 465  : 	return  token->getLine(token);

  0007f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR token$[rsp]
  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR token$[rsp]
  00089	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
$LN1@getLine:

; 466  : }

  0008f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getText
_TEXT	SEGMENT
tree$ = 48
getText	PROC						; COMDAT

; 441  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 442  : 	return	tree->toString(tree);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00014	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]

; 443  : }

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5f		 pop	 rdi
  0001f	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getType
_TEXT	SEGMENT
theTree$ = 32
tree$ = 64
getType	PROC						; COMDAT

; 424  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 425  : 	pANTLR3_COMMON_TREE    theTree;
; 426  : 
; 427  : 	theTree = (pANTLR3_COMMON_TREE)(tree->super);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 89 44 24 20	 mov	 QWORD PTR theTree$[rsp], rax

; 428  : 
; 429  : 	if	(theTree->token == NULL)

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR theTree$[rsp]
  0001c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00021	75 06		 jne	 SHORT $LN2@getType

; 430  : 	{
; 431  : 		return	0;

  00023	33 c0		 xor	 eax, eax
  00025	eb 1a		 jmp	 SHORT $LN1@getType

; 432  : 	}

  00027	eb 18		 jmp	 SHORT $LN3@getType
$LN2@getType:

; 433  : 	else
; 434  : 	{
; 435  : 		return	theTree->token->getType(theTree->token);

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR theTree$[rsp]
  0002e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR theTree$[rsp]
  00037	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003b	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
$LN3@getType:
$LN1@getType:

; 436  : 	}
; 437  : }

  00041	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT isNilNode
_TEXT	SEGMENT
tree$ = 16
isNilNode PROC						; COMDAT

; 409  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 410  : 	// This is a Nil tree if it has no payload (Token in our case)
; 411  : 	//
; 412  : 	if	(((pANTLR3_COMMON_TREE)(tree->super))->token == NULL)

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00013	75 06		 jne	 SHORT $LN2@isNilNode

; 413  : 	{
; 414  : 		return ANTLR3_TRUE;

  00015	b0 01		 mov	 al, 1
  00017	eb 04		 jmp	 SHORT $LN1@isNilNode

; 415  : 	}

  00019	eb 02		 jmp	 SHORT $LN3@isNilNode
$LN2@isNilNode:

; 416  : 	else
; 417  : 	{
; 418  : 		return ANTLR3_FALSE;

  0001b	32 c0		 xor	 al, al
$LN3@isNilNode:
$LN1@isNilNode:

; 419  : 	}
; 420  : }

  0001d	5f		 pop	 rdi
  0001e	c3		 ret	 0
isNilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT dupNode
_TEXT	SEGMENT
theOld$ = 32
tree$ = 64
dupNode	PROC						; COMDAT

; 394  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 395  :     // The node we are duplicating is in fact the common tree (that's why we are here)
; 396  :     // so we use the super pointer to duplicate.
; 397  :     //
; 398  :     pANTLR3_COMMON_TREE	    theOld;
; 399  :     
; 400  : 	theOld	= (pANTLR3_COMMON_TREE)(tree->super);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 89 44 24 20	 mov	 QWORD PTR theOld$[rsp], rax

; 401  : 
; 402  : 	// The pointer we return is the base implementation of course
; 403  :     //
; 404  : 	return  theOld->factory->newFromTree(theOld->factory, theOld);

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR theOld$[rsp]
  0001c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00020	48 8b 54 24 20	 mov	 rdx, QWORD PTR theOld$[rsp]
  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR theOld$[rsp]
  0002a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0002e	ff 90 60 01 00
	00		 call	 QWORD PTR [rax+352]

; 405  : }

  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
dupNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT getToken
_TEXT	SEGMENT
tree$ = 16
getToken PROC						; COMDAT

; 382  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 383  :     // The token is the payload of the common tree or other implementor
; 384  :     // so it is stored within ourselves, which is the super pointer.Note 
; 385  : 	// that whatever the actual token is, it is passed around by its pointer
; 386  : 	// to the common token implementation, which it may of course surround
; 387  : 	// with its own super structure.
; 388  :     //
; 389  :     return  ((pANTLR3_COMMON_TREE)(tree->super))->token;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]

; 390  : }

  00012	5f		 pop	 rdi
  00013	c3		 ret	 0
getToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT antlr3SetCTAPI
_TEXT	SEGMENT
tree$ = 48
antlr3SetCTAPI PROC					; COMDAT

; 290  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 291  :     // Init base tree
; 292  :     //
; 293  :     antlr3BaseTreeNew(&(tree->baseTree));

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 antlr3BaseTreeNew

; 294  : 
; 295  :     // We need a pointer to ourselves for 
; 296  :     // the payload and few functions that we
; 297  :     // provide.
; 298  :     //
; 299  :     tree->baseTree.super    =  tree;

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00025	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 300  : 
; 301  :     // Common tree overrides
; 302  : 
; 303  :     tree->baseTree.isNilNode                = isNilNode;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:isNilNode
  00035	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 304  :     tree->baseTree.toString					= toString;

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toString
  00048	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 305  :     tree->baseTree.dupNode					= (void *(*)(pANTLR3_BASE_TREE))(dupNode);

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupNode
  0005b	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 306  :     tree->baseTree.getLine					= getLine;

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  0006e	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 307  :     tree->baseTree.getCharPositionInLine	= getCharPositionInLine;

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  00081	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 308  :     tree->baseTree.toString					= toString;

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toString
  00094	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 309  :     tree->baseTree.getType					= getType;

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  000a7	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 310  :     tree->baseTree.getText					= getText;

  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  000ba	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 311  :     tree->baseTree.getToken					= getToken;

  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getToken
  000cd	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 312  : 	tree->baseTree.getParent				= getParent;

  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getParent
  000dd	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 313  : 	tree->baseTree.setParent				= setParent;

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setParent
  000f0	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 314  : 	tree->baseTree.setChildIndex			= setChildIndex;

  000f7	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChildIndex
  00103	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 315  : 	tree->baseTree.getChildIndex			= getChildIndex;

  0010a	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildIndex
  00116	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 316  : 	tree->baseTree.createChildrenList		= createChildrenList;

  0011d	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createChildrenList
  00129	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 317  :     tree->baseTree.reuse                    = reuse;

  0012d	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reuse
  00139	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 318  : 	tree->baseTree.free						= NULL;	    // Factory trees have no free function

  00140	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00145	48 c7 80 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+304], 0

; 319  :     tree->baseTree.u                        = NULL;     // Initialize user pointer            

  00150	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00155	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 320  : 
; 321  : 	tree->baseTree.children	= NULL;

  0015d	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00162	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 322  : 
; 323  :     tree->token				= NULL;	// No token as yet

  0016a	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0016f	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 324  :     tree->startIndex		= 0;

  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0017c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 325  :     tree->stopIndex			= 0;

  00184	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00189	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 326  : 	tree->parent			= NULL;	// No parent yet

  00191	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00196	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 327  : 	tree->childIndex		= -1;

  0019e	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  001a3	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [rax+40], -1

; 328  : 
; 329  :     return;
; 330  : }

  001aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ae	5f		 pop	 rdi
  001af	c3		 ret	 0
antlr3SetCTAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT antlr3ArboretumNew
_TEXT	SEGMENT
factory$ = 32
strFactory$ = 64
antlr3ArboretumNew PROC					; COMDAT

; 66   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 67   :     pANTLR3_ARBORETUM   factory;
; 68   : 
; 69   :     // Allocate memory
; 70   :     //
; 71   :     factory	= (pANTLR3_ARBORETUM) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_ARBORETUM));

  0000a	b9 78 01 00 00	 mov	 ecx, 376		; 00000178H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 72   :     if	(factory == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@antlr3Arbo

; 73   :     {
; 74   : 		return	NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 e7 00 00 00	 jmp	 $LN1@antlr3Arbo
$LN2@antlr3Arbo:

; 75   :     }
; 76   : 
; 77   : 	// Install a vector factory to create, track and free() any child
; 78   : 	// node lists.
; 79   : 	//
; 80   : 	factory->vFactory					= antlr3VectorFactoryNew(0);

  00029	33 c9		 xor	 ecx, ecx
  0002b	e8 00 00 00 00	 call	 antlr3VectorFactoryNew
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00035	48 89 81 48 01
	00 00		 mov	 QWORD PTR [rcx+328], rax

; 81   : 	if	(factory->vFactory == NULL)

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00041	48 83 b8 48 01
	00 00 00	 cmp	 QWORD PTR [rax+328], 0
  00049	75 12		 jne	 SHORT $LN3@antlr3Arbo

; 82   : 	{
; 83   : 		free(factory);

  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 84   : 		return	NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 b3 00 00 00	 jmp	 $LN1@antlr3Arbo
$LN3@antlr3Arbo:

; 85   : 	}
; 86   : 
; 87   :     // We also keep a reclaim stack, so that any Nil nodes that are
; 88   :     // orphaned are not just left in the pool but are reused, other wise
; 89   :     // we create 6 times as many nilNodes as ordinary nodes and use loads of
; 90   :     // memory. Perhaps at some point, the analysis phase will generate better
; 91   :     // code and we won't need to do this here.
; 92   :     //
; 93   :     factory->nilStack       =  antlr3StackNew(0);

  0005d	33 c9		 xor	 ecx, ecx
  0005f	e8 00 00 00 00	 call	 antlr3StackNew
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00069	48 89 81 50 01
	00 00		 mov	 QWORD PTR [rcx+336], rax

; 94   : 
; 95   :     // Install factory API
; 96   :     //
; 97   :     factory->newTree	    =  newPoolTree;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPoolTree
  0007c	48 89 88 58 01
	00 00		 mov	 QWORD PTR [rax+344], rcx

; 98   :     factory->newFromTree    =  newFromTree;

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newFromTree
  0008f	48 89 88 60 01
	00 00		 mov	 QWORD PTR [rax+352], rcx

; 99   :     factory->newFromToken   =  newFromToken;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newFromToken
  000a2	48 89 88 68 01
	00 00		 mov	 QWORD PTR [rax+360], rcx

; 100  :     factory->close			=  factoryClose;

  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:factoryClose
  000b5	48 89 88 70 01
	00 00		 mov	 QWORD PTR [rax+368], rcx

; 101  : 
; 102  :     // Allocate the initial pool
; 103  :     //
; 104  :     factory->thisPool	= -1;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000c1	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 105  :     factory->pools		= NULL;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000cd	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 106  :     newPool(factory);

  000d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000d9	e8 00 00 00 00	 call	 newPool

; 107  : 
; 108  :     // Factory space is good, we now want to initialize our cheating token
; 109  :     // which one it is initialized is the model for all tokens we manufacture
; 110  :     //
; 111  :     antlr3SetCTAPI(&factory->unTruc);

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000e3	48 83 c0 10	 add	 rax, 16
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 antlr3SetCTAPI

; 112  : 
; 113  :     // Set some initial variables for future copying, including a string factory
; 114  :     // that we can use later for converting trees to strings.
; 115  :     //
; 116  : 	factory->unTruc.factory				= factory;

  000ef	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000f9	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 117  :     factory->unTruc.baseTree.strFactory	= strFactory;

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00107	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 118  : 
; 119  :     return  factory;

  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Arbo:

; 120  : 
; 121  : }

  00110	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
antlr3ArboretumNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT antlr3CommonTreeNewFromToken
_TEXT	SEGMENT
newTree$ = 32
token$ = 64
antlr3CommonTreeNewFromToken PROC			; COMDAT

; 354  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 355  : 	pANTLR3_COMMON_TREE	newTree;
; 356  : 
; 357  : 	newTree = antlr3CommonTreeNew();

  0000a	e8 00 00 00 00	 call	 antlr3CommonTreeNew
  0000f	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 358  : 
; 359  : 	if	(newTree == NULL)

  00014	48 83 7c 24 20
	00		 cmp	 QWORD PTR newTree$[rsp], 0
  0001a	75 04		 jne	 SHORT $LN2@antlr3Comm

; 360  : 	{
; 361  : 		return	NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 13		 jmp	 SHORT $LN1@antlr3Comm
$LN2@antlr3Comm:

; 362  : 	}
; 363  : 
; 364  : 	//Pick up the payload we had in the supplied tree
; 365  : 	//
; 366  : 	newTree->token = token;

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  0002a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 367  : 	return newTree;

  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
$LN1@antlr3Comm:

; 368  : }

  00033	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
antlr3CommonTreeNewFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontree.c
;	COMDAT antlr3CommonTreeNew
_TEXT	SEGMENT
tree$ = 32
antlr3CommonTreeNew PROC				; COMDAT

; 338  : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 339  : 	pANTLR3_COMMON_TREE	tree;
; 340  : 	tree    = ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE));

  00006	ba 38 01 00 00	 mov	 edx, 312		; 00000138H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00016	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 341  : 
; 342  : 	if	(tree == NULL)

  0001b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tree$[rsp], 0
  00021	75 04		 jne	 SHORT $LN2@antlr3Comm

; 343  : 	{
; 344  : 		return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 0f		 jmp	 SHORT $LN1@antlr3Comm
$LN2@antlr3Comm:

; 345  : 	}
; 346  : 
; 347  : 	antlr3SetCTAPI(tree);

  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  0002c	e8 00 00 00 00	 call	 antlr3SetCTAPI

; 348  : 
; 349  : 	return tree;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
$LN1@antlr3Comm:

; 350  : }

  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
antlr3CommonTreeNew ENDP
_TEXT	ENDS
END
