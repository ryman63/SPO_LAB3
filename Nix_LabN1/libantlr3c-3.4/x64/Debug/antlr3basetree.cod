; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3BaseTreeNew
PUBLIC	??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@ ; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
PUBLIC	??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@ ; `string'
PUBLIC	??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BaseTreeNew DD imagerel $LN3
	DD	imagerel $LN3+284
	DD	imagerel $unwind$antlr3BaseTreeNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChild DD imagerel getChild
	DD	imagerel getChild+94
	DD	imagerel $unwind$getChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildCount DD imagerel getChildCount
	DD	imagerel getChildCount+58
	DD	imagerel $unwind$getChildCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+10
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+10
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getFirstChildWithType DD imagerel getFirstChildWithType
	DD	imagerel getFirstChildWithType+156
	DD	imagerel $unwind$getFirstChildWithType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChild DD imagerel addChild
	DD	imagerel addChild+409
	DD	imagerel $unwind$addChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChildren DD imagerel addChildren
	DD	imagerel addChildren+109
	DD	imagerel $unwind$addChildren
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replaceChildren DD imagerel replaceChildren
	DD	imagerel replaceChildren+1106
	DD	imagerel $unwind$replaceChildren
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freshenPACIndexesAll DD imagerel freshenPACIndexesAll
	DD	imagerel freshenPACIndexesAll+34
	DD	imagerel $unwind$freshenPACIndexesAll
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freshenPACIndexes DD imagerel freshenPACIndexes
	DD	imagerel freshenPACIndexes+132
	DD	imagerel $unwind$freshenPACIndexes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChild DD imagerel setChild
	DD	imagerel setChild+91
	DD	imagerel $unwind$setChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deleteChild DD imagerel deleteChild
	DD	imagerel deleteChild+64
	DD	imagerel $unwind$deleteChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTree DD imagerel dupTree
	DD	imagerel dupTree+192
	DD	imagerel $unwind$dupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toStringTree DD imagerel toStringTree
	DD	imagerel toStringTree+414
	DD	imagerel $unwind$toStringTree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@
CONST	SEGMENT
??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@ DB 'replaceChi'
	DB	'ldren: out of memory!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@
CONST	SEGMENT
??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@ DB 'replaceChildr'
	DB	'en call: Indexes are invalid; no children in list for %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@
CONST	SEGMENT
??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@ DB 'ANTLR3: An'
	DB	' attempt was made to add a child list to itself!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toStringTree DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTree DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deleteChild DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChild DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freshenPACIndexes DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freshenPACIndexesAll DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replaceChildren DD 031b01H
	DD	012011bH
	DD	07014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChildren DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChild DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getFirstChildWithType DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildCount DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChild DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BaseTreeNew DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT toStringTree
_TEXT	SEGMENT
string$ = 32
i$ = 40
n$ = 44
t$ = 48
tree$ = 80
toStringTree PROC					; COMDAT

; 289  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 290  : 	pANTLR3_STRING  string;
; 291  : 	ANTLR3_UINT32   i;
; 292  : 	ANTLR3_UINT32   n;
; 293  : 	pANTLR3_BASE_TREE   t;
; 294  : 
; 295  : 	if	(tree->children == NULL || tree->children->size(tree->children) == 0)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00014	74 1c		 je	 SHORT $LN6@toStringTr
  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0001b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00024	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00028	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  0002e	85 c0		 test	 eax, eax
  00030	75 15		 jne	 SHORT $LN5@toStringTr
$LN6@toStringTr:

; 296  : 	{
; 297  : 		return	tree->toString(tree);

  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0003c	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]
  00042	e9 51 01 00 00	 jmp	 $LN1@toStringTr
$LN5@toStringTr:

; 298  : 	}
; 299  : 
; 300  : 	/* Need a new string with nothing at all in it.
; 301  : 	*/
; 302  : 	string	= tree->strFactory->newRaw(tree->strFactory);

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0004c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00050	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00055	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00059	ff 50 10	 call	 QWORD PTR [rax+16]
  0005c	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 303  : 
; 304  : 	if	(tree->isNilNode(tree) == ANTLR3_FALSE)

  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0006b	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	75 48		 jne	 SHORT $LN7@toStringTr

; 305  : 	{
; 306  : 		string->append8	(string, "(");

  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01ODHLEDKK@?$CI@
  0007f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00089	ff 50 38	 call	 QWORD PTR [rax+56]

; 307  : 		string->appendS	(string, tree->toString(tree));

  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00096	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]
  0009c	48 8b d0	 mov	 rdx, rax
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  000a9	ff 50 58	 call	 QWORD PTR [rax+88]

; 308  : 		string->append8	(string, " ");

  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
  000b3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  000bd	ff 50 38	 call	 QWORD PTR [rax+56]
$LN7@toStringTr:

; 309  : 	}
; 310  : 	if	(tree->children != NULL)

  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  000c5	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000ca	0f 84 98 00 00
	00		 je	 $LN8@toStringTr

; 311  : 	{
; 312  : 		n = tree->children->size(tree->children);

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  000d5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  000de	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000e2	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  000e8	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax

; 313  : 
; 314  : 		for	(i = 0; i < n; i++)

  000ec	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000f4	eb 0a		 jmp	 SHORT $LN4@toStringTr
$LN2@toStringTr:
  000f6	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000fa	ff c0		 inc	 eax
  000fc	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@toStringTr:
  00100	8b 44 24 2c	 mov	 eax, DWORD PTR n$[rsp]
  00104	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00108	73 5e		 jae	 SHORT $LN3@toStringTr

; 315  : 		{   
; 316  : 			t   = (pANTLR3_BASE_TREE) tree->children->get(tree->children, i);

  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0010f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00113	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00117	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0011c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00120	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00126	48 89 44 24 30	 mov	 QWORD PTR t$[rsp], rax

; 317  : 
; 318  : 			if  (i > 0)

  0012b	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  00130	76 14		 jbe	 SHORT $LN9@toStringTr

; 319  : 			{
; 320  : 				string->append8(string, " ");

  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
  00139	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00143	ff 50 38	 call	 QWORD PTR [rax+56]
$LN9@toStringTr:

; 321  : 			}
; 322  : 			string->appendS(string, t->toStringTree(t));

  00146	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t$[rsp]
  0014b	48 8b 44 24 30	 mov	 rax, QWORD PTR t$[rsp]
  00150	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00156	48 8b d0	 mov	 rdx, rax
  00159	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0015e	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00163	ff 50 58	 call	 QWORD PTR [rax+88]

; 323  : 		}

  00166	eb 8e		 jmp	 SHORT $LN2@toStringTr
$LN3@toStringTr:
$LN8@toStringTr:

; 324  : 	}
; 325  : 	if	(tree->isNilNode(tree) == ANTLR3_FALSE)

  00168	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0016d	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00172	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00178	0f b6 c0	 movzx	 eax, al
  0017b	85 c0		 test	 eax, eax
  0017d	75 14		 jne	 SHORT $LN10@toStringTr

; 326  : 	{
; 327  : 		string->append8(string,")");

  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
  00186	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0018b	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00190	ff 50 38	 call	 QWORD PTR [rax+56]
$LN10@toStringTr:

; 328  : 	}
; 329  : 
; 330  : 	return  string;

  00193	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@toStringTr:

; 331  : }

  00198	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0019c	5f		 pop	 rdi
  0019d	c3		 ret	 0
toStringTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT dupTree
_TEXT	SEGMENT
newTree$ = 32
i$ = 40
s$ = 44
t$1 = 48
newNode$2 = 56
tree$ = 80
dupTree	PROC						; COMDAT

; 258  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 259  : 	pANTLR3_BASE_TREE	newTree;
; 260  : 	ANTLR3_UINT32	i;
; 261  : 	ANTLR3_UINT32	s;
; 262  : 
; 263  : 	newTree = tree->dupNode	    (tree);

  0000a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00014	ff 50 58	 call	 QWORD PTR [rax+88]
  00017	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 264  : 
; 265  : 	if	(tree->children != NULL)

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00021	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00026	0f 84 89 00 00
	00		 je	 $LN5@dupTree

; 266  : 	{
; 267  : 		s	    = tree->children->size  (tree->children);

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  00031	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00035	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  0003a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003e	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00044	89 44 24 2c	 mov	 DWORD PTR s$[rsp], eax

; 268  : 
; 269  : 		for	(i = 0; i < s; i++)

  00048	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00050	eb 0a		 jmp	 SHORT $LN4@dupTree
$LN2@dupTree:
  00052	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00056	ff c0		 inc	 eax
  00058	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@dupTree:
  0005c	8b 44 24 2c	 mov	 eax, DWORD PTR s$[rsp]
  00060	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00064	73 4f		 jae	 SHORT $LN3@dupTree

; 270  : 		{
; 271  : 			pANTLR3_BASE_TREE    t;
; 272  : 			pANTLR3_BASE_TREE    newNode;
; 273  : 
; 274  : 			t   = (pANTLR3_BASE_TREE) tree->children->get(tree->children, i);

  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR tree$[rsp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tree$[rsp]
  00078	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007c	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00082	48 89 44 24 30	 mov	 QWORD PTR t$1[rsp], rax

; 275  : 
; 276  : 			if  (t!= NULL)

  00087	48 83 7c 24 30
	00		 cmp	 QWORD PTR t$1[rsp], 0
  0008d	74 24		 je	 SHORT $LN6@dupTree

; 277  : 			{
; 278  : 				newNode	    = t->dupTree(t);

  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR t$1[rsp]
  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR t$1[rsp]
  00099	ff 50 60	 call	 QWORD PTR [rax+96]
  0009c	48 89 44 24 38	 mov	 QWORD PTR newNode$2[rsp], rax

; 279  : 				newTree->addChild(newTree, newNode);

  000a1	48 8b 54 24 38	 mov	 rdx, QWORD PTR newNode$2[rsp]
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newTree$[rsp]
  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
  000b0	ff 50 30	 call	 QWORD PTR [rax+48]
$LN6@dupTree:

; 280  : 			}
; 281  : 		}

  000b3	eb 9d		 jmp	 SHORT $LN2@dupTree
$LN3@dupTree:
$LN5@dupTree:

; 282  : 	}
; 283  : 
; 284  : 	return newTree;

  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]

; 285  : }

  000ba	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
dupTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT deleteChild
_TEXT	SEGMENT
tree$ = 48
i$ = 56
deleteChild PROC					; COMDAT

; 247  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 248  : 	if	( tree->children == NULL)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00013	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00018	75 04		 jne	 SHORT $LN2@deleteChil

; 249  : 	{
; 250  : 		return	NULL;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 1c		 jmp	 SHORT $LN1@deleteChil
$LN2@deleteChil:

; 251  : 	}
; 252  : 
; 253  : 	return  tree->children->remove(tree->children, i);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00023	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00027	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00030	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00034	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
$LN1@deleteChil:

; 254  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
deleteChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT setChild
_TEXT	SEGMENT
tree$ = 64
i$ = 72
child$ = 80
setChild PROC						; COMDAT

; 237  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 238  : 	if	(tree->children == NULL)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00018	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0001d	75 0d		 jne	 SHORT $LN2@setChild

; 239  : 	{
; 240  : 		tree->createChildrenList(tree);

  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00029	ff 50 40	 call	 QWORD PTR [rax+64]
$LN2@setChild:

; 241  : 	}
; 242  : 	tree->children->set(tree->children, i, child, NULL, ANTLR3_FALSE);

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00031	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00035	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	4c 8b 44 24 50	 mov	 r8, QWORD PTR child$[rsp]
  00042	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0004b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004f	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 243  : }

  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
setChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT freshenPACIndexes
_TEXT	SEGMENT
count$ = 32
c$ = 36
child$1 = 40
tree$ = 64
offset$ = 72
freshenPACIndexes PROC					; COMDAT

; 471  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 472  : 	ANTLR3_UINT32	count;
; 473  : 	ANTLR3_UINT32	c;
; 474  : 
; 475  : 	count	= tree->getChildCount(tree);		// How many children do we have 

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00018	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0001e	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax

; 476  : 
; 477  : 	// Loop from the supplied index and set the indexes and parent
; 478  : 	//
; 479  : 	for	(c = offset; c < count; c++)

  00022	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00026	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
  0002a	eb 0a		 jmp	 SHORT $LN4@freshenPAC
$LN2@freshenPAC:
  0002c	8b 44 24 24	 mov	 eax, DWORD PTR c$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax
$LN4@freshenPAC:
  00036	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  0003a	39 44 24 24	 cmp	 DWORD PTR c$[rsp], eax
  0003e	73 3e		 jae	 SHORT $LN3@freshenPAC

; 480  : 	{
; 481  : 		pANTLR3_BASE_TREE	child;
; 482  : 
; 483  : 		child = tree->getChild(tree, c);

  00040	8b 54 24 24	 mov	 edx, DWORD PTR c$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0004e	ff 50 70	 call	 QWORD PTR [rax+112]
  00051	48 89 44 24 28	 mov	 QWORD PTR child$1[rsp], rax

; 484  : 
; 485  : 		child->setChildIndex(child, c);

  00056	8b 54 24 24	 mov	 edx, DWORD PTR c$[rsp]
  0005a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR child$1[rsp]
  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR child$1[rsp]
  00064	ff 50 78	 call	 QWORD PTR [rax+120]

; 486  : 		child->setParent(child, tree);

  00067	48 8b 54 24 40	 mov	 rdx, QWORD PTR tree$[rsp]
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR child$1[rsp]
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR child$1[rsp]
  00076	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 487  : 	}

  0007c	eb ae		 jmp	 SHORT $LN2@freshenPAC
$LN3@freshenPAC:

; 488  : }

  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
freshenPACIndexes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT freshenPACIndexesAll
_TEXT	SEGMENT
tree$ = 48
freshenPACIndexesAll PROC				; COMDAT

; 462  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 463  : 	tree->freshenPACIndexes(tree, 0);

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00016	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 464  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
freshenPACIndexesAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT replaceChildren
_TEXT	SEGMENT
replacingHowMany$ = 48
replacingWithHowMany$ = 52
numNewChildren$ = 56
delta$ = 60
i$ = 64
j$ = 68
newChildren$ = 72
freeNewChildren$ = 80
child$1 = 88
indexToDelete$2 = 96
numToInsert$3 = 100
tv68 = 104
tv223 = 112
tv221 = 120
tv220 = 128
parent$ = 160
startChildIndex$ = 168
stopChildIndex$ = 176
newTree$ = 184
replaceChildren PROC					; COMDAT

; 340  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 341  : 	ANTLR3_INT32	replacingHowMany;		// How many nodes will go away
; 342  : 	ANTLR3_INT32	replacingWithHowMany;	// How many nodes will replace them
; 343  : 	ANTLR3_INT32	numNewChildren;			// Tracking variable
; 344  : 	ANTLR3_INT32	delta;					// Difference in new vs existing count
; 345  : 
; 346  : 	ANTLR3_INT32	i;
; 347  : 	ANTLR3_INT32	j;
; 348  : 
; 349  : 	pANTLR3_VECTOR	newChildren;			// Iterator for whatever we are going to add in
; 350  : 	ANTLR3_BOOLEAN	freeNewChildren;		// Whether we created the iterator locally or reused it
; 351  : 
; 352  : 	if	(parent->children == NULL)

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00023	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00028	75 43		 jne	 SHORT $LN17@replaceChi

; 353  : 	{
; 354  : 		ANTLR3_FPRINTF(stderr, "replaceChildren call: Indexes are invalid; no children in list for %s", parent->getText(parent)->chars);

  0002a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  00032	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  0003a	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00040	48 89 44 24 68	 mov	 QWORD PTR tv68[rsp], rax
  00045	b9 02 00 00 00	 mov	 ecx, 2
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00050	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv68[rsp]
  00055	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 fprintf

; 355  : 		return;

  00068	e9 dc 03 00 00	 jmp	 $LN1@replaceChi
$LN17@replaceChi:

; 356  : 	}
; 357  : 
; 358  : 	// Either use the existing list of children in the supplied nil node, or build a vector of the
; 359  : 	// tree we were given if it is not a nil node, then we treat both situations exactly the same
; 360  : 	//
; 361  : 	if	(newTree->isNilNode(newTree))

  0006d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR newTree$[rsp]
  00075	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR newTree$[rsp]
  0007d	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00083	0f b6 c0	 movzx	 eax, al
  00086	85 c0		 test	 eax, eax
  00088	74 18		 je	 SHORT $LN18@replaceChi

; 362  : 	{
; 363  : 		newChildren = newTree->children;

  0008a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR newTree$[rsp]
  00092	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00096	48 89 44 24 48	 mov	 QWORD PTR newChildren$[rsp], rax

; 364  : 		freeNewChildren = ANTLR3_FALSE;		// We must NO free this memory

  0009b	c6 44 24 50 00	 mov	 BYTE PTR freeNewChildren$[rsp], 0

; 365  : 	}

  000a0	eb 5c		 jmp	 SHORT $LN19@replaceChi
$LN18@replaceChi:

; 366  : 	else
; 367  : 	{
; 368  : 		newChildren = antlr3VectorNew(1);

  000a2	b9 01 00 00 00	 mov	 ecx, 1
  000a7	e8 00 00 00 00	 call	 antlr3VectorNew
  000ac	48 89 44 24 48	 mov	 QWORD PTR newChildren$[rsp], rax

; 369  : 		if	(newChildren == NULL)

  000b1	48 83 7c 24 48
	00		 cmp	 QWORD PTR newChildren$[rsp], 0
  000b7	75 25		 jne	 SHORT $LN20@replaceChi

; 370  : 		{
; 371  : 			ANTLR3_FPRINTF(stderr, "replaceChildren: out of memory!!");

  000b9	b9 02 00 00 00	 mov	 ecx, 2
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 fprintf

; 372  : 			exit(1);

  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN20@replaceChi:

; 373  : 		}
; 374  : 		newChildren->add(newChildren, (void *)newTree, NULL);

  000de	45 33 c0	 xor	 r8d, r8d
  000e1	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR newTree$[rsp]
  000e9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  000ee	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  000f3	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 375  : 
; 376  : 		freeNewChildren = ANTLR3_TRUE;		// We must free this memory

  000f9	c6 44 24 50 01	 mov	 BYTE PTR freeNewChildren$[rsp], 1
$LN19@replaceChi:

; 377  : 	}
; 378  : 
; 379  : 	// Initialize
; 380  : 	//
; 381  : 	replacingHowMany		= stopChildIndex - startChildIndex + 1;

  000fe	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR startChildIndex$[rsp]
  00105	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR stopChildIndex$[rsp]
  0010c	2b c8		 sub	 ecx, eax
  0010e	8b c1		 mov	 eax, ecx
  00110	ff c0		 inc	 eax
  00112	89 44 24 30	 mov	 DWORD PTR replacingHowMany$[rsp], eax

; 382  : 	replacingWithHowMany	= newChildren->size(newChildren);

  00116	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  0011b	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00120	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00126	89 44 24 34	 mov	 DWORD PTR replacingWithHowMany$[rsp], eax

; 383  : 	delta					= replacingHowMany - replacingWithHowMany;

  0012a	8b 44 24 34	 mov	 eax, DWORD PTR replacingWithHowMany$[rsp]
  0012e	8b 4c 24 30	 mov	 ecx, DWORD PTR replacingHowMany$[rsp]
  00132	2b c8		 sub	 ecx, eax
  00134	8b c1		 mov	 eax, ecx
  00136	89 44 24 3c	 mov	 DWORD PTR delta$[rsp], eax

; 384  : 	numNewChildren			= newChildren->size(newChildren);

  0013a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  0013f	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00144	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  0014a	89 44 24 38	 mov	 DWORD PTR numNewChildren$[rsp], eax

; 385  : 
; 386  : 	// If it is the same number of nodes, then do a direct replacement
; 387  : 	//
; 388  : 	if	(delta == 0)

  0014e	83 7c 24 3c 00	 cmp	 DWORD PTR delta$[rsp], 0
  00153	0f 85 a7 00 00
	00		 jne	 $LN21@replaceChi

; 389  : 	{
; 390  : 		pANTLR3_BASE_TREE	child;
; 391  : 
; 392  : 		// Same number of nodes
; 393  : 		//
; 394  : 		j	= 0;

  00159	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 395  : 		for	(i = startChildIndex; i <= stopChildIndex; i++)

  00161	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR startChildIndex$[rsp]
  00168	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  0016c	eb 0a		 jmp	 SHORT $LN4@replaceChi
$LN2@replaceChi:
  0016e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00172	ff c0		 inc	 eax
  00174	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@replaceChi:
  00178	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR stopChildIndex$[rsp]
  0017f	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00183	7f 76		 jg	 SHORT $LN3@replaceChi

; 396  : 		{
; 397  : 			child = (pANTLR3_BASE_TREE) newChildren->get(newChildren, j);

  00185	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  00189	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  0018e	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00193	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00199	48 89 44 24 58	 mov	 QWORD PTR child$1[rsp], rax

; 398  : 			parent->children->set(parent->children, i, child, NULL, ANTLR3_FALSE);

  0019e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  001a6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001aa	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001af	45 33 c9	 xor	 r9d, r9d
  001b2	4c 8b 44 24 58	 mov	 r8, QWORD PTR child$1[rsp]
  001b7	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  001bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  001c3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001c7	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 399  : 			child->setParent(child, parent);

  001cd	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR parent$[rsp]
  001d5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR child$1[rsp]
  001da	48 8b 44 24 58	 mov	 rax, QWORD PTR child$1[rsp]
  001df	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 400  : 			child->setChildIndex(child, i);

  001e5	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  001e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR child$1[rsp]
  001ee	48 8b 44 24 58	 mov	 rax, QWORD PTR child$1[rsp]
  001f3	ff 50 78	 call	 QWORD PTR [rax+120]

; 401  : 		}

  001f6	e9 73 ff ff ff	 jmp	 $LN2@replaceChi
$LN3@replaceChi:

; 402  : 	}

  001fb	e9 0a 02 00 00	 jmp	 $LN22@replaceChi
$LN21@replaceChi:

; 403  : 	else if (delta > 0)

  00200	83 7c 24 3c 00	 cmp	 DWORD PTR delta$[rsp], 0
  00205	0f 8e f2 00 00
	00		 jle	 $LN23@replaceChi

; 404  : 	{
; 405  : 		ANTLR3_UINT32	indexToDelete;
; 406  : 
; 407  : 		// Less nodes than there were before
; 408  : 		// reuse what we have then delete the rest
; 409  : 		//
; 410  : 		for	(j = 0; j < numNewChildren; j++)

  0020b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00213	eb 0a		 jmp	 SHORT $LN7@replaceChi
$LN5@replaceChi:
  00215	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  00219	ff c0		 inc	 eax
  0021b	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN7@replaceChi:
  0021f	8b 44 24 38	 mov	 eax, DWORD PTR numNewChildren$[rsp]
  00223	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  00227	7d 5a		 jge	 SHORT $LN6@replaceChi

; 411  : 		{
; 412  : 			parent->children->set(parent->children, startChildIndex + j, newChildren->get(newChildren, j), NULL, ANTLR3_FALSE);

  00229	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  0022d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00232	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00237	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0023d	8b 4c 24 44	 mov	 ecx, DWORD PTR j$[rsp]
  00241	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  00248	03 d1		 add	 edx, ecx
  0024a	8b ca		 mov	 ecx, edx
  0024c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR parent$[rsp]
  00254	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00258	48 89 54 24 70	 mov	 QWORD PTR tv223[rsp], rdx
  0025d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00262	45 33 c9	 xor	 r9d, r9d
  00265	4c 8b c0	 mov	 r8, rax
  00268	8b d1		 mov	 edx, ecx
  0026a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00272	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00276	48 8b 44 24 70	 mov	 rax, QWORD PTR tv223[rsp]
  0027b	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 413  : 		}

  00281	eb 92		 jmp	 SHORT $LN5@replaceChi
$LN6@replaceChi:

; 414  : 
; 415  : 		// We just delete the same index position until done
; 416  : 		//
; 417  : 		indexToDelete = startChildIndex + numNewChildren;

  00283	8b 44 24 38	 mov	 eax, DWORD PTR numNewChildren$[rsp]
  00287	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR startChildIndex$[rsp]
  0028e	03 c8		 add	 ecx, eax
  00290	8b c1		 mov	 eax, ecx
  00292	89 44 24 60	 mov	 DWORD PTR indexToDelete$2[rsp], eax

; 418  : 
; 419  : 		for	(j = indexToDelete; j <= (ANTLR3_INT32)stopChildIndex; j++)

  00296	8b 44 24 60	 mov	 eax, DWORD PTR indexToDelete$2[rsp]
  0029a	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
  0029e	eb 0a		 jmp	 SHORT $LN10@replaceChi
$LN8@replaceChi:
  002a0	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  002a4	ff c0		 inc	 eax
  002a6	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN10@replaceChi:
  002aa	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR stopChildIndex$[rsp]
  002b1	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  002b5	7f 24		 jg	 SHORT $LN9@replaceChi

; 420  : 		{
; 421  : 			parent->children->remove(parent->children, indexToDelete);

  002b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  002bf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002c3	8b 54 24 60	 mov	 edx, DWORD PTR indexToDelete$2[rsp]
  002c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  002cf	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002d3	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]

; 422  : 		}

  002d9	eb c5		 jmp	 SHORT $LN8@replaceChi
$LN9@replaceChi:

; 423  : 
; 424  : 		parent->freshenPACIndexes(parent, startChildIndex);

  002db	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  002e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  002ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  002f2	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 425  : 	}

  002f8	e9 0d 01 00 00	 jmp	 $LN24@replaceChi
$LN23@replaceChi:

; 426  : 	else
; 427  : 	{
; 428  : 		ANTLR3_UINT32 numToInsert;
; 429  : 
; 430  : 		// More nodes than there were before
; 431  : 		// Use what we can, then start adding
; 432  : 		//
; 433  : 		for	(j = 0; j < replacingHowMany; j++)

  002fd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00305	eb 0a		 jmp	 SHORT $LN13@replaceChi
$LN11@replaceChi:
  00307	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  0030b	ff c0		 inc	 eax
  0030d	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN13@replaceChi:
  00311	8b 44 24 30	 mov	 eax, DWORD PTR replacingHowMany$[rsp]
  00315	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  00319	7d 5a		 jge	 SHORT $LN12@replaceChi

; 434  : 		{
; 435  : 			parent->children->set(parent->children, startChildIndex + j, newChildren->get(newChildren, j), NULL, ANTLR3_FALSE);

  0031b	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  0031f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00324	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00329	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0032f	8b 4c 24 44	 mov	 ecx, DWORD PTR j$[rsp]
  00333	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  0033a	03 d1		 add	 edx, ecx
  0033c	8b ca		 mov	 ecx, edx
  0033e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR parent$[rsp]
  00346	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0034a	48 89 54 24 78	 mov	 QWORD PTR tv221[rsp], rdx
  0034f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00354	45 33 c9	 xor	 r9d, r9d
  00357	4c 8b c0	 mov	 r8, rax
  0035a	8b d1		 mov	 edx, ecx
  0035c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00364	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00368	48 8b 44 24 78	 mov	 rax, QWORD PTR tv221[rsp]
  0036d	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 436  : 		}

  00373	eb 92		 jmp	 SHORT $LN11@replaceChi
$LN12@replaceChi:

; 437  : 
; 438  : 		numToInsert = replacingWithHowMany - replacingHowMany;

  00375	8b 44 24 30	 mov	 eax, DWORD PTR replacingHowMany$[rsp]
  00379	8b 4c 24 34	 mov	 ecx, DWORD PTR replacingWithHowMany$[rsp]
  0037d	2b c8		 sub	 ecx, eax
  0037f	8b c1		 mov	 eax, ecx
  00381	89 44 24 64	 mov	 DWORD PTR numToInsert$3[rsp], eax

; 439  : 
; 440  : 		for	(j = replacingHowMany; j < replacingWithHowMany; j++)

  00385	8b 44 24 30	 mov	 eax, DWORD PTR replacingHowMany$[rsp]
  00389	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
  0038d	eb 0a		 jmp	 SHORT $LN16@replaceChi
$LN14@replaceChi:
  0038f	8b 44 24 44	 mov	 eax, DWORD PTR j$[rsp]
  00393	ff c0		 inc	 eax
  00395	89 44 24 44	 mov	 DWORD PTR j$[rsp], eax
$LN16@replaceChi:
  00399	8b 44 24 34	 mov	 eax, DWORD PTR replacingWithHowMany$[rsp]
  0039d	39 44 24 44	 cmp	 DWORD PTR j$[rsp], eax
  003a1	7d 4a		 jge	 SHORT $LN15@replaceChi

; 441  : 		{
; 442  : 			parent->children->add(parent->children, newChildren->get(newChildren, j), NULL);

  003a3	8b 54 24 44	 mov	 edx, DWORD PTR j$[rsp]
  003a7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  003ac	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  003b1	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  003b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  003bf	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003c3	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv220[rsp], rcx
  003cb	45 33 c0	 xor	 r8d, r8d
  003ce	48 8b d0	 mov	 rdx, rax
  003d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  003d9	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  003dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv220[rsp]
  003e5	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 443  : 		}

  003eb	eb a2		 jmp	 SHORT $LN14@replaceChi
$LN15@replaceChi:

; 444  : 
; 445  : 		parent->freshenPACIndexes(parent, startChildIndex);

  003ed	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR startChildIndex$[rsp]
  003f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR parent$[rsp]
  003fc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR parent$[rsp]
  00404	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]
$LN24@replaceChi:
$LN22@replaceChi:

; 446  : 	}
; 447  : 
; 448  : 	if	(freeNewChildren == ANTLR3_TRUE)

  0040a	0f b6 44 24 50	 movzx	 eax, BYTE PTR freeNewChildren$[rsp]
  0040f	83 f8 01	 cmp	 eax, 1
  00412	75 35		 jne	 SHORT $LN25@replaceChi

; 449  : 	{
; 450  : 		ANTLR3_FREE(newChildren->elements);

  00414	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00419	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0041c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 451  : 		newChildren->elements = NULL;

  00422	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00427	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 452  : 		newChildren->size = 0;

  0042e	48 8b 44 24 48	 mov	 rax, QWORD PTR newChildren$[rsp]
  00433	48 c7 80 58 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+344], 0

; 453  : 		ANTLR3_FREE(newChildren);		// Will not free the nodes

  0043e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newChildren$[rsp]
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@replaceChi:
$LN1@replaceChi:
$LN26@replaceChi:

; 454  : 	}
; 455  : }

  00449	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00450	5f		 pop	 rdi
  00451	c3		 ret	 0
replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT addChildren
_TEXT	SEGMENT
i$ = 32
s$ = 36
tree$ = 64
kids$ = 72
addChildren PROC					; COMDAT

; 223  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 224  : 	ANTLR3_UINT32    i;
; 225  : 	ANTLR3_UINT32    s;
; 226  : 
; 227  : 	s = kids->size(kids);

  0000f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR kids$[rsp]
  00014	48 8b 44 24 48	 mov	 rax, QWORD PTR kids$[rsp]
  00019	ff 50 38	 call	 QWORD PTR [rax+56]
  0001c	89 44 24 24	 mov	 DWORD PTR s$[rsp], eax

; 228  : 	for	(i = 0; i<s; i++)

  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00028	eb 0a		 jmp	 SHORT $LN4@addChildre
$LN2@addChildre:
  0002a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002e	ff c0		 inc	 eax
  00030	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@addChildre:
  00034	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  00038	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0003c	73 29		 jae	 SHORT $LN3@addChildre

; 229  : 	{
; 230  : 		tree->addChild(tree, (pANTLR3_BASE_TREE)(kids->get(kids, i+1)));

  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00042	ff c0		 inc	 eax
  00044	8b c0		 mov	 eax, eax
  00046	8b d0		 mov	 edx, eax
  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR kids$[rsp]
  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR kids$[rsp]
  00052	ff 50 18	 call	 QWORD PTR [rax+24]
  00055	48 8b d0	 mov	 rdx, rax
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00062	ff 50 30	 call	 QWORD PTR [rax+48]

; 231  : 	}

  00065	eb c3		 jmp	 SHORT $LN2@addChildre
$LN3@addChildre:

; 232  : }

  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
addChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT addChild
_TEXT	SEGMENT
n$ = 32
i$ = 36
entry$1 = 40
tree$ = 64
child$ = 72
addChild PROC						; COMDAT

; 145  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 146  : 	ANTLR3_UINT32   n;
; 147  : 	ANTLR3_UINT32   i;
; 148  : 
; 149  : 	if	(child == NULL)

  0000f	48 83 7c 24 48
	00		 cmp	 QWORD PTR child$[rsp], 0
  00015	75 05		 jne	 SHORT $LN5@addChild

; 150  : 	{
; 151  : 		return;

  00017	e9 77 01 00 00	 jmp	 $LN1@addChild
$LN5@addChild:

; 152  : 	}
; 153  : 
; 154  : 	if	(child->isNilNode(child) == ANTLR3_TRUE)

  0001c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  00026	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	83 f8 01	 cmp	 eax, 1
  00032	0f 85 19 01 00
	00		 jne	 $LN6@addChild

; 155  : 	{
; 156  : 		if  (child->children != NULL && child->children == tree->children)

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  0003d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00042	74 33		 je	 SHORT $LN8@addChild
  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  0004e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00052	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00056	75 1f		 jne	 SHORT $LN8@addChild

; 157  : 		{
; 158  : 			// TODO: Change to exception rather than ANTLR3_FPRINTF?
; 159  : 			//
; 160  : 			ANTLR3_FPRINTF(stderr, "ANTLR3: An attempt was made to add a child list to itself!\n");

  00058	b9 02 00 00 00	 mov	 ecx, 2
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 fprintf

; 161  : 			return;

  00072	e9 1c 01 00 00	 jmp	 $LN1@addChild
$LN8@addChild:

; 162  : 		}
; 163  : 
; 164  :         // Add all of the children's children to this list
; 165  :         //
; 166  :         if (child->children != NULL)

  00077	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  0007c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00081	0f 84 c8 00 00
	00		 je	 $LN9@addChild

; 167  :         {
; 168  :             if (tree->children == NULL)

  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0008c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00091	75 2e		 jne	 SHORT $LN10@addChild

; 169  :             {
; 170  :                 // We are build ing the tree structure here, so we need not
; 171  :                 // worry about duplication of pointers as the tree node
; 172  :                 // factory will only clean up each node once. So we just
; 173  :                 // copy in the child's children pointer as the child is
; 174  :                 // a nil node (has not root itself).
; 175  :                 //
; 176  :                 tree->children = child->children;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00098	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  0009d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000a1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 177  :                 child->children = NULL;

  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  000aa	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 178  :                 freshenPACIndexesAll(tree);

  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  000b7	e8 00 00 00 00	 call	 freshenPACIndexesAll

; 179  :                 
; 180  :             }

  000bc	e9 8e 00 00 00	 jmp	 $LN11@addChild
$LN10@addChild:

; 181  :             else
; 182  :             {
; 183  :                 // Need to copy the children
; 184  :                 //
; 185  :                 n = child->children->size(child->children);

  000c1	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  000c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  000cf	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000d3	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  000d9	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 186  : 
; 187  :                 for (i = 0; i < n; i++)

  000dd	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e5	eb 0a		 jmp	 SHORT $LN4@addChild
$LN2@addChild:
  000e7	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000eb	ff c0		 inc	 eax
  000ed	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@addChild:
  000f1	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000f5	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000f9	73 54		 jae	 SHORT $LN3@addChild

; 188  :                 {
; 189  :                     pANTLR3_BASE_TREE entry;
; 190  :                     entry = child->children->get(child->children, i);

  000fb	48 8b 44 24 48	 mov	 rax, QWORD PTR child$[rsp]
  00100	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00104	8b 54 24 24	 mov	 edx, DWORD PTR i$[rsp]
  00108	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  0010d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00111	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00117	48 89 44 24 28	 mov	 QWORD PTR entry$1[rsp], rax

; 191  : 
; 192  :                     // ANTLR3 lists can be sparse, unlike Array Lists
; 193  :                     //
; 194  :                     if (entry != NULL)

  0011c	48 83 7c 24 28
	00		 cmp	 QWORD PTR entry$1[rsp], 0
  00122	74 29		 je	 SHORT $LN12@addChild

; 195  :                     {
; 196  :                         tree->children->add(tree->children, entry, (void (ANTLR3_CDECL *) (void *))child->free);

  00124	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00129	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0012d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  00132	4c 8b 81 f8 00
	00 00		 mov	 r8, QWORD PTR [rcx+248]
  00139	48 8b 54 24 28	 mov	 rdx, QWORD PTR entry$1[rsp]
  0013e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00143	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00147	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]
$LN12@addChild:

; 197  :                     }
; 198  :                 }

  0014d	eb 98		 jmp	 SHORT $LN2@addChild
$LN3@addChild:
$LN11@addChild:
$LN9@addChild:

; 199  :             }
; 200  : 		}
; 201  : 	}

  0014f	eb 42		 jmp	 SHORT $LN7@addChild
$LN6@addChild:

; 202  : 	else
; 203  : 	{
; 204  : 		// Tree we are adding is not a Nil and might have children to copy
; 205  : 		//
; 206  : 		if  (tree->children == NULL)

  00151	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00156	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0015b	75 0d		 jne	 SHORT $LN13@addChild

; 207  : 		{
; 208  : 			// No children in the tree we are adding to, so create a new list on
; 209  : 			// the fly to hold them.
; 210  : 			//
; 211  : 			tree->createChildrenList(tree);

  0015d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00162	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00167	ff 50 40	 call	 QWORD PTR [rax+64]
$LN13@addChild:

; 212  : 		}
; 213  : 
; 214  : 		tree->children->add(tree->children, child, (void (ANTLR3_CDECL *)(void *))child->free);

  0016a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0016f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00173	48 8b 4c 24 48	 mov	 rcx, QWORD PTR child$[rsp]
  00178	4c 8b 81 f8 00
	00 00		 mov	 r8, QWORD PTR [rcx+248]
  0017f	48 8b 54 24 48	 mov	 rdx, QWORD PTR child$[rsp]
  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00189	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0018d	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]
$LN7@addChild:
$LN1@addChild:

; 215  : 		
; 216  : 	}
; 217  : }

  00193	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00197	5f		 pop	 rdi
  00198	c3		 ret	 0
addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getFirstChildWithType
_TEXT	SEGMENT
i$ = 32
cs$ = 36
t$ = 40
tree$ = 64
type$ = 72
getFirstChildWithType PROC				; COMDAT

; 96   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 97   : 	ANTLR3_UINT32   i;
; 98   : 	ANTLR3_UINT32   cs;
; 99   : 
; 100  : 	pANTLR3_BASE_TREE	t;
; 101  : 	if	(tree->children != NULL)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00013	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00018	74 7a		 je	 SHORT $LN5@getFirstCh

; 102  : 	{
; 103  : 		cs	= tree->children->size(tree->children);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00028	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002c	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00032	89 44 24 24	 mov	 DWORD PTR cs$[rsp], eax

; 104  : 		for	(i = 0; i < cs; i++)

  00036	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003e	eb 0a		 jmp	 SHORT $LN4@getFirstCh
$LN2@getFirstCh:
  00040	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00044	ff c0		 inc	 eax
  00046	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@getFirstCh:
  0004a	8b 44 24 24	 mov	 eax, DWORD PTR cs$[rsp]
  0004e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00052	73 40		 jae	 SHORT $LN3@getFirstCh

; 105  : 		{
; 106  : 			t = (pANTLR3_BASE_TREE) (tree->children->get(tree->children, i));

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  00059	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005d	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tree$[rsp]
  00066	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0006a	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00070	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 107  : 			if  (tree->getType(t) == type)

  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR tree$[rsp]
  0007f	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00085	3b 44 24 48	 cmp	 eax, DWORD PTR type$[rsp]
  00089	75 07		 jne	 SHORT $LN6@getFirstCh

; 108  : 			{
; 109  : 				return  (pANTLR3_BASE_TREE)t;

  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00090	eb 04		 jmp	 SHORT $LN1@getFirstCh
$LN6@getFirstCh:

; 110  : 			}
; 111  : 		}

  00092	eb ac		 jmp	 SHORT $LN2@getFirstCh
$LN3@getFirstCh:
$LN5@getFirstCh:

; 112  : 	}
; 113  : 	return  NULL;

  00094	33 c0		 xor	 eax, eax
$LN1@getFirstCh:

; 114  : }

  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
getFirstChildWithType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getLine
_TEXT	SEGMENT
tree$ = 16
getLine	PROC						; COMDAT

; 91   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 92   : 	return  0;

  00006	33 c0		 xor	 eax, eax

; 93   : }

  00008	5f		 pop	 rdi
  00009	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
tree$ = 16
getCharPositionInLine PROC				; COMDAT

; 85   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 86   : 	return  0;

  00006	33 c0		 xor	 eax, eax

; 87   : }

  00008	5f		 pop	 rdi
  00009	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getChildCount
_TEXT	SEGMENT
tree$ = 48
getChildCount PROC					; COMDAT

; 132  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 133  : 	if	(tree->children == NULL)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0000f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00014	75 06		 jne	 SHORT $LN2@getChildCo

; 134  : 	{
; 135  : 		return 0;

  00016	33 c0		 xor	 eax, eax
  00018	eb 1a		 jmp	 SHORT $LN1@getChildCo

; 136  : 	}

  0001a	eb 18		 jmp	 SHORT $LN3@getChildCo
$LN2@getChildCo:

; 137  : 	else
; 138  : 	{
; 139  : 		return	tree->children->size(tree->children);

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00021	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0002a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002e	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
$LN3@getChildCo:
$LN1@getChildCo:

; 140  : 	}
; 141  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT getChild
_TEXT	SEGMENT
tree$ = 48
i$ = 56
getChild PROC						; COMDAT

; 120  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 121  : 	if	(      tree->children == NULL
; 122  : 		|| i >= tree->children->size(tree->children))

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00013	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00018	74 1e		 je	 SHORT $LN3@getChild
  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  00028	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002c	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00032	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00036	72 04		 jb	 SHORT $LN2@getChild
$LN3@getChild:

; 123  : 	{
; 124  : 		return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 1c		 jmp	 SHORT $LN1@getChild
$LN2@getChild:

; 125  : 	}
; 126  : 	return  tree->children->get(tree->children, i);

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR tree$[rsp]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	8b 54 24 38	 mov	 edx, DWORD PTR i$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tree$[rsp]
  0004e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00052	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
$LN1@getChild:

; 127  : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetree.c
;	COMDAT antlr3BaseTreeNew
_TEXT	SEGMENT
tree$ = 16
antlr3BaseTreeNew PROC					; COMDAT

; 59   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 60   : 	/* api */
; 61   : 	tree->getChild				= getChild;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChild
  00012	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 62   : 	tree->getChildCount			= getChildCount;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildCount
  00022	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 63   : 	tree->addChild				= (void (*)(pANTLR3_BASE_TREE, void *))(addChild);

  00029	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChild
  00035	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 64   : 	tree->addChildren			= addChildren;

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChildren
  00045	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 65   : 	tree->setChild				= setChild;

  00049	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChild
  00055	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 66   : 	tree->deleteChild			= deleteChild;

  0005c	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:deleteChild
  00068	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 67   : 	tree->dupTree				= dupTree;

  0006c	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  00078	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 68   : 	tree->toStringTree			= toStringTree;

  0007c	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toStringTree
  00088	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 69   : 	tree->getCharPositionInLine	= getCharPositionInLine;

  0008f	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  0009b	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 70   : 	tree->getLine				= getLine;

  0009f	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  000ab	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 71   : 	tree->replaceChildren		= replaceChildren;

  000b2	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:replaceChildren
  000be	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 72   : 	tree->freshenPACIndexesAll	= freshenPACIndexesAll;

  000c2	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freshenPACIndexesAll
  000ce	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 73   : 	tree->freshenPACIndexes		= freshenPACIndexes;

  000d5	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freshenPACIndexes
  000e1	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 74   : 	tree->getFirstChildWithType	= (void *(*)(pANTLR3_BASE_TREE, ANTLR3_UINT32))(getFirstChildWithType);

  000e8	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getFirstChildWithType
  000f4	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 75   : 	tree->children				= NULL;

  000fb	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  00100	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 76   : 	tree->strFactory			= NULL;

  00108	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]
  0010d	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 77   : 
; 78   : 	/* Rest must be filled in by caller.
; 79   : 	*/
; 80   : 	return  tree;

  00115	48 8b 44 24 10	 mov	 rax, QWORD PTR tree$[rsp]

; 81   : }

  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
antlr3BaseTreeNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  0004b	e8 00 00 00 00	 call	 _vfprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 842  :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 843  :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 844  :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
