; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	antlr3DebugListenerNew
PUBLIC	antlr3DebugListenerNewPort
PUBLIC	serializeText
PUBLIC	serializeToken
PUBLIC	serializeNode
PUBLIC	??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@		; `string'
PUBLIC	??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@		; `string'
PUBLIC	??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@ ; `string'
PUBLIC	??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@ ; `string'
PUBLIC	??_C@_02KINNFLEC@?7?$CC@			; `string'
PUBLIC	??_C@_03IEFOOEDL@?$CF0A@			; `string'
PUBLIC	??_C@_03PJCJBAHO@?$CF0D@			; `string'
PUBLIC	??_C@_03MMIJIMKH@?$CF25@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@	; `string'
PUBLIC	??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@		; `string'
PUBLIC	??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@	; `string'
PUBLIC	??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@	; `string'
PUBLIC	??_C@_0O@CLDGECJA@consumeToken?7@		; `string'
PUBLIC	??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@	; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7@				; `string'
PUBLIC	??_C@_03LFAOPKED@LT?7@				; `string'
PUBLIC	??_C@_08JOJCKFBH@mark?7?$CFd?6@			; `string'
PUBLIC	??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@		; `string'
PUBLIC	??_C@_07EBOLPGDK@rewind?6@			; `string'
PUBLIC	??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@ ; `string'
PUBLIC	??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@ ; `string'
PUBLIC	??_C@_0N@DCBHEMKM@beginResync?6@		; `string'
PUBLIC	??_C@_0L@KHCEOHOJ@endResync?6@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@	; `string'
PUBLIC	??_C@_0L@KANKBBAE@terminate?6@			; `string'
PUBLIC	??_C@_0N@CLFGHGNF@consumeNode?7@		; `string'
PUBLIC	??_C@_03KELPNMOF@LN?7@				; `string'
PUBLIC	??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@		; `string'
PUBLIC	??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@ ; `string'
PUBLIC	??_C@_0L@OOIEOANM@errorNode?7@			; `string'
PUBLIC	??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@ ; `string'
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	accept:PROC
EXTRN	bind:PROC
EXTRN	closesocket:PROC
EXTRN	htonl:PROC
EXTRN	htons:PROC
EXTRN	listen:PROC
EXTRN	recv:PROC
EXTRN	send:PROC
EXTRN	setsockopt:PROC
EXTRN	shutdown:PROC
EXTRN	socket:PROC
EXTRN	WSAStartup:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3DebugListenerNew DD imagerel $LN4
	DD	imagerel $LN4+657
	DD	imagerel $unwind$antlr3DebugListenerNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$handshake DD imagerel handshake
	DD	imagerel handshake+645
	DD	imagerel $unwind$handshake
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterRule DD imagerel enterRule
	DD	imagerel enterRule+157
	DD	imagerel $unwind$enterRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterAlt DD imagerel enterAlt
	DD	imagerel enterAlt+143
	DD	imagerel $unwind$enterAlt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitRule DD imagerel exitRule
	DD	imagerel exitRule+157
	DD	imagerel $unwind$exitRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterSubRule DD imagerel enterSubRule
	DD	imagerel enterSubRule+143
	DD	imagerel $unwind$enterSubRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitSubRule DD imagerel exitSubRule
	DD	imagerel exitSubRule+143
	DD	imagerel $unwind$exitSubRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enterDecision DD imagerel enterDecision
	DD	imagerel enterDecision+143
	DD	imagerel $unwind$enterDecision
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitDecision DD imagerel exitDecision
	DD	imagerel exitDecision+143
	DD	imagerel $unwind$exitDecision
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeToken DD imagerel consumeToken
	DD	imagerel consumeToken+100
	DD	imagerel $unwind$consumeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeHiddenToken DD imagerel consumeHiddenToken
	DD	imagerel consumeHiddenToken+100
	DD	imagerel $unwind$consumeHiddenToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LT DD	imagerel LT
	DD	imagerel LT+154
	DD	imagerel $unwind$LT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mark DD	imagerel mark
	DD	imagerel mark+158
	DD	imagerel $unwind$mark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rewindMark DD imagerel rewindMark
	DD	imagerel rewindMark+158
	DD	imagerel $unwind$rewindMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rewindLast DD imagerel rewindLast
	DD	imagerel rewindLast+33
	DD	imagerel $unwind$rewindLast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginBacktrack DD imagerel beginBacktrack
	DD	imagerel beginBacktrack+143
	DD	imagerel $unwind$beginBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endBacktrack DD imagerel endBacktrack
	DD	imagerel endBacktrack+159
	DD	imagerel $unwind$endBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$location DD imagerel location
	DD	imagerel location+156
	DD	imagerel $unwind$location
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recognitionException DD imagerel recognitionException
	DD	imagerel recognitionException+190
	DD	imagerel $unwind$recognitionException
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginResync DD imagerel beginResync
	DD	imagerel beginResync+33
	DD	imagerel $unwind$beginResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endResync DD imagerel endResync
	DD	imagerel endResync+33
	DD	imagerel $unwind$endResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$semanticPredicate DD imagerel semanticPredicate
	DD	imagerel semanticPredicate+513
	DD	imagerel $unwind$semanticPredicate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$commence DD imagerel commence
	DD	imagerel commence+8
	DD	imagerel $unwind$commence
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$terminate DD imagerel terminate
	DD	imagerel terminate+43
	DD	imagerel $unwind$terminate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeNode DD imagerel consumeNode
	DD	imagerel consumeNode+119
	DD	imagerel $unwind$consumeNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LTT DD	imagerel LTT
	DD	imagerel LTT+165
	DD	imagerel $unwind$LTT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nilNode DD imagerel nilNode
	DD	imagerel nilNode+177
	DD	imagerel $unwind$nilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$errorNode DD imagerel errorNode
	DD	imagerel errorNode+333
	DD	imagerel $unwind$errorNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createNode DD imagerel createNode
	DD	imagerel createNode+372
	DD	imagerel $unwind$createNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createNodeTok DD imagerel createNodeTok
	DD	imagerel createNodeTok+240
	DD	imagerel $unwind$createNodeTok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$becomeRoot DD imagerel becomeRoot
	DD	imagerel becomeRoot+254
	DD	imagerel $unwind$becomeRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChild DD imagerel addChild
	DD	imagerel addChild+254
	DD	imagerel $unwind$addChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenBoundaries DD imagerel setTokenBoundaries
	DD	imagerel setTokenBoundaries+206
	DD	imagerel $unwind$setTokenBoundaries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ack DD	imagerel ack
	DD	imagerel ack+153
	DD	imagerel $unwind$ack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3DebugListenerNewPort DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$antlr3DebugListenerNewPort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sockSend DD imagerel sockSend
	DD	imagerel sockSend+136
	DD	imagerel $unwind$sockSend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$transmit DD imagerel transmit
	DD	imagerel transmit+63
	DD	imagerel $unwind$transmit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serializeText DD imagerel $LN13
	DD	imagerel $LN13+235
	DD	imagerel $unwind$serializeText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serializeToken DD imagerel $LN4
	DD	imagerel $LN4+515
	DD	imagerel $unwind$serializeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serializeNode DD imagerel $LN7
	DD	imagerel $LN7+740
	DD	imagerel $unwind$serializeNode
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@ DB 'becomeRoot', 09H
	DB	'%d', 09H, '%d', 09H, '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@ DB 'addChild', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@ DB 'becomeRoot', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@ DB 'createNode', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOIEOANM@errorNode?7@
CONST	SEGMENT
??_C@_0L@OOIEOANM@errorNode?7@ DB 'errorNode', 09H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@
CONST	SEGMENT
??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@ DB 'createNodeFromToken'
	DB	'Elements ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@
CONST	SEGMENT
??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@ DB 'nilNode', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KELPNMOF@LN?7@
CONST	SEGMENT
??_C@_03KELPNMOF@LN?7@ DB 'LN', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLFGHGNF@consumeNode?7@
CONST	SEGMENT
??_C@_0N@CLFGHGNF@consumeNode?7@ DB 'consumeNode', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KANKBBAE@terminate?6@
CONST	SEGMENT
??_C@_0L@KANKBBAE@terminate?6@ DB 'terminate', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@
CONST	SEGMENT
??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@ DB 'semanticPredicate', 09H
	DB	'%s', 09H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHCEOHOJ@endResync?6@
CONST	SEGMENT
??_C@_0L@KHCEOHOJ@endResync?6@ DB 'endResync', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCBHEMKM@beginResync?6@
CONST	SEGMENT
??_C@_0N@DCBHEMKM@beginResync?6@ DB 'beginResync', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@ DB 'exception'
	DB	09H, '%s', 09H, '%d', 09H, '%d', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@ DB 'location', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@ DB 'endBacktrack', 09H, '%'
	DB	'd', 09H, '%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@
CONST	SEGMENT
??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@ DB 'beginBacktrack', 09H, '%d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBOLPGDK@rewind?6@
CONST	SEGMENT
??_C@_07EBOLPGDK@rewind?6@ DB 'rewind', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@
CONST	SEGMENT
??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@ DB 'rewind', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOJCKFBH@mark?7?$CFd?6@
CONST	SEGMENT
??_C@_08JOJCKFBH@mark?7?$CFd?6@ DB 'mark', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFAOPKED@LT?7@
CONST	SEGMENT
??_C@_03LFAOPKED@LT?7@ DB 'LT', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@
CONST	SEGMENT
??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@ DB 'consumeHiddenToken', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLDGECJA@consumeToken?7@
CONST	SEGMENT
??_C@_0O@CLDGECJA@consumeToken?7@ DB 'consumeToken', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@
CONST	SEGMENT
??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@ DB 'exitDecision', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@
CONST	SEGMENT
??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@ DB 'enterDecision', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@
CONST	SEGMENT
??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@ DB 'exitSubRule', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@
CONST	SEGMENT
??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@ DB 'enterSubRule', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@
CONST	SEGMENT
??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@ DB 'exitRule', 09H, '%s', 09H
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@
CONST	SEGMENT
??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@ DB 'enterAlt', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@
CONST	SEGMENT
??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@ DB 'enterRule', 09H, '%s', 09H
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMIJIMKH@?$CF25@
CONST	SEGMENT
??_C@_03MMIJIMKH@?$CF25@ DB '%25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJCJBAHO@?$CF0D@
CONST	SEGMENT
??_C@_03PJCJBAHO@?$CF0D@ DB '%0D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEFOOEDL@?$CF0A@
CONST	SEGMENT
??_C@_03IEFOOEDL@?$CF0A@ DB '%0A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KINNFLEC@?7?$CC@
CONST	SEGMENT
??_C@_02KINNFLEC@?7?$CC@ DB 09H, '"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@
CONST	SEGMENT
??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@ DB 'Received'
	DB	' char count was %d, and last char received was %02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@
CONST	SEGMENT
??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@ DB 'Exiting debug'
	DB	'ger as remote client closed the socket', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@
CONST	SEGMENT
??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@ DB 'grammar "%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@
CONST	SEGMENT
??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@ DB 'ANTLR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serializeNode DD 020f01H
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serializeToken DD 020f01H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serializeText DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$transmit DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sockSend DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3DebugListenerNewPort DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ack DD	022001H
	DD	07006720aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ack$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
ack$rtcVarDesc DD 024H
	DD	01H
	DQ	FLAT:ack$rtcName$0
	ORG $+48
ack$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ack$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03fH
	DB	0b5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenBoundaries DD 034719H
	DD	01c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
setTokenBoundaries$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
setTokenBoundaries$rtcVarDesc DD 040H
	DD	080H
	DQ	FLAT:setTokenBoundaries$rtcName$0
	ORG $+48
setTokenBoundaries$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:setTokenBoundaries$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	0e5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChild DD 034219H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
addChild$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
addChild$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:addChild$rtcName$0
	ORG $+48
addChild$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:addChild$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	0e5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$becomeRoot DD 034219H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
becomeRoot$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
becomeRoot$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:becomeRoot$rtcName$0
	ORG $+48
becomeRoot$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:becomeRoot$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	0d7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createNodeTok DD 034219H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
createNodeTok$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
createNodeTok$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:createNodeTok$rtcName$0
	ORG $+48
createNodeTok$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:createNodeTok$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createNode DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$errorNode DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
	DB	098H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nilNode DD 033d19H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
nilNode$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
nilNode$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:nilNode$rtcName$0
	ORG $+48
nilNode$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:nilNode$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LTT DD	021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeNode DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$terminate DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$commence DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$semanticPredicate DD 021301H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endResync DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginResync DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
	DB	0a5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recognitionException DD 033d19H
	DD	02c0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
recognitionException$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
recognitionException$rtcVarDesc DD 040H
	DD	0100H
	DQ	FLAT:recognitionException$rtcName$0
	ORG $+48
recognitionException$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:recognitionException$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	039H
	DB	083H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$location DD 034119H
	DD	01a0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
location$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
location$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:location$rtcName$0
	ORG $+48
location$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:location$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	039H
	DB	086H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endBacktrack DD 034119H
	DD	01a0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
endBacktrack$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
endBacktrack$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:endBacktrack$rtcName$0
	ORG $+48
endBacktrack$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:endBacktrack$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	076H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginBacktrack DD 033c19H
	DD	01a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
beginBacktrack$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
beginBacktrack$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:beginBacktrack$rtcName$0
	ORG $+48
beginBacktrack$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:beginBacktrack$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rewindLast DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
	DB	085H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rewindMark DD 033d19H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
rewindMark$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
rewindMark$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:rewindMark$rtcName$0
	ORG $+48
rewindMark$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:rewindMark$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
	DB	085H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mark DD	033d19H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
mark$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
mark$rtcVarDesc DD 030H
	DD	080H
	DQ	FLAT:mark$rtcName$0
	ORG $+48
mark$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:mark$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LT DD	021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeHiddenToken DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeToken DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	076H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitDecision DD 033c19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
exitDecision$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
exitDecision$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:exitDecision$rtcName$0
	ORG $+48
exitDecision$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:exitDecision$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	076H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterDecision DD 033c19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterDecision$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterDecision$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterDecision$rtcName$0
	ORG $+48
enterDecision$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterDecision$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	076H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitSubRule DD 033c19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
exitSubRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
exitSubRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:exitSubRule$rtcName$0
	ORG $+48
exitSubRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:exitSubRule$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	076H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterSubRule DD 033c19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterSubRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterSubRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterSubRule$rtcName$0
	ORG $+48
enterSubRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterSubRule$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	084H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitRule DD 034219H
	DD	04a0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
exitRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
exitRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:exitRule$rtcName$0
	ORG $+48
exitRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:exitRule$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	076H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterAlt DD 033c19H
	DD	04a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterAlt$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterAlt$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterAlt$rtcName$0
	ORG $+48
enterAlt$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterAlt$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	084H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enterRule DD 034219H
	DD	04a0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
enterRule$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
enterRule$rtcVarDesc DD 030H
	DD	0200H
	DQ	FLAT:enterRule$rtcName$0
	ORG $+48
enterRule$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:enterRule$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	030H
	DW	026cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handshake DD 033819H
	DD	07a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	03c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
handshake$rtcName$0 DB 063H
	DB	06cH
	DB	069H
	DB	065H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+1
handshake$rtcName$1 DB 073H
	DB	065H
	DB	072H
	DB	076H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
handshake$rtcName$2 DB 06dH
	DB	065H
	DB	073H
	DB	073H
	DB	061H
	DB	067H
	DB	065H
	DB	00H
handshake$rtcName$3 DB 073H
	DB	06fH
	DB	063H
	DB	06bH
	DB	061H
	DB	064H
	DB	064H
	DB	072H
	DB	05fH
	DB	06cH
	DB	065H
	DB	06eH
	DB	00H
	ORG $+3
handshake$rtcName$4 DB 06fH
	DB	070H
	DB	074H
	DB	056H
	DB	061H
	DB	06cH
	DB	00H
	ORG $+1
handshake$rtcName$5 DB 077H
	DB	073H
	DB	061H
	DB	044H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+8
handshake$rtcVarDesc DD 0210H
	DD	0198H
	DQ	FLAT:handshake$rtcName$5
	DD	01e4H
	DD	04H
	DQ	FLAT:handshake$rtcName$4
	DD	01c4H
	DD	04H
	DQ	FLAT:handshake$rtcName$3
	DD	0b0H
	DD	0100H
	DQ	FLAT:handshake$rtcName$2
	DD	078H
	DD	010H
	DQ	FLAT:handshake$rtcName$1
	DD	048H
	DD	010H
	DQ	FLAT:handshake$rtcName$0
	ORG $+288
handshake$rtcFrameData DD 06H
	DD	00H
	DQ	FLAT:handshake$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3DebugListenerNew DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT serializeNode
_TEXT	SEGMENT
token$ = 32
tv245 = 40
tv241 = 48
tv238 = 56
tv235 = 64
tv233 = 72
tv227 = 80
delboy$ = 112
node$ = 120
serializeNode PROC					; COMDAT

; 465  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 466  : 	pANTLR3_COMMON_TOKEN	token;
; 467  : 
; 468  : 
; 469  : 	// Do we already have a serialization buffer?
; 470  : 	//
; 471  : 	if	(delboy->tokenString == NULL)

  0000f	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00014	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00019	75 33		 jne	 SHORT $LN2@serializeN

; 472  : 	{
; 473  : 		// No, so create one, using the string factory that
; 474  : 		// the grammar name used, which is guaranteed to exist.
; 475  : 		// 64 bytes will do us here for starters. 
; 476  : 		//
; 477  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0001b	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00029	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	48 89 4c 24 28	 mov	 QWORD PTR tv245[rsp], rcx
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv245[rsp]
  00042	ff 50 18	 call	 QWORD PTR [rax+24]
  00045	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0004a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@serializeN:

; 478  : 	}
; 479  : 
; 480  : 	// Empty string
; 481  : 	//
; 482  : 	delboy->tokenString->set(delboy->tokenString, (const char *)"");

  0004e	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00063	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00067	ff 50 20	 call	 QWORD PTR [rax+32]

; 483  : 
; 484  : 	// Protect against bugs/errors etc
; 485  : 	//
; 486  : 	if	(node == NULL)

  0006a	48 83 7c 24 78
	00		 cmp	 QWORD PTR node$[rsp], 0
  00070	75 0e		 jne	 SHORT $LN3@serializeN

; 487  : 	{
; 488  : 		return delboy->tokenString;

  00072	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00077	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007b	e9 5e 02 00 00	 jmp	 $LN1@serializeN
$LN3@serializeN:

; 489  : 	}
; 490  : 
; 491  : 	// Now we serialize the elements of the node.Note that the debugger only
; 492  : 	// uses 32 bits.
; 493  : 	//
; 494  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00080	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00085	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00089	ba 09 00 00 00	 mov	 edx, 9
  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00093	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00097	ff 50 70	 call	 QWORD PTR [rax+112]

; 495  : 
; 496  : 	// Adaptor ID
; 497  : 	//
; 498  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, node));

  0009a	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0009f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000a3	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  000a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000ad	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000b1	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  000b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000bc	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000c0	48 89 4c 24 30	 mov	 QWORD PTR tv241[rsp], rcx
  000c5	8b d0		 mov	 edx, eax
  000c7	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  000cc	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000d0	48 8b 44 24 30	 mov	 rax, QWORD PTR tv241[rsp]
  000d5	ff 50 78	 call	 QWORD PTR [rax+120]

; 499  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000d8	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  000dd	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000e1	ba 09 00 00 00	 mov	 edx, 9
  000e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  000eb	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000ef	ff 50 70	 call	 QWORD PTR [rax+112]

; 500  : 
; 501  : 	// Type of the current token (which may be imaginary)
; 502  : 	//
; 503  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getType(delboy->adaptor, node));

  000f2	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  000f7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000fb	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  00100	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00105	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00109	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
  0010f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00114	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00118	48 89 4c 24 38	 mov	 QWORD PTR tv238[rsp], rcx
  0011d	8b d0		 mov	 edx, eax
  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00124	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00128	48 8b 44 24 38	 mov	 rax, QWORD PTR tv238[rsp]
  0012d	ff 50 78	 call	 QWORD PTR [rax+120]

; 504  : 
; 505  : 	// See if we have an actual token or just an imaginary
; 506  : 	//
; 507  : 	token	= delboy->adaptor->getToken(delboy->adaptor, node);

  00130	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00135	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00139	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  0013e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00143	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00147	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]
  0014d	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 508  : 
; 509  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00152	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00157	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0015b	ba 09 00 00 00	 mov	 edx, 9
  00160	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00165	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00169	ff 50 70	 call	 QWORD PTR [rax+112]

; 510  : 	if	(token != NULL)

  0016c	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  00172	74 7e		 je	 SHORT $LN4@serializeN

; 511  : 	{
; 512  : 		// Real token
; 513  : 		//
; 514  : 		delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(token->getLine(token)));

  00174	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0017e	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00189	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0018d	48 89 4c 24 40	 mov	 QWORD PTR tv235[rsp], rcx
  00192	8b d0		 mov	 edx, eax
  00194	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00199	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR tv235[rsp]
  001a2	ff 50 78	 call	 QWORD PTR [rax+120]

; 515  : 		delboy->tokenString->addc(delboy->tokenString, ' ');

  001a5	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  001aa	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001ae	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  001b8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001bc	ff 50 70	 call	 QWORD PTR [rax+112]

; 516  : 		delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(token->getCharPositionInLine(token)));

  001bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001c4	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  001c9	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  001cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  001d4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001d8	48 89 4c 24 48	 mov	 QWORD PTR tv233[rsp], rcx
  001dd	8b d0		 mov	 edx, eax
  001df	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  001e4	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001e8	48 8b 44 24 48	 mov	 rax, QWORD PTR tv233[rsp]
  001ed	ff 50 78	 call	 QWORD PTR [rax+120]

; 517  : 	}

  001f0	eb 4e		 jmp	 SHORT $LN5@serializeN
$LN4@serializeN:

; 518  : 	else
; 519  : 	{
; 520  : 		// Imaginary tokens have no location
; 521  : 		//
; 522  : 		delboy->tokenString->addi(delboy->tokenString, -1);

  001f2	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  001f7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001fb	ba ff ff ff ff	 mov	 edx, -1
  00200	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00205	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00209	ff 50 78	 call	 QWORD PTR [rax+120]

; 523  : 		delboy->tokenString->addc(delboy->tokenString, '\t');

  0020c	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00211	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00215	ba 09 00 00 00	 mov	 edx, 9
  0021a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0021f	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00223	ff 50 70	 call	 QWORD PTR [rax+112]

; 524  : 		delboy->tokenString->addi(delboy->tokenString, -1);

  00226	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0022b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0022f	ba ff ff ff ff	 mov	 edx, -1
  00234	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00239	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0023d	ff 50 78	 call	 QWORD PTR [rax+120]
$LN5@serializeN:

; 525  : 	}
; 526  : 
; 527  : 	// Start Index of the node
; 528  : 	//
; 529  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00240	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  00245	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00249	ba 09 00 00 00	 mov	 edx, 9
  0024e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  00253	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00257	ff 50 70	 call	 QWORD PTR [rax+112]

; 530  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_UINT32)(delboy->adaptor->getTokenStartIndex(delboy->adaptor, node)));

  0025a	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0025f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00263	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  00268	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0026d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00271	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00277	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  0027c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00280	48 89 4c 24 50	 mov	 QWORD PTR tv227[rsp], rcx
  00285	8b d0		 mov	 edx, eax
  00287	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0028c	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00290	48 8b 44 24 50	 mov	 rax, QWORD PTR tv227[rsp]
  00295	ff 50 78	 call	 QWORD PTR [rax+120]

; 531  : 
; 532  : 	// Now send the text that the node represents.
; 533  : 	//
; 534  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, node));

  00298	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  0029d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002a1	48 8b 54 24 78	 mov	 rdx, QWORD PTR node$[rsp]
  002a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  002ab	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  002af	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  002b5	48 8b d0	 mov	 rdx, rax
  002b8	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  002bd	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  002c1	e8 00 00 00 00	 call	 serializeText

; 535  : 
; 536  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 537  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 538  : 	// must force encode it. We have a method to do this in the string class, but
; 539  : 	// there is no utf8 string implementation as of yet
; 540  : 	//
; 541  : 	return delboy->tokenString->toUTF8(delboy->tokenString);

  002c6	48 8b 44 24 70	 mov	 rax, QWORD PTR delboy$[rsp]
  002cb	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delboy$[rsp]
  002d4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002d8	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
$LN1@serializeN:

; 542  : }

  002de	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002e2	5f		 pop	 rdi
  002e3	c3		 ret	 0
serializeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT serializeToken
_TEXT	SEGMENT
tv195 = 32
tv193 = 40
tv191 = 48
tv189 = 56
tv187 = 64
tv185 = 72
delboy$ = 96
t$ = 104
serializeToken PROC					; COMDAT

; 419  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 420  : 	// Do we already have a serialization buffer?
; 421  : 	//
; 422  : 	if	(delboy->tokenString == NULL)

  0000f	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00014	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00019	75 33		 jne	 SHORT $LN2@serializeT

; 423  : 	{
; 424  : 		// No, so create one, using the string factory that
; 425  : 		// the grammar name used, which is guaranteed to exist.
; 426  : 		// 64 bytes will do us here for starters. 
; 427  : 		//
; 428  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00029	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	48 89 4c 24 20	 mov	 QWORD PTR tv195[rsp], rcx
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR tv195[rsp]
  00042	ff 50 18	 call	 QWORD PTR [rax+24]
  00045	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  0004a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@serializeT:

; 429  : 	}
; 430  : 
; 431  : 	// Empty string
; 432  : 	//
; 433  : 	delboy->tokenString->set(delboy->tokenString, (const char *)"");

  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00063	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00067	ff 50 20	 call	 QWORD PTR [rax+32]

; 434  : 
; 435  : 	// Now we serialize the elements of the token.Note that the debugger only
; 436  : 	// uses 32 bits.
; 437  : 	//
; 438  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getTokenIndex(t)));

  0006a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  00074	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  0007f	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00083	48 89 4c 24 28	 mov	 QWORD PTR tv193[rsp], rcx
  00088	8b d0		 mov	 edx, eax
  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  0008f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00093	48 8b 44 24 28	 mov	 rax, QWORD PTR tv193[rsp]
  00098	ff 50 78	 call	 QWORD PTR [rax+120]

; 439  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000a0	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a4	ba 09 00 00 00	 mov	 edx, 9
  000a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  000ae	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b2	ff 50 70	 call	 QWORD PTR [rax+112]

; 440  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getType(t)));

  000b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  000ba	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  000bf	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  000ca	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000ce	48 89 4c 24 30	 mov	 QWORD PTR tv191[rsp], rcx
  000d3	8b d0		 mov	 edx, eax
  000d5	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000da	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000de	48 8b 44 24 30	 mov	 rax, QWORD PTR tv191[rsp]
  000e3	ff 50 78	 call	 QWORD PTR [rax+120]

; 441  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  000eb	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ef	ba 09 00 00 00	 mov	 edx, 9
  000f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  000f9	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000fd	ff 50 70	 call	 QWORD PTR [rax+112]

; 442  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getChannel(t)));

  00100	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  00105	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  0010a	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00110	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00115	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00119	48 89 4c 24 38	 mov	 QWORD PTR tv189[rsp], rcx
  0011e	8b d0		 mov	 edx, eax
  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00125	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00129	48 8b 44 24 38	 mov	 rax, QWORD PTR tv189[rsp]
  0012e	ff 50 78	 call	 QWORD PTR [rax+120]

; 443  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00131	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00136	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013a	ba 09 00 00 00	 mov	 edx, 9
  0013f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00144	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00148	ff 50 70	 call	 QWORD PTR [rax+112]

; 444  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getLine(t)));

  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  00155	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  00160	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00164	48 89 4c 24 40	 mov	 QWORD PTR tv187[rsp], rcx
  00169	8b d0		 mov	 edx, eax
  0016b	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00170	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00174	48 8b 44 24 40	 mov	 rax, QWORD PTR tv187[rsp]
  00179	ff 50 78	 call	 QWORD PTR [rax+120]

; 445  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  00181	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00185	ba 09 00 00 00	 mov	 edx, 9
  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  0018f	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00193	ff 50 70	 call	 QWORD PTR [rax+112]

; 446  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getCharPositionInLine(t)));

  00196	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  001a0	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  001a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  001ab	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001af	48 89 4c 24 48	 mov	 QWORD PTR tv185[rsp], rcx
  001b4	8b d0		 mov	 edx, eax
  001b6	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  001bb	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001bf	48 8b 44 24 48	 mov	 rax, QWORD PTR tv185[rsp]
  001c4	ff 50 78	 call	 QWORD PTR [rax+120]

; 447  : 
; 448  : 	// Now send the text that the token represents.
; 449  : 	//
; 450  : 	serializeText(delboy->tokenString, t->getText(t));

  001c7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t$[rsp]
  001cc	48 8b 44 24 68	 mov	 rax, QWORD PTR t$[rsp]
  001d1	ff 50 78	 call	 QWORD PTR [rax+120]
  001d4	48 8b d0	 mov	 rdx, rax
  001d7	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  001dc	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001e0	e8 00 00 00 00	 call	 serializeText

; 451  : 
; 452  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 453  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 454  : 	// must force encode it. We have a method to do this in the string class, but
; 455  : 	// it returns malloc space that we must free afterwards.
; 456  : 	//
; 457  : 	return delboy->tokenString->toUTF8(delboy->tokenString);

  001e5	48 8b 44 24 60	 mov	 rax, QWORD PTR delboy$[rsp]
  001ea	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delboy$[rsp]
  001f3	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001f7	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 458  : }

  001fd	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00201	5f		 pop	 rdi
  00202	c3		 ret	 0
serializeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT serializeText
_TEXT	SEGMENT
c$ = 32
character$ = 36
tv75 = 40
buffer$ = 64
text$ = 72
serializeText PROC					; COMDAT

; 366  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 367  : 	ANTLR3_UINT32	c;
; 368  : 	ANTLR3_UCHAR	character;
; 369  : 
; 370  : 	// strings lead in with a "
; 371  : 	//
; 372  : 	buffer->append(buffer, "\t\"");

  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KINNFLEC@?7?$CC@
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  00020	ff 50 30	 call	 QWORD PTR [rax+48]

; 373  : 
; 374  : 	if	(text == NULL)

  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR text$[rsp], 0
  00029	75 05		 jne	 SHORT $LN7@serializeT

; 375  : 	{
; 376  : 		return;

  0002b	e9 b5 00 00 00	 jmp	 $LN1@serializeT
$LN7@serializeT:

; 377  : 	}
; 378  : 
; 379  : 	// Now we replace linefeeds, newlines and the escape
; 380  : 	// leadin character '%' with their hex equivalents
; 381  : 	// prefixed by '%'
; 382  : 	//
; 383  : 	for	(c = 0; c < text->len; c++)

  00030	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR c$[rsp], 0
  00038	eb 0a		 jmp	 SHORT $LN4@serializeT
$LN2@serializeT:
  0003a	8b 44 24 20	 mov	 eax, DWORD PTR c$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 20	 mov	 DWORD PTR c$[rsp], eax
$LN4@serializeT:
  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR text$[rsp]
  00049	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0004c	39 44 24 20	 cmp	 DWORD PTR c$[rsp], eax
  00050	0f 83 8f 00 00
	00		 jae	 $LN3@serializeT

; 384  : 	{
; 385  : 		switch	(character = text->charAt(text, c))

  00056	8b 54 24 20	 mov	 edx, DWORD PTR c$[rsp]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR text$[rsp]
  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR text$[rsp]
  00064	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0006a	89 44 24 24	 mov	 DWORD PTR character$[rsp], eax
  0006e	8b 44 24 24	 mov	 eax, DWORD PTR character$[rsp]
  00072	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  00076	83 7c 24 28 0a	 cmp	 DWORD PTR tv75[rsp], 10
  0007b	74 10		 je	 SHORT $LN8@serializeT
  0007d	83 7c 24 28 0d	 cmp	 DWORD PTR tv75[rsp], 13
  00082	74 1f		 je	 SHORT $LN9@serializeT
  00084	83 7c 24 28 5c	 cmp	 DWORD PTR tv75[rsp], 92	; 0000005cH
  00089	74 2e		 je	 SHORT $LN10@serializeT
  0008b	eb 42		 jmp	 SHORT $LN11@serializeT
$LN8@serializeT:

; 386  : 		{
; 387  : 			case	'\n':
; 388  : 
; 389  : 				buffer->append(buffer, "%0A");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03IEFOOEDL@?$CF0A@
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  0009e	ff 50 30	 call	 QWORD PTR [rax+48]

; 390  : 				break;

  000a1	eb 3d		 jmp	 SHORT $LN5@serializeT
$LN9@serializeT:

; 391  : 
; 392  : 			case	'\r':
; 393  : 			
; 394  : 				buffer->append(buffer, "%0D");

  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03PJCJBAHO@?$CF0D@
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000b4	ff 50 30	 call	 QWORD PTR [rax+48]

; 395  : 				break;

  000b7	eb 27		 jmp	 SHORT $LN5@serializeT
$LN10@serializeT:

; 396  : 
; 397  : 			case	'\\':
; 398  : 
; 399  : 				buffer->append(buffer, "%25");

  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03MMIJIMKH@?$CF25@
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000ca	ff 50 30	 call	 QWORD PTR [rax+48]

; 400  : 				break;

  000cd	eb 11		 jmp	 SHORT $LN5@serializeT
$LN11@serializeT:

; 401  : 
; 402  : 				// Other characters: The Song Remains the Same.
; 403  : 				//
; 404  : 			default:
; 405  : 					
; 406  : 				buffer->addc(buffer, character);

  000cf	8b 54 24 24	 mov	 edx, DWORD PTR character$[rsp]
  000d3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000dd	ff 50 70	 call	 QWORD PTR [rax+112]
$LN5@serializeT:

; 407  : 				break;
; 408  : 		}
; 409  : 	}

  000e0	e9 55 ff ff ff	 jmp	 $LN2@serializeT
$LN3@serializeT:
$LN1@serializeT:

; 410  : }

  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	5f		 pop	 rdi
  000ea	c3		 ret	 0
serializeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT transmit
_TEXT	SEGMENT
delboy$ = 48
ptr$ = 56
transmit PROC						; COMDAT

; 324  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 325  : 	sockSend(delboy->socket, ptr, (int)strlen(ptr));

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	44 8b c0	 mov	 r8d, eax
  0001c	48 8b 54 24 38	 mov	 rdx, QWORD PTR ptr$[rsp]
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR delboy$[rsp]
  00026	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002a	e8 00 00 00 00	 call	 sockSend

; 326  : 	ack(delboy);

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  00034	e8 00 00 00 00	 call	 ack

; 327  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
transmit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT sockSend
_TEXT	SEGMENT
sent$ = 32
thisSend$ = 36
sock$ = 64
ptr$ = 72
len$ = 80
sockSend PROC						; COMDAT

; 166  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 167  : 	int		sent;
; 168  : 	int		thisSend;
; 169  : 
; 170  : 	sent	= 0;

  00014	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR sent$[rsp], 0
$LN2@sockSend:

; 171  : 		
; 172  : 	while	(sent < len)

  0001c	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00020	39 44 24 20	 cmp	 DWORD PTR sent$[rsp], eax
  00024	7d 57		 jge	 SHORT $LN3@sockSend

; 173  : 	{
; 174  : 		// Send as many bytes as we can
; 175  : 		//
; 176  : 		thisSend =	send(sock, ptr, len - sent, 0);

  00026	8b 44 24 20	 mov	 eax, DWORD PTR sent$[rsp]
  0002a	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  0002e	2b c8		 sub	 ecx, eax
  00030	8b c1		 mov	 eax, ecx
  00032	45 33 c9	 xor	 r9d, r9d
  00035	44 8b c0	 mov	 r8d, eax
  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sock$[rsp]
  00042	e8 00 00 00 00	 call	 send
  00047	89 44 24 24	 mov	 DWORD PTR thisSend$[rsp], eax

; 177  : 
; 178  : 		// Check for errors and tell the user if we got one
; 179  : 		//
; 180  : 		if	(thisSend	== -1)

  0004b	83 7c 24 24 ff	 cmp	 DWORD PTR thisSend$[rsp], -1
  00050	75 04		 jne	 SHORT $LN4@sockSend

; 181  : 		{
; 182  : 			return	ANTLR3_FALSE;

  00052	33 c0		 xor	 eax, eax
  00054	eb 2c		 jmp	 SHORT $LN1@sockSend
$LN4@sockSend:

; 183  : 		}
; 184  : 
; 185  : 		// Increment our offset by how many we were able to send
; 186  : 		//
; 187  : 		ptr			+= thisSend;

  00056	48 63 44 24 24	 movsxd	 rax, DWORD PTR thisSend$[rsp]
  0005b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ptr$[rsp]
  00060	48 03 c8	 add	 rcx, rax
  00063	48 8b c1	 mov	 rax, rcx
  00066	48 89 44 24 48	 mov	 QWORD PTR ptr$[rsp], rax

; 188  : 		sent		+= thisSend;

  0006b	8b 44 24 24	 mov	 eax, DWORD PTR thisSend$[rsp]
  0006f	8b 4c 24 20	 mov	 ecx, DWORD PTR sent$[rsp]
  00073	03 c8		 add	 ecx, eax
  00075	8b c1		 mov	 eax, ecx
  00077	89 44 24 20	 mov	 DWORD PTR sent$[rsp], eax

; 189  : 	}

  0007b	eb 9f		 jmp	 SHORT $LN2@sockSend
$LN3@sockSend:

; 190  : 	return	ANTLR3_TRUE;

  0007d	b8 01 00 00 00	 mov	 eax, 1
$LN1@sockSend:

; 191  : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
sockSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT antlr3DebugListenerNewPort
_TEXT	SEGMENT
delboy$ = 32
port$ = 64
antlr3DebugListenerNewPort PROC				; COMDAT

; 148  : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 149  : 	pANTLR3_DEBUG_EVENT_LISTENER	delboy;
; 150  : 
; 151  : 	delboy		 = antlr3DebugListenerNew();

  00009	e8 00 00 00 00	 call	 antlr3DebugListenerNew
  0000e	48 89 44 24 20	 mov	 QWORD PTR delboy$[rsp], rax

; 152  : 
; 153  : 	if	(delboy != NULL)

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR delboy$[rsp], 0
  00019	74 0b		 je	 SHORT $LN2@antlr3Debu

; 154  : 	{
; 155  : 		delboy->port = port;

  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00020	8b 4c 24 40	 mov	 ecx, DWORD PTR port$[rsp]
  00024	89 08		 mov	 DWORD PTR [rax], ecx
$LN2@antlr3Debu:

; 156  : 	}
; 157  : 
; 158  : 	return delboy;

  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]

; 159  : }

  0002b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
antlr3DebugListenerNewPort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT ack
_TEXT	SEGMENT
buffer$ = 36
rCount$ = 52
delboy$ = 80
ack	PROC						; COMDAT

; 331  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
$LN4@ack:

; 332  : 	// Local buffer to read the next character in to
; 333  : 	//
; 334  : 	char	buffer;
; 335  : 	int		rCount;
; 336  : 
; 337  : 	// Ack terminates in a line feed, so we just wait for
; 338  : 	// one of those. Speed is not of the essence so we don't need
; 339  : 	// to buffer the input or anything.
; 340  : 	//
; 341  : 	do
; 342  : 	{
; 343  : 		rCount = recv(delboy->socket, &buffer, 1, 0);

  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 01 00 00
	00		 mov	 r8d, 1
  00029	48 8d 54 24 24	 lea	 rdx, QWORD PTR buffer$[rsp]
  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00033	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00037	e8 00 00 00 00	 call	 recv
  0003c	89 44 24 34	 mov	 DWORD PTR rCount$[rsp], eax

; 344  : 	}
; 345  : 	while	(rCount == 1 && buffer != '\n');

  00040	83 7c 24 34 01	 cmp	 DWORD PTR rCount$[rsp], 1
  00045	75 0a		 jne	 SHORT $LN5@ack
  00047	0f be 44 24 24	 movsx	 eax, BYTE PTR buffer$[rsp]
  0004c	83 f8 0a	 cmp	 eax, 10
  0004f	75 cf		 jne	 SHORT $LN4@ack
$LN5@ack:

; 346  : 
; 347  : 	// If the socket ws closed on us, then we will get an error or
; 348  : 	// (with a graceful close), 0. We can assume the the debugger stopped for some reason
; 349  : 	// (such as Java crashing again). Therefore we just exit the program
; 350  : 	// completely if we don't get the terminating '\n' for the ack.
; 351  : 	//
; 352  : 	if	(rCount != 1)

  00051	83 7c 24 34 01	 cmp	 DWORD PTR rCount$[rsp], 1
  00056	74 2c		 je	 SHORT $LN6@ack

; 353  : 	{
; 354  : 		ANTLR3_PRINTF("Exiting debugger as remote client closed the socket\n");

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@
  0005f	e8 00 00 00 00	 call	 printf

; 355  : 		ANTLR3_PRINTF("Received char count was %d, and last char received was %02X\n", rCount, buffer);

  00064	0f be 44 24 24	 movsx	 eax, BYTE PTR buffer$[rsp]
  00069	44 8b c0	 mov	 r8d, eax
  0006c	8b 54 24 34	 mov	 edx, DWORD PTR rCount$[rsp]
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@
  00077	e8 00 00 00 00	 call	 printf

; 356  : 		exit(0);

  0007c	33 c9		 xor	 ecx, ecx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN6@ack:
$LN7@ack:

; 357  : 	}
; 358  : }

  00084	48 8b cc	 mov	 rcx, rsp
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ack$rtcFrameData
  0008e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
ack	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT setTokenBoundaries
_TEXT	SEGMENT
buffer$ = 64
__$ArrayPad$ = 208
delboy$ = 240
t$ = 248
tokenStartIndex$ = 256
tokenStopIndex$ = 264
setTokenBoundaries PROC					; COMDAT

; 1037 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1038 : 	char	buffer[128];
; 1039 : 
; 1040 : 	sprintf(buffer, "becomeRoot\t%d\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, t),

  00047	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0004f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00053	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0005b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00063	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00067	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  0006d	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tokenStopIndex$[rsp]
  00074	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00078	44 8b 8c 24 00
	01 00 00	 mov	 r9d, DWORD PTR tokenStartIndex$[rsp]
  00080	44 8b c0	 mov	 r8d, eax
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@
  0008a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0008f	e8 00 00 00 00	 call	 sprintf

; 1041 : 												(ANTLR3_UINT32)tokenStartIndex,
; 1042 : 												(ANTLR3_UINT32)tokenStopIndex
; 1043 : 											);
; 1044 : 	transmit(delboy, buffer);

  00094	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00099	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000a1	e8 00 00 00 00	 call	 transmit

; 1045 : }

  000a6	48 8b cc	 mov	 rcx, rsp
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:setTokenBoundaries$rtcFrameData
  000b0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000b5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000bd	48 33 cc	 xor	 rcx, rsp
  000c0	e8 00 00 00 00	 call	 __security_check_cookie
  000c5	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
setTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT addChild
_TEXT	SEGMENT
buffer$ = 48
tv67 = 192
tv82 = 200
__$ArrayPad$ = 208
delboy$ = 240
root$ = 248
child$ = 256
addChild PROC						; COMDAT

; 1026 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1027 : 	char	buffer[128];
; 1028 : 
; 1029 : 	sprintf(buffer, "addChild\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, root),

  00042	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0004a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004e	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR child$[rsp]
  00056	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00062	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00068	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0006f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00077	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0007b	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv82[rsp], rcx
  00083	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR root$[rsp]
  0008b	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR delboy$[rsp]
  00093	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00097	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR tv82[rsp]
  0009f	41 ff 90 00 01
	00 00		 call	 QWORD PTR [r8+256]
  000a6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv67[rsp]
  000ad	44 8b c9	 mov	 r9d, ecx
  000b0	44 8b c0	 mov	 r8d, eax
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@
  000ba	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000bf	e8 00 00 00 00	 call	 sprintf

; 1030 : 											delboy->adaptor->getUniqueID(delboy->adaptor, child)
; 1031 : 											);
; 1032 : 	transmit(delboy, buffer);

  000c4	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000c9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000d1	e8 00 00 00 00	 call	 transmit

; 1033 : }

  000d6	48 8b cc	 mov	 rcx, rsp
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:addChild$rtcFrameData
  000e0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ed	48 33 cc	 xor	 rcx, rsp
  000f0	e8 00 00 00 00	 call	 __security_check_cookie
  000f5	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT becomeRoot
_TEXT	SEGMENT
buffer$ = 48
tv67 = 192
tv82 = 200
__$ArrayPad$ = 208
delboy$ = 240
newRoot$ = 248
oldRoot$ = 256
becomeRoot PROC						; COMDAT

; 1014 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1015 : 	char	buffer[128];
; 1016 : 
; 1017 : 	sprintf(buffer, "becomeRoot\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, newRoot),

  00042	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0004a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004e	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR oldRoot$[rsp]
  00056	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0005e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00062	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00068	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  0006f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00077	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0007b	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv82[rsp], rcx
  00083	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR newRoot$[rsp]
  0008b	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR delboy$[rsp]
  00093	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00097	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR tv82[rsp]
  0009f	41 ff 90 00 01
	00 00		 call	 QWORD PTR [r8+256]
  000a6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv67[rsp]
  000ad	44 8b c9	 mov	 r9d, ecx
  000b0	44 8b c0	 mov	 r8d, eax
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@
  000ba	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000bf	e8 00 00 00 00	 call	 sprintf

; 1018 : 											delboy->adaptor->getUniqueID(delboy->adaptor, oldRoot)
; 1019 : 											);
; 1020 : 	transmit(delboy, buffer);

  000c4	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000c9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000d1	e8 00 00 00 00	 call	 transmit

; 1021 : }

  000d6	48 8b cc	 mov	 rcx, rsp
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:becomeRoot$rtcFrameData
  000e0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ed	48 33 cc	 xor	 rcx, rsp
  000f0	e8 00 00 00 00	 call	 __security_check_cookie
  000f5	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
becomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT createNodeTok
_TEXT	SEGMENT
buffer$ = 48
tv66 = 192
tv80 = 200
__$ArrayPad$ = 208
delboy$ = 240
node$ = 248
token$ = 256
createNodeTok PROC					; COMDAT

; 1004 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1005 : 	char	buffer[128];
; 1006 : 
; 1007 : 	sprintf(buffer, "createNode\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, node), (ANTLR3_UINT32)token->getTokenIndex(token));

  00042	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  0004a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00052	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00058	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv66[rsp], rax
  00060	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00068	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0006c	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv80[rsp], rcx
  00074	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR node$[rsp]
  0007c	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR delboy$[rsp]
  00084	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00088	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR tv80[rsp]
  00090	41 ff 90 00 01
	00 00		 call	 QWORD PTR [r8+256]
  00097	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv66[rsp]
  0009f	44 8b c9	 mov	 r9d, ecx
  000a2	44 8b c0	 mov	 r8d, eax
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@
  000ac	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000b1	e8 00 00 00 00	 call	 sprintf

; 1008 : 
; 1009 : 	transmit(delboy, buffer);

  000b6	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000bb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  000c3	e8 00 00 00 00	 call	 transmit

; 1010 : }

  000c8	48 8b cc	 mov	 rcx, rsp
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:createNodeTok$rtcFrameData
  000d2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000d7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000df	48 33 cc	 xor	 rcx, rsp
  000e2	e8 00 00 00 00	 call	 __security_check_cookie
  000e7	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
createNodeTok ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT createNode
_TEXT	SEGMENT
tv170 = 32
tv167 = 40
tv164 = 48
delboy$ = 80
t$ = 88
createNode PROC						; COMDAT

; 917  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 918  : 	// Do we already have a serialization buffer?
; 919  : 	//
; 920  : 	if	(delboy->tokenString == NULL)

  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00014	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00019	75 33		 jne	 SHORT $LN2@createNode

; 921  : 	{
; 922  : 		// No, so create one, using the string factory that
; 923  : 		// the grammar name used, which is guaranteed to exist.
; 924  : 		// 64 bytes will do us here for starters. 
; 925  : 		//
; 926  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00029	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	48 89 4c 24 20	 mov	 QWORD PTR tv170[rsp], rcx
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR tv170[rsp]
  00042	ff 50 18	 call	 QWORD PTR [rax+24]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0004a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@createNode:

; 927  : 	}
; 928  : 
; 929  : 	// Empty string
; 930  : 	//
; 931  : 	delboy->tokenString->set8(delboy->tokenString, (const char *)"createNodeFromTokenElements ");

  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00063	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00067	ff 50 28	 call	 QWORD PTR [rax+40]

; 932  : 
; 933  : 	// Now we serialize the elements of the node.Note that the debugger only
; 934  : 	// uses 32 bits.
; 935  : 	//
; 936  : 	// Adaptor ID
; 937  : 	//
; 938  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  0006f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00073	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0007d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00081	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  0008c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00090	48 89 4c 24 28	 mov	 QWORD PTR tv167[rsp], rcx
  00095	8b d0		 mov	 edx, eax
  00097	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  0009c	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR tv167[rsp]
  000a5	ff 50 78	 call	 QWORD PTR [rax+120]

; 939  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  000ad	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b1	ba 09 00 00 00	 mov	 edx, 9
  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000bb	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000bf	ff 50 70	 call	 QWORD PTR [rax+112]

; 940  : 
; 941  : 	// Type of the current token (which may be imaginary)
; 942  : 	//
; 943  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getType(delboy->adaptor, t));

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  000c7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000cb	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  000d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000d5	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000d9	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  000e4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000e8	48 89 4c 24 30	 mov	 QWORD PTR tv164[rsp], rcx
  000ed	8b d0		 mov	 edx, eax
  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  000f4	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000f8	48 8b 44 24 30	 mov	 rax, QWORD PTR tv164[rsp]
  000fd	ff 50 78	 call	 QWORD PTR [rax+120]

; 944  : 
; 945  : 	// The text that this node represents
; 946  : 	//
; 947  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, t));

  00100	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00105	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00109	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  0010e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00113	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00117	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00125	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00129	e8 00 00 00 00	 call	 serializeText

; 948  : 	delboy->tokenString->addc(delboy->tokenString, '\n');

  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  00133	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00137	ba 0a 00 00 00	 mov	 edx, 10
  0013c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00141	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00145	ff 50 70	 call	 QWORD PTR [rax+112]

; 949  : 
; 950  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 951  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 952  : 	// must force encode it. We have a method to do this in the string class, but
; 953  : 	// there is no utf8 string implementation as of yet
; 954  : 	//
; 955  : 	transmit(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR delboy$[rsp]
  0014d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00151	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00156	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0015a	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00160	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00164	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  00169	e8 00 00 00 00	 call	 transmit

; 956  : 
; 957  : }

  0016e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
createNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT errorNode
_TEXT	SEGMENT
tv163 = 32
tv160 = 40
delboy$ = 64
t$ = 72
errorNode PROC						; COMDAT

; 960  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 961  : 	// Do we already have a serialization buffer?
; 962  : 	//
; 963  : 	if	(delboy->tokenString == NULL)

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00014	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00019	75 33		 jne	 SHORT $LN2@errorNode

; 964  : 	{
; 965  : 		// No, so create one, using the string factory that
; 966  : 		// the grammar name used, which is guaranteed to exist.
; 967  : 		// 64 bytes will do us here for starters. 
; 968  : 		//
; 969  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00029	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	48 89 4c 24 20	 mov	 QWORD PTR tv163[rsp], rcx
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR tv163[rsp]
  00042	ff 50 18	 call	 QWORD PTR [rax+24]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0004a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@errorNode:

; 970  : 	}
; 971  : 
; 972  : 	// Empty string
; 973  : 	//
; 974  : 	delboy->tokenString->set8(delboy->tokenString, (const char *)"errorNode\t");

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OOIEOANM@errorNode?7@
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00063	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00067	ff 50 28	 call	 QWORD PTR [rax+40]

; 975  : 
; 976  : 	// Now we serialize the elements of the node.Note that the debugger only
; 977  : 	// uses 32 bits.
; 978  : 	//
; 979  : 	// Adaptor ID
; 980  : 	//
; 981  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  0006f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00073	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0007d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00081	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0008c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00090	48 89 4c 24 28	 mov	 QWORD PTR tv160[rsp], rcx
  00095	8b d0		 mov	 edx, eax
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  0009c	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR tv160[rsp]
  000a5	ff 50 78	 call	 QWORD PTR [rax+120]

; 982  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000ad	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b1	ba 09 00 00 00	 mov	 edx, 9
  000b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000bb	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000bf	ff 50 70	 call	 QWORD PTR [rax+112]

; 983  : 
; 984  : 	// Type of the current token (which is an error)
; 985  : 	//
; 986  : 	delboy->tokenString->addi(delboy->tokenString, ANTLR3_TOKEN_INVALID);

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000c7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000cb	33 d2		 xor	 edx, edx
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000d2	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000d6	ff 50 78	 call	 QWORD PTR [rax+120]

; 987  : 
; 988  : 	// The text that this node represents
; 989  : 	//
; 990  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, t));

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000de	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000e2	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  000ec	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000f0	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  000f6	48 8b d0	 mov	 rdx, rax
  000f9	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  000fe	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00102	e8 00 00 00 00	 call	 serializeText

; 991  : 	delboy->tokenString->addc(delboy->tokenString, '\n');

  00107	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  0010c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00110	ba 0a 00 00 00	 mov	 edx, 10
  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0011a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0011e	ff 50 70	 call	 QWORD PTR [rax+112]

; 992  : 
; 993  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 994  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 995  : 	// must force encode it. We have a method to do this in the string class, but
; 996  : 	// there is no utf8 string implementation as of yet
; 997  : 	//
; 998  : 	transmit(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00121	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00126	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0012a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0012f	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00133	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00139	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00142	e8 00 00 00 00	 call	 transmit

; 999  : 
; 1000 : }

  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
errorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT nilNode
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
t$ = 232
nilNode	PROC						; COMDAT

; 909  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00017	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 910  : 	char	buffer[128];
; 911  : 	sprintf(buffer, "nilNode\t%d\n", delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0003d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00045	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00049	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00051	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00059	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0005d	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  00063	44 8b c0	 mov	 r8d, eax
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@
  0006d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00072	e8 00 00 00 00	 call	 sprintf

; 912  : 	transmit(delboy, buffer);

  00077	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0007c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00084	e8 00 00 00 00	 call	 transmit

; 913  : }

  00089	48 8b cc	 mov	 rcx, rsp
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:nilNode$rtcFrameData
  00093	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00098	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a0	48 33 cc	 xor	 rcx, rsp
  000a3	e8 00 00 00 00	 call	 __security_check_cookie
  000a8	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
nilNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT LTT
_TEXT	SEGMENT
buffer$ = 32
delboy$ = 64
i$ = 72
t$ = 80
LTT	PROC						; COMDAT

; 890  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 891  : 	pANTLR3_STRING	buffer;
; 892  : 
; 893  : 	buffer = serializeNode	(delboy, t);

  00013	48 8b 54 24 50	 mov	 rdx, QWORD PTR t$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0001d	e8 00 00 00 00	 call	 serializeNode
  00022	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 894  : 
; 895  : 	// Now prepend the command
; 896  : 	//
; 897  : 	buffer->insert8	(buffer, 0, "\t");

  00027	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01GPOEFGEJ@?7@
  0002e	33 d2		 xor	 edx, edx
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0003a	ff 50 48	 call	 QWORD PTR [rax+72]

; 898  : 	buffer->inserti	(buffer, 0, i);

  0003d	44 8b 44 24 48	 mov	 r8d, DWORD PTR i$[rsp]
  00042	33 d2		 xor	 edx, edx
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  0004e	ff 50 68	 call	 QWORD PTR [rax+104]

; 899  : 	buffer->insert8	(buffer, 0, "LN\t");

  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03KELPNMOF@LN?7@
  00058	33 d2		 xor	 edx, edx
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00064	ff 50 48	 call	 QWORD PTR [rax+72]

; 900  : 	buffer->addc	(buffer, '\n');

  00067	ba 0a 00 00 00	 mov	 edx, 10
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00076	ff 50 70	 call	 QWORD PTR [rax+112]

; 901  : 
; 902  : 	// Send to the debugger and wait for the ack
; 903  : 	//
; 904  : 	transmit		(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  0007e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00087	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0008b	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00091	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0009a	e8 00 00 00 00	 call	 transmit

; 905  : }

  0009f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
LTT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT consumeNode
_TEXT	SEGMENT
buffer$ = 32
delboy$ = 64
t$ = 72
consumeNode PROC					; COMDAT

; 873  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 874  : 	pANTLR3_STRING	buffer;
; 875  : 
; 876  : 	buffer = serializeNode	(delboy, t);

  0000f	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00019	e8 00 00 00 00	 call	 serializeNode
  0001e	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 877  : 
; 878  : 	// Now prepend the command
; 879  : 	//
; 880  : 	buffer->insert8	(buffer, 0, "consumeNode\t");

  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CLFGHGNF@consumeNode?7@
  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00036	ff 50 48	 call	 QWORD PTR [rax+72]

; 881  : 	buffer->addc	(buffer, '\n');

  00039	ba 0a 00 00 00	 mov	 edx, 10
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00048	ff 50 70	 call	 QWORD PTR [rax+112]

; 882  : 
; 883  : 	// Send to the debugger and wait for the ack
; 884  : 	//
; 885  : 	transmit		(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR delboy$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00059	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0005d	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00063	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006c	e8 00 00 00 00	 call	 transmit

; 886  : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
consumeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT terminate
_TEXT	SEGMENT
delboy$ = 48
terminate PROC						; COMDAT

; 862  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 863  : 	// Terminate sequence
; 864  : 	//
; 865  : 	sockSend(delboy->socket, "terminate\n", 10);		// Send out the command

  0000a	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KANKBBAE@terminate?6@
  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR delboy$[rsp]
  0001c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00020	e8 00 00 00 00	 call	 sockSend

; 866  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
terminate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT commence
_TEXT	SEGMENT
delboy$ = 16
commence PROC						; COMDAT

; 851  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 852  : 	// Nothing to see here
; 853  : 	//
; 854  : }

  00006	5f		 pop	 rdi
  00007	c3		 ret	 0
commence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT semanticPredicate
_TEXT	SEGMENT
buffer$ = 32
out$ = 40
tv78 = 48
tv87 = 56
delboy$ = 80
result$ = 88
predicate$ = 96
semanticPredicate PROC					; COMDAT

; 788  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 789  : 	unsigned char * buffer;
; 790  : 	unsigned char * out;
; 791  : 
; 792  : 	if	(predicate != NULL)

  00013	48 83 7c 24 60
	00		 cmp	 QWORD PTR predicate$[rsp], 0
  00019	0f 84 dc 01 00
	00		 je	 $LN6@semanticPr

; 793  : 	{
; 794  : 		buffer	= (unsigned char *)ANTLR3_MALLOC(64 + 2*strlen(predicate));

  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR predicate$[rsp]
  00024	e8 00 00 00 00	 call	 strlen
  00029	48 8d 44 00 40	 lea	 rax, QWORD PTR [rax+rax+64]
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00037	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 795  : 
; 796  : 		if	(buffer != NULL)

  0003c	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00042	0f 84 a4 01 00
	00		 je	 $LN7@semanticPr

; 797  : 		{
; 798  : 			out = buffer + sprintf((char *)buffer, "semanticPredicate\t%s\t", result == ANTLR3_TRUE ? "true" : "false");

  00048	0f b6 44 24 58	 movzx	 eax, BYTE PTR result$[rsp]
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 0e		 jne	 SHORT $LN13@semanticPr
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LOAJBDKD@true@
  00059	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  0005e	eb 0c		 jmp	 SHORT $LN14@semanticPr
$LN13@semanticPr:
  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05LAPONLG@false@
  00067	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
$LN14@semanticPr:
  0006c	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv78[rsp]
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  0007d	e8 00 00 00 00	 call	 sprintf
  00082	48 98		 cdqe
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00089	48 03 c8	 add	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax
$LN2@semanticPr:

; 799  : 
; 800  : 			while (*predicate != '\0')

  00094	48 8b 44 24 60	 mov	 rax, QWORD PTR predicate$[rsp]
  00099	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009c	85 c0		 test	 eax, eax
  0009e	0f 84 1e 01 00
	00		 je	 $LN3@semanticPr

; 801  : 			{
; 802  : 				switch(*predicate)

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR predicate$[rsp]
  000a9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ac	88 44 24 38	 mov	 BYTE PTR tv87[rsp], al
  000b0	80 7c 24 38 0a	 cmp	 BYTE PTR tv87[rsp], 10
  000b5	74 17		 je	 SHORT $LN8@semanticPr
  000b7	80 7c 24 38 0d	 cmp	 BYTE PTR tv87[rsp], 13
  000bc	74 54		 je	 SHORT $LN9@semanticPr
  000be	80 7c 24 38 25	 cmp	 BYTE PTR tv87[rsp], 37	; 00000025H
  000c3	0f 84 8a 00 00
	00		 je	 $LN10@semanticPr
  000c9	e9 c6 00 00 00	 jmp	 $LN11@semanticPr
$LN8@semanticPr:

; 803  : 				{
; 804  : 					case	'\n':
; 805  : 						
; 806  : 						*out++	= '%';

  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000d3	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000db	48 ff c0	 inc	 rax
  000de	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 807  : 						*out++	= '0';

  000e3	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000e8	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000f0	48 ff c0	 inc	 rax
  000f3	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 808  : 						*out++	= 'A';

  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  000fd	c6 00 41	 mov	 BYTE PTR [rax], 65	; 00000041H
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00105	48 ff c0	 inc	 rax
  00108	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 809  : 						break;

  0010d	e9 9e 00 00 00	 jmp	 $LN4@semanticPr
$LN9@semanticPr:

; 810  : 
; 811  : 					case	'\r':
; 812  : 
; 813  : 						*out++	= '%';

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00117	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  0011a	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0011f	48 ff c0	 inc	 rax
  00122	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 814  : 						*out++	= '0';

  00127	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0012c	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  0012f	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00134	48 ff c0	 inc	 rax
  00137	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 815  : 						*out++	= 'D';

  0013c	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00141	c6 00 44	 mov	 BYTE PTR [rax], 68	; 00000044H
  00144	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00149	48 ff c0	 inc	 rax
  0014c	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 816  : 						break;

  00151	eb 5d		 jmp	 SHORT $LN4@semanticPr
$LN10@semanticPr:

; 817  : 
; 818  : 					case	'%':
; 819  : 
; 820  : 						*out++	= '%';

  00153	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00158	c6 00 25	 mov	 BYTE PTR [rax], 37	; 00000025H
  0015b	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00160	48 ff c0	 inc	 rax
  00163	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 821  : 						*out++	= '0';

  00168	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0016d	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H
  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00175	48 ff c0	 inc	 rax
  00178	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 822  : 						*out++	= 'D';

  0017d	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00182	c6 00 44	 mov	 BYTE PTR [rax], 68	; 00000044H
  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  0018a	48 ff c0	 inc	 rax
  0018d	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 823  : 						break;

  00192	eb 1c		 jmp	 SHORT $LN4@semanticPr
$LN11@semanticPr:

; 824  : 
; 825  : 
; 826  : 					default:
; 827  : 
; 828  : 						*out++	= *predicate;

  00194	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  00199	48 8b 4c 24 60	 mov	 rcx, QWORD PTR predicate$[rsp]
  0019e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001a1	88 08		 mov	 BYTE PTR [rax], cl
  001a3	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001a8	48 ff c0	 inc	 rax
  001ab	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax
$LN4@semanticPr:

; 829  : 						break;
; 830  : 				}
; 831  : 
; 832  : 				predicate++;

  001b0	48 8b 44 24 60	 mov	 rax, QWORD PTR predicate$[rsp]
  001b5	48 ff c0	 inc	 rax
  001b8	48 89 44 24 60	 mov	 QWORD PTR predicate$[rsp], rax

; 833  : 			}

  001bd	e9 d2 fe ff ff	 jmp	 $LN2@semanticPr
$LN3@semanticPr:

; 834  : 			*out++	= '\n';

  001c2	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001c7	c6 00 0a	 mov	 BYTE PTR [rax], 10
  001ca	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001cf	48 ff c0	 inc	 rax
  001d2	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax

; 835  : 			*out++	= '\0';

  001d7	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001dc	c6 00 00	 mov	 BYTE PTR [rax], 0
  001df	48 8b 44 24 28	 mov	 rax, QWORD PTR out$[rsp]
  001e4	48 ff c0	 inc	 rax
  001e7	48 89 44 24 28	 mov	 QWORD PTR out$[rsp], rax
$LN7@semanticPr:

; 836  : 		}
; 837  : 
; 838  : 		// Send it and wait for the ack
; 839  : 		//
; 840  : 		transmit(delboy, (const char *)buffer);

  001ec	48 8b 54 24 20	 mov	 rdx, QWORD PTR buffer$[rsp]
  001f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delboy$[rsp]
  001f6	e8 00 00 00 00	 call	 transmit
$LN6@semanticPr:

; 841  : 	}
; 842  : }

  001fb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001ff	5f		 pop	 rdi
  00200	c3		 ret	 0
semanticPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT endResync
_TEXT	SEGMENT
delboy$ = 48
endResync PROC						; COMDAT

; 782  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 783  : 	transmit(delboy, (const char *)"endResync\n");

  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KHCEOHOJ@endResync?6@
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  00016	e8 00 00 00 00	 call	 transmit

; 784  : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
endResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT beginResync
_TEXT	SEGMENT
delboy$ = 48
beginResync PROC					; COMDAT

; 776  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 777  : 	transmit(delboy, (const char *)"beginResync\n");

  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DCBHEMKM@beginResync?6@
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  00016	e8 00 00 00 00	 call	 transmit

; 778  : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
beginResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT recognitionException
_TEXT	SEGMENT
buffer$ = 64
__$ArrayPad$ = 336
delboy$ = 368
e$ = 376
recognitionException PROC				; COMDAT

; 764  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00012	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00017	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR [rsp+368]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 765  : 	char	buffer[256];
; 766  : 
; 767  : 	sprintf(buffer, "exception\t%s\t%d\t%d\t%d\n", (char *)(e->name), (ANTLR3_INT32)(e->index), e->line, e->charPositionInLine);

  0003d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00045	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00048	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0004c	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00054	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00057	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005b	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00063	44 8b 48 28	 mov	 r9d, DWORD PTR [rax+40]
  00067	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0006f	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@
  0007a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0007f	e8 00 00 00 00	 call	 sprintf

; 768  : 
; 769  : 	// Transmit the message and wait for ack
; 770  : 	//
; 771  : 	transmit(delboy, buffer);

  00084	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00089	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00091	e8 00 00 00 00	 call	 transmit

; 772  : }

  00096	48 8b cc	 mov	 rcx, rsp
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:recognitionException$rtcFrameData
  000a0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ad	48 33 cc	 xor	 rcx, rsp
  000b0	e8 00 00 00 00	 call	 __security_check_cookie
  000b5	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
recognitionException ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT location
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
line$ = 232
pos$ = 240
location PROC						; COMDAT

; 752  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00016	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001b	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00036	48 33 c4	 xor	 rax, rsp
  00039	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 753  : 	char buffer[128];
; 754  : 
; 755  : 	sprintf(buffer, "location\t%d\t%d\n", line, pos);

  00041	44 8b 8c 24 f0
	00 00 00	 mov	 r9d, DWORD PTR pos$[rsp]
  00049	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR line$[rsp]
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@
  00058	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005d	e8 00 00 00 00	 call	 sprintf

; 756  : 
; 757  : 	// Transmit the message and wait for ack
; 758  : 	//
; 759  : 	transmit(delboy, buffer);

  00062	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00067	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0006f	e8 00 00 00 00	 call	 transmit

; 760  : }

  00074	48 8b cc	 mov	 rcx, rsp
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:location$rtcFrameData
  0007e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00083	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008b	48 33 cc	 xor	 rcx, rsp
  0008e	e8 00 00 00 00	 call	 __security_check_cookie
  00093	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
location ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT endBacktrack
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
level$ = 232
successful$ = 240
endBacktrack PROC					; COMDAT

; 740  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00016	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001b	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00036	48 33 c4	 xor	 rax, rsp
  00039	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 741  : 	char buffer[128];
; 742  : 
; 743  : 	sprintf(buffer, "endBacktrack\t%d\t%d\n", level, successful);

  00041	0f b6 84 24 f0
	00 00 00	 movzx	 eax, BYTE PTR successful$[rsp]
  00049	44 8b c8	 mov	 r9d, eax
  0004c	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR level$[rsp]
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@
  0005b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00060	e8 00 00 00 00	 call	 sprintf

; 744  : 
; 745  : 	// Transmit the message and wait for ack
; 746  : 	//
; 747  : 	transmit(delboy, buffer);

  00065	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0006a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00072	e8 00 00 00 00	 call	 transmit

; 748  : }

  00077	48 8b cc	 mov	 rcx, rsp
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:endBacktrack$rtcFrameData
  00081	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00086	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008e	48 33 cc	 xor	 rcx, rsp
  00091	e8 00 00 00 00	 call	 __security_check_cookie
  00096	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
endBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT beginBacktrack
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
level$ = 232
beginBacktrack PROC					; COMDAT

; 728  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 729  : 	char buffer[128];
; 730  : 
; 731  : 	sprintf(buffer, "beginBacktrack\t%d\n", (ANTLR3_UINT32)(level & 0xFFFFFFFF));

  0003c	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR level$[rsp]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@
  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00050	e8 00 00 00 00	 call	 sprintf

; 732  : 
; 733  : 	// Transmit the message and wait for ack
; 734  : 	//
; 735  : 	transmit(delboy, buffer);

  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00062	e8 00 00 00 00	 call	 transmit

; 736  : }

  00067	48 8b cc	 mov	 rcx, rsp
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:beginBacktrack$rtcFrameData
  00071	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00076	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
beginBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT rewindLast
_TEXT	SEGMENT
delboy$ = 48
rewindLast PROC						; COMDAT

; 722  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 723  : 	transmit(delboy, (const char *)"rewind\n");

  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EBOLPGDK@rewind?6@
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delboy$[rsp]
  00016	e8 00 00 00 00	 call	 transmit

; 724  : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
rewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT rewindMark
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
marker$ = 232
rewindMark PROC						; COMDAT

; 709  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00017	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 710  : 	char buffer[128];
; 711  : 
; 712  : 	sprintf(buffer, "rewind\t%d\n", (ANTLR3_UINT32)(marker & 0xFFFFFFFF));

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR marker$[rsp]
  0004a	48 23 c8	 and	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	44 8b c0	 mov	 r8d, eax
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@
  0005a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005f	e8 00 00 00 00	 call	 sprintf

; 713  : 
; 714  : 	// Transmit the message and wait for ack
; 715  : 	//
; 716  : 	transmit(delboy, buffer);

  00064	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00069	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00071	e8 00 00 00 00	 call	 transmit

; 717  : 
; 718  : }

  00076	48 8b cc	 mov	 rcx, rsp
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:rewindMark$rtcFrameData
  00080	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00085	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008d	48 33 cc	 xor	 rcx, rsp
  00090	e8 00 00 00 00	 call	 __security_check_cookie
  00095	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
rewindMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT mark
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 192
delboy$ = 224
marker$ = 232
mark	PROC						; COMDAT

; 697  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00017	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+224]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 698  : 	char buffer[128];
; 699  : 
; 700  : 	sprintf(buffer, "mark\t%d\n", (ANTLR3_UINT32)(marker & 0xFFFFFFFF));

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR marker$[rsp]
  0004a	48 23 c8	 and	 rcx, rax
  0004d	48 8b c1	 mov	 rax, rcx
  00050	44 8b c0	 mov	 r8d, eax
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JOJCKFBH@mark?7?$CFd?6@
  0005a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005f	e8 00 00 00 00	 call	 sprintf

; 701  : 
; 702  : 	// Transmit the message and wait for ack
; 703  : 	//
; 704  : 	transmit(delboy, buffer);

  00064	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00069	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00071	e8 00 00 00 00	 call	 transmit

; 705  : }

  00076	48 8b cc	 mov	 rcx, rsp
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:mark$rtcFrameData
  00080	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00085	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008d	48 33 cc	 xor	 rcx, rsp
  00090	e8 00 00 00 00	 call	 __security_check_cookie
  00095	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
mark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT LT
_TEXT	SEGMENT
msg$ = 32
delboy$ = 64
i$ = 72
t$ = 80
LT	PROC						; COMDAT

; 669  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 670  : 	pANTLR3_STRING msg;
; 671  : 
; 672  : 	if	(t != NULL)

  00013	48 83 7c 24 50
	00		 cmp	 QWORD PTR t$[rsp], 0
  00019	74 79		 je	 SHORT $LN2@LT

; 673  : 	{
; 674  : 		// Create the serialized token
; 675  : 		//
; 676  : 		msg = serializeToken(delboy, t);

  0001b	48 8b 54 24 50	 mov	 rdx, QWORD PTR t$[rsp]
  00020	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00025	e8 00 00 00 00	 call	 serializeToken
  0002a	48 89 44 24 20	 mov	 QWORD PTR msg$[rsp], rax

; 677  : 
; 678  : 		// Insert the index parameter
; 679  : 		//
; 680  : 		msg->insert8(msg, 0, "\t");

  0002f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01GPOEFGEJ@?7@
  00036	33 d2		 xor	 edx, edx
  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00042	ff 50 48	 call	 QWORD PTR [rax+72]

; 681  : 		msg->inserti(msg, 0, i);

  00045	44 8b 44 24 48	 mov	 r8d, DWORD PTR i$[rsp]
  0004a	33 d2		 xor	 edx, edx
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00056	ff 50 68	 call	 QWORD PTR [rax+104]

; 682  : 
; 683  : 		// Insert the debug event indicator
; 684  : 		//
; 685  : 		msg->insert8(msg, 0, "LT\t");

  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03LFAOPKED@LT?7@
  00060	33 d2		 xor	 edx, edx
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0006c	ff 50 48	 call	 QWORD PTR [rax+72]

; 686  : 
; 687  : 		msg->addc(msg, '\n');

  0006f	ba 0a 00 00 00	 mov	 edx, 10
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  0007e	ff 50 70	 call	 QWORD PTR [rax+112]

; 688  : 
; 689  : 		// Transmit the message and wait for ack
; 690  : 		//
; 691  : 		transmit(delboy, (const char *)(msg->chars));

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00086	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  0008f	e8 00 00 00 00	 call	 transmit
$LN2@LT:

; 692  : 	}
; 693  : }

  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
LT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT consumeHiddenToken
_TEXT	SEGMENT
msg$ = 32
delboy$ = 64
t$ = 72
consumeHiddenToken PROC					; COMDAT

; 647  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 648  : 	pANTLR3_STRING msg;
; 649  : 
; 650  : 	// Create the serialized token
; 651  : 	//
; 652  : 	msg = serializeToken(delboy, t);

  0000f	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00019	e8 00 00 00 00	 call	 serializeToken
  0001e	48 89 44 24 20	 mov	 QWORD PTR msg$[rsp], rax

; 653  : 
; 654  : 	// Insert the debug event indicator
; 655  : 	//
; 656  : 	msg->insert8(msg, 0, "consumeHiddenToken\t");

  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@
  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00036	ff 50 48	 call	 QWORD PTR [rax+72]

; 657  : 
; 658  : 	msg->addc(msg, '\n');

  00039	ba 0a 00 00 00	 mov	 edx, 10
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00048	ff 50 70	 call	 QWORD PTR [rax+112]

; 659  : 
; 660  : 	// Transmit the message and wait for ack
; 661  : 	//
; 662  : 	transmit(delboy, (const char *)(msg->chars));

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00050	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00059	e8 00 00 00 00	 call	 transmit

; 663  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
consumeHiddenToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT consumeToken
_TEXT	SEGMENT
msg$ = 32
delboy$ = 64
t$ = 72
consumeToken PROC					; COMDAT

; 627  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 628  : 	pANTLR3_STRING msg;
; 629  : 
; 630  : 	// Create the serialized token
; 631  : 	//
; 632  : 	msg = serializeToken(delboy, t);

  0000f	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00019	e8 00 00 00 00	 call	 serializeToken
  0001e	48 89 44 24 20	 mov	 QWORD PTR msg$[rsp], rax

; 633  : 
; 634  : 	// Insert the debug event indicator
; 635  : 	//
; 636  : 	msg->insert8(msg, 0, "consumeToken\t");

  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@CLDGECJA@consumeToken?7@
  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00036	ff 50 48	 call	 QWORD PTR [rax+72]

; 637  : 
; 638  : 	msg->addc(msg, '\n');

  00039	ba 0a 00 00 00	 mov	 edx, 10
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR msg$[rsp]
  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00048	ff 50 70	 call	 QWORD PTR [rax+112]

; 639  : 
; 640  : 	// Transmit the message and wait for ack
; 641  : 	//
; 642  : 	transmit(delboy, (const char *)(msg->chars));

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR msg$[rsp]
  00050	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delboy$[rsp]
  00059	e8 00 00 00 00	 call	 transmit

; 643  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
consumeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT exitDecision
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
exitDecision PROC					; COMDAT

; 616  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 617  : 	char	buffer[512];
; 618  : 
; 619  : 	// Create the message (speed is not of the essence)
; 620  : 	//
; 621  : 	sprintf(buffer, "exitDecision\t%d\n", decisionNumber);

  0003c	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@
  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00050	e8 00 00 00 00	 call	 sprintf

; 622  : 	transmit(delboy, buffer);

  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00062	e8 00 00 00 00	 call	 transmit

; 623  : }

  00067	48 8b cc	 mov	 rcx, rsp
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exitDecision$rtcFrameData
  00071	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00076	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
exitDecision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterDecision
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
enterDecision PROC					; COMDAT

; 604  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 605  : 	char	buffer[512];
; 606  : 
; 607  : 	// Create the message (speed is not of the essence)
; 608  : 	//
; 609  : 	sprintf(buffer, "enterDecision\t%d\n", decisionNumber);

  0003c	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@
  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00050	e8 00 00 00 00	 call	 sprintf

; 610  : 	transmit(delboy, buffer);

  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00062	e8 00 00 00 00	 call	 transmit

; 611  : 
; 612  : }

  00067	48 8b cc	 mov	 rcx, rsp
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterDecision$rtcFrameData
  00071	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00076	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
enterDecision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT exitSubRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
exitSubRule PROC					; COMDAT

; 593  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 594  : 	char	buffer[512];
; 595  : 
; 596  : 	// Create the message (speed is not of the essence)
; 597  : 	//
; 598  : 	sprintf(buffer, "exitSubRule\t%d\n", decisionNumber);

  0003c	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@
  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00050	e8 00 00 00 00	 call	 sprintf

; 599  : 	transmit(delboy, buffer);

  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00062	e8 00 00 00 00	 call	 transmit

; 600  : }

  00067	48 8b cc	 mov	 rcx, rsp
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exitSubRule$rtcFrameData
  00071	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00076	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
exitSubRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterSubRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
decisionNumber$ = 616
enterSubRule PROC					; COMDAT

; 582  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 583  : 	char	buffer[512];
; 584  : 
; 585  : 	// Create the message (speed is not of the essence)
; 586  : 	//
; 587  : 	sprintf(buffer, "enterSubRule\t%d\n", decisionNumber);

  0003c	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR decisionNumber$[rsp]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@
  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00050	e8 00 00 00 00	 call	 sprintf

; 588  : 	transmit(delboy, buffer);

  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00062	e8 00 00 00 00	 call	 transmit

; 589  : }

  00067	48 8b cc	 mov	 rcx, rsp
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterSubRule$rtcFrameData
  00071	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00076	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
enterSubRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT exitRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
grammarFileName$ = 616
ruleName$ = 624
exitRule PROC						; COMDAT

; 571  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 572  : 	char	buffer[512];
; 573  : 
; 574  : 	// Create the message (speed is not of the essence)
; 575  : 	//
; 576  : 	sprintf(buffer, "exitRule\t%s\t%s\n", grammarFileName, ruleName);

  00042	4c 8b 8c 24 70
	02 00 00	 mov	 r9, QWORD PTR ruleName$[rsp]
  0004a	4c 8b 84 24 68
	02 00 00	 mov	 r8, QWORD PTR grammarFileName$[rsp]
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@
  00059	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005e	e8 00 00 00 00	 call	 sprintf

; 577  : 	transmit(delboy, buffer);

  00063	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00068	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00070	e8 00 00 00 00	 call	 transmit

; 578  : }

  00075	48 8b cc	 mov	 rcx, rsp
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exitRule$rtcFrameData
  0007f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00084	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
exitRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterAlt
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
alt$ = 616
enterAlt PROC						; COMDAT

; 560  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 561  : 	char	buffer[512];
; 562  : 
; 563  : 	// Create the message (speed is not of the essence)
; 564  : 	//
; 565  : 	sprintf(buffer, "enterAlt\t%d\n", alt);

  0003c	44 8b 84 24 68
	02 00 00	 mov	 r8d, DWORD PTR alt$[rsp]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@
  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00050	e8 00 00 00 00	 call	 sprintf

; 566  : 	transmit(delboy, buffer);

  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00062	e8 00 00 00 00	 call	 transmit

; 567  : }

  00067	48 8b cc	 mov	 rcx, rsp
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterAlt$rtcFrameData
  00071	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00076	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007e	48 33 cc	 xor	 rcx, rsp
  00081	e8 00 00 00 00	 call	 __security_check_cookie
  00086	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
enterAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT enterRule
_TEXT	SEGMENT
buffer$ = 48
__$ArrayPad$ = 576
delboy$ = 608
grammarFileName$ = 616
ruleName$ = 624
enterRule PROC						; COMDAT

; 549  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR [rsp+608]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 550  : 	char	buffer[512];
; 551  : 
; 552  : 	// Create the message (speed is not of the essence)
; 553  : 	//
; 554  : 	sprintf(buffer, "enterRule\t%s\t%s\n", grammarFileName, ruleName);

  00042	4c 8b 8c 24 70
	02 00 00	 mov	 r9, QWORD PTR ruleName$[rsp]
  0004a	4c 8b 84 24 68
	02 00 00	 mov	 r8, QWORD PTR grammarFileName$[rsp]
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@
  00059	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0005e	e8 00 00 00 00	 call	 sprintf

; 555  : 	transmit(delboy, buffer);

  00063	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00068	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00070	e8 00 00 00 00	 call	 transmit

; 556  : }

  00075	48 8b cc	 mov	 rcx, rsp
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enterRule$rtcFrameData
  0007f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00084	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 81 c4 50 02
	00 00		 add	 rsp, 592		; 00000250H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
enterRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT handshake
_TEXT	SEGMENT
serverSocket$ = 48
client$ = 72
server$ = 120
message$ = 176
sockaddr_len$ = 452
optVal$ = 484
wVersionRequested$9 = 500
wsaData$10 = 528
err$11 = 948
__$ArrayPad$ = 960
delboy$ = 992
handshake PROC						; COMDAT

; 195  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec d0 03
	00 00		 sub	 rsp, 976		; 000003d0H
  0000d	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00012	b9 e8 00 00 00	 mov	 ecx, 232		; 000000e8H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR [rsp+992]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 196  : 	/// Connection structure with which to wait and accept a connection from
; 197  : 	/// a debugger.
; 198  : 	///
; 199  : 	SOCKET				serverSocket;
; 200  : 
; 201  : 	// Connection structures to deal with the client after we accept the connection
; 202  : 	// and the server while we accept a connection.
; 203  : 	//
; 204  : 	ANTLR3_SOCKADDRT	client;
; 205  : 	ANTLR3_SOCKADDRT	server;
; 206  : 
; 207  : 	// Buffer to construct our message in
; 208  : 	//
; 209  : 	char	message[256];
; 210  : 
; 211  : 	// Specifies the length of the connection structure to accept()
; 212  : 	// Windows use int, everyone else uses size_t
; 213  : 	//
; 214  : 	ANTLR3_SALENT				sockaddr_len;
; 215  : 
; 216  : 	// Option holder for setsockopt()
; 217  : 	//
; 218  : 	int		optVal;
; 219  : 
; 220  : 	if	(delboy->initialized == ANTLR3_FALSE)

  00038	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00040	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00044	85 c0		 test	 eax, eax
  00046	0f 85 5a 01 00
	00		 jne	 $LN2@handshake

; 221  : 	{
; 222  : 		// Windows requires us to initialize WinSock.
; 223  : 		//
; 224  : #ifdef ANTLR3_WINDOWS
; 225  : 		{
; 226  : 			WORD		wVersionRequested;
; 227  : 			WSADATA		wsaData;
; 228  : 			int			err;			// Return code from WSAStartup
; 229  : 
; 230  : 			// We must initialise the Windows socket system when the DLL is loaded.
; 231  : 			// We are asking for Winsock 1.1 or better as we don't need anything
; 232  : 			// too complicated for this.
; 233  : 			//
; 234  : 			wVersionRequested = MAKEWORD( 1, 1);

  0004c	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  00051	66 89 84 24 f4
	01 00 00	 mov	 WORD PTR wVersionRequested$9[rsp], ax

; 235  : 
; 236  : 			err = WSAStartup( wVersionRequested, &wsaData );

  00059	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR wsaData$10[rsp]
  00061	0f b7 8c 24 f4
	01 00 00	 movzx	 ecx, WORD PTR wVersionRequested$9[rsp]
  00069	e8 00 00 00 00	 call	 WSAStartup
  0006e	89 84 24 b4 03
	00 00		 mov	 DWORD PTR err$11[rsp], eax

; 237  : 
; 238  : 			if ( err != 0 ) 

  00075	83 bc 24 b4 03
	00 00 00	 cmp	 DWORD PTR err$11[rsp], 0
  0007d	74 07		 je	 SHORT $LN3@handshake

; 239  : 			{
; 240  : 				// Tell the user that we could not find a usable
; 241  : 				// WinSock DLL
; 242  : 				//
; 243  : 				return FALSE;

  0007f	32 c0		 xor	 al, al
  00081	e9 d1 01 00 00	 jmp	 $LN1@handshake
$LN3@handshake:

; 244  : 			}
; 245  : 		}
; 246  : #endif
; 247  : 
; 248  : 		// Create the server socket, we are the server because we just wait until
; 249  : 		// a debugger connects to the port we are listening on.
; 250  : 		//
; 251  : 		serverSocket	= socket(AF_INET, SOCK_STREAM, 0);

  00086	45 33 c0	 xor	 r8d, r8d
  00089	ba 01 00 00 00	 mov	 edx, 1
  0008e	b9 02 00 00 00	 mov	 ecx, 2
  00093	e8 00 00 00 00	 call	 socket
  00098	48 89 44 24 30	 mov	 QWORD PTR serverSocket$[rsp], rax

; 252  : 
; 253  : 		if	(serverSocket == INVALID_SOCKET)

  0009d	48 83 7c 24 30
	ff		 cmp	 QWORD PTR serverSocket$[rsp], -1
  000a3	75 07		 jne	 SHORT $LN4@handshake

; 254  : 		{
; 255  : 			return ANTLR3_FALSE;

  000a5	32 c0		 xor	 al, al
  000a7	e9 ab 01 00 00	 jmp	 $LN1@handshake
$LN4@handshake:

; 256  : 		}
; 257  : 
; 258  : 		// Set the listening port
; 259  : 		//
; 260  : 		server.sin_port			= htons((unsigned short)delboy->port);

  000ac	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  000b4	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000b7	e8 00 00 00 00	 call	 htons
  000bc	66 89 44 24 7a	 mov	 WORD PTR server$[rsp+2], ax

; 261  : 		server.sin_family		= AF_INET;

  000c1	b8 02 00 00 00	 mov	 eax, 2
  000c6	66 89 44 24 78	 mov	 WORD PTR server$[rsp], ax

; 262  : 		server.sin_addr.s_addr	= htonl (INADDR_ANY);

  000cb	33 c9		 xor	 ecx, ecx
  000cd	e8 00 00 00 00	 call	 htonl
  000d2	89 44 24 7c	 mov	 DWORD PTR server$[rsp+4], eax

; 263  : 
; 264  : 		// We could allow a rebind on the same addr/port pair I suppose, but
; 265  : 		// I imagine that most people will just want to start debugging one parser at once.
; 266  : 		// Maybe change this at some point, but rejecting the bind at this point will ensure
; 267  : 		// that people realize they have left something running in the background.
; 268  : 		//
; 269  : 		if	(bind(serverSocket, (pANTLR3_SOCKADDRC)&server, sizeof(server)) == -1)

  000d6	41 b8 10 00 00
	00		 mov	 r8d, 16
  000dc	48 8d 54 24 78	 lea	 rdx, QWORD PTR server$[rsp]
  000e1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  000e6	e8 00 00 00 00	 call	 bind
  000eb	83 f8 ff	 cmp	 eax, -1
  000ee	75 07		 jne	 SHORT $LN5@handshake

; 270  : 		{
; 271  : 			return ANTLR3_FALSE;

  000f0	32 c0		 xor	 al, al
  000f2	e9 60 01 00 00	 jmp	 $LN1@handshake
$LN5@handshake:

; 272  : 		}
; 273  : 
; 274  : 		// We have bound the socket to the port and address so we now ask the TCP subsystem
; 275  : 		// to start listening on that address/port
; 276  : 		//
; 277  : 		if	(listen(serverSocket, 1) == -1)

  000f7	ba 01 00 00 00	 mov	 edx, 1
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  00101	e8 00 00 00 00	 call	 listen
  00106	83 f8 ff	 cmp	 eax, -1
  00109	75 07		 jne	 SHORT $LN6@handshake

; 278  : 		{
; 279  : 			// Some error, just fail
; 280  : 			//
; 281  : 			return	ANTLR3_FALSE;

  0010b	32 c0		 xor	 al, al
  0010d	e9 45 01 00 00	 jmp	 $LN1@handshake
$LN6@handshake:

; 282  : 		}
; 283  : 
; 284  : 		// Now we can try to accept a connection on the port
; 285  : 		//
; 286  : 		sockaddr_len	= sizeof(client);

  00112	c7 84 24 c4 01
	00 00 10 00 00
	00		 mov	 DWORD PTR sockaddr_len$[rsp], 16

; 287  : 		delboy->socket	= accept(serverSocket, (pANTLR3_SOCKADDRC)&client, &sockaddr_len);

  0011d	4c 8d 84 24 c4
	01 00 00	 lea	 r8, QWORD PTR sockaddr_len$[rsp]
  00125	48 8d 54 24 48	 lea	 rdx, QWORD PTR client$[rsp]
  0012a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  0012f	e8 00 00 00 00	 call	 accept
  00134	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  0013c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 288  : 
; 289  : 		// Having accepted a connection, we can stop listening and close down the socket
; 290  : 		//
; 291  : 		shutdown		(serverSocket, 0x02);

  00140	ba 02 00 00 00	 mov	 edx, 2
  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  0014a	e8 00 00 00 00	 call	 shutdown

; 292  : 		ANTLR3_CLOSESOCKET		(serverSocket);

  0014f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR serverSocket$[rsp]
  00154	e8 00 00 00 00	 call	 closesocket

; 293  : 
; 294  : 		if	(delboy->socket == -1)

  00159	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00161	48 83 78 08 ff	 cmp	 QWORD PTR [rax+8], -1
  00166	75 07		 jne	 SHORT $LN7@handshake

; 295  : 		{
; 296  : 			return ANTLR3_FALSE;

  00168	32 c0		 xor	 al, al
  0016a	e9 e8 00 00 00	 jmp	 $LN1@handshake
$LN7@handshake:

; 297  : 		}
; 298  : 
; 299  : 		// Disable Nagle as this is essentially a chat exchange
; 300  : 		//
; 301  : 		optVal	= 1;

  0016f	c7 84 24 e4 01
	00 00 01 00 00
	00		 mov	 DWORD PTR optVal$[rsp], 1

; 302  : 		setsockopt(delboy->socket, SOL_SOCKET, TCP_NODELAY, (const void *)&optVal, sizeof(optVal));

  0017a	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00182	4c 8d 8c 24 e4
	01 00 00	 lea	 r9, QWORD PTR optVal$[rsp]
  0018a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00190	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00195	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  0019d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001a1	e8 00 00 00 00	 call	 setsockopt
$LN2@handshake:

; 303  : 		
; 304  : 	}
; 305  : 
; 306  : 	// We now have a good socket connection with the debugging client, so we
; 307  : 	// send it the protocol version we are using and what the name of the grammar
; 308  : 	// is that we represent.
; 309  : 	//
; 310  : 	sprintf		(message, "ANTLR %d\n", delboy->PROTOCOL_VERSION);

  001a6	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  001ae	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@
  001b9	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  001c1	e8 00 00 00 00	 call	 sprintf

; 311  : 	sockSend	(delboy->socket, message, (int)strlen(message));

  001c6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  001ce	e8 00 00 00 00	 call	 strlen
  001d3	44 8b c0	 mov	 r8d, eax
  001d6	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR message$[rsp]
  001de	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  001e6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001ea	e8 00 00 00 00	 call	 sockSend

; 312  : 	sprintf		(message, "grammar \"%s\n", delboy->grammarFileName->chars);

  001ef	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  001f7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001fb	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  001ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@
  00206	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  0020e	e8 00 00 00 00	 call	 sprintf

; 313  : 	sockSend	(delboy->socket, message, (int)strlen(message));

  00213	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR message$[rsp]
  0021b	e8 00 00 00 00	 call	 strlen
  00220	44 8b c0	 mov	 r8d, eax
  00223	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR message$[rsp]
  0022b	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00233	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00237	e8 00 00 00 00	 call	 sockSend

; 314  : 	ack			(delboy);

  0023c	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR delboy$[rsp]
  00244	e8 00 00 00 00	 call	 ack

; 315  : 
; 316  : 	delboy->initialized = ANTLR3_TRUE;

  00249	48 8b 84 24 e0
	03 00 00	 mov	 rax, QWORD PTR delboy$[rsp]
  00251	c6 40 20 01	 mov	 BYTE PTR [rax+32], 1

; 317  : 
; 318  : 	return	ANTLR3_TRUE;

  00255	b0 01		 mov	 al, 1
$LN1@handshake:

; 319  : }

  00257	48 8b f8	 mov	 rdi, rax
  0025a	48 8b cc	 mov	 rcx, rsp
  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:handshake$rtcFrameData
  00264	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00269	48 8b c7	 mov	 rax, rdi
  0026c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00274	48 33 cc	 xor	 rcx, rsp
  00277	e8 00 00 00 00	 call	 __security_check_cookie
  0027c	48 81 c4 d0 03
	00 00		 add	 rsp, 976		; 000003d0H
  00283	5f		 pop	 rdi
  00284	c3		 ret	 0
handshake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3debughandlers.c
;	COMDAT antlr3DebugListenerNew
_TEXT	SEGMENT
delboy$ = 32
antlr3DebugListenerNew PROC				; COMDAT

; 94   : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 95   : 	pANTLR3_DEBUG_EVENT_LISTENER	delboy;
; 96   : 
; 97   : 	delboy = ANTLR3_CALLOC(1, sizeof(ANTLR3_DEBUG_EVENT_LISTENER));

  00006	ba 48 01 00 00	 mov	 edx, 328		; 00000148H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00016	48 89 44 24 20	 mov	 QWORD PTR delboy$[rsp], rax

; 98   : 
; 99   : 	if	(delboy == NULL)

  0001b	48 83 7c 24 20
	00		 cmp	 QWORD PTR delboy$[rsp], 0
  00021	75 07		 jne	 SHORT $LN2@antlr3Debu

; 100  : 	{
; 101  : 		return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	e9 61 02 00 00	 jmp	 $LN1@antlr3Debu
$LN2@antlr3Debu:

; 102  : 	}
; 103  : 
; 104  : 	// Initialize the API
; 105  : 	//
; 106  : 	delboy->addChild				= addChild;

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChild
  00036	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 107  : 	delboy->becomeRoot				= becomeRoot;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:becomeRoot
  00049	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 108  : 	delboy->beginBacktrack			= beginBacktrack;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginBacktrack
  0005c	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 109  : 	delboy->beginResync				= beginResync;

  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginResync
  0006f	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 110  : 	delboy->commence				= commence;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:commence
  00082	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 111  : 	delboy->consumeHiddenToken		= consumeHiddenToken;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeHiddenToken
  00095	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 112  : 	delboy->consumeNode				= consumeNode;

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeNode
  000a8	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 113  : 	delboy->consumeToken			= consumeToken;

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeToken
  000bb	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 114  : 	delboy->createNode				= createNode;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createNode
  000cb	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 115  : 	delboy->createNodeTok			= createNodeTok;

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createNodeTok
  000de	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 116  : 	delboy->endBacktrack			= endBacktrack;

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endBacktrack
  000f1	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 117  : 	delboy->endResync				= endResync;

  000f8	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endResync
  00104	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 118  : 	delboy->enterAlt				= enterAlt;

  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterAlt
  00117	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 119  : 	delboy->enterDecision			= enterDecision;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterDecision
  00127	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 120  : 	delboy->enterRule				= enterRule;

  0012b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterRule
  00137	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 121  : 	delboy->enterSubRule			= enterSubRule;

  0013b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:enterSubRule
  00147	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 122  : 	delboy->exitDecision			= exitDecision;

  0014b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exitDecision
  00157	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 123  : 	delboy->exitRule				= exitRule;

  0015b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exitRule
  00167	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 124  : 	delboy->exitSubRule				= exitSubRule;

  0016b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exitSubRule
  00177	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 125  : 	delboy->handshake				= handshake;

  0017b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:handshake
  00187	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 126  : 	delboy->location				= location;

  0018b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:location
  00197	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 127  : 	delboy->LT						= LT;

  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LT
  001aa	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 128  : 	delboy->LTT						= LTT;

  001b1	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LTT
  001bd	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 129  : 	delboy->mark					= mark;

  001c4	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mark
  001d0	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 130  : 	delboy->nilNode					= nilNode;

  001d7	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nilNode
  001e3	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx

; 131  : 	delboy->recognitionException	= recognitionException;

  001ea	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recognitionException
  001f6	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 132  : 	delboy->rewind					= rewindMark;

  001fd	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rewindMark
  00209	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 133  : 	delboy->rewindLast				= rewindLast;

  00210	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rewindLast
  0021c	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 134  : 	delboy->semanticPredicate		= semanticPredicate;

  00223	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00228	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:semanticPredicate
  0022f	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 135  : 	delboy->setTokenBoundaries		= setTokenBoundaries;

  00236	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenBoundaries
  00242	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 136  : 	delboy->terminate				= terminate;

  00249	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:terminate
  00255	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 137  : 	delboy->errorNode				= errorNode;

  0025c	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:errorNode
  00268	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 138  : 
; 139  : 	delboy->PROTOCOL_VERSION		= 2;	// ANTLR 3.1 is at protocol version 2

  0026f	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00274	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [rax+16], 2

; 140  : 
; 141  : 	delboy->port					= DEFAULT_DEBUGGER_PORT;

  0027b	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
  00280	c7 00 cc bf 00
	00		 mov	 DWORD PTR [rax], 49100	; 0000bfccH

; 142  : 
; 143  : 	return delboy;

  00286	48 8b 44 24 20	 mov	 rax, QWORD PTR delboy$[rsp]
$LN1@antlr3Debu:

; 144  : }

  0028b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0028f	5f		 pop	 rdi
  00290	c3		 ret	 0
antlr3DebugListenerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004b	e8 00 00 00 00	 call	 _vsprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00019	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00023	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00028	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002d	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 83 c8 01	 or	 rax, 1
  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0002a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003e	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00043	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00051	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00055	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0005a	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00064	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00066	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0006a	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006e	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00072	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Format$ = 96
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 68	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00039	b9 01 00 00 00	 mov	 ecx, 1
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00044	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00049	45 33 c0	 xor	 r8d, r8d
  0004c	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Format$[rsp]
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 _vfprintf_l
  00059	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  0005d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  00066	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  0006a	8b f8		 mov	 edi, eax
  0006c	48 8b cc	 mov	 rcx, rsp
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printf$rtcFrameData
  00076	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007b	8b c7		 mov	 eax, edi
  0007d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
