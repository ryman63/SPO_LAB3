; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3BaseRecognizerNew
PUBLIC	antlr3RecognitionExceptionNew
PUBLIC	antlr3MTExceptionNew
PUBLIC	??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@ ; `string'
PUBLIC	??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@ ; `string'
PUBLIC	??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@ ; `string'
PUBLIC	??_C@_0BF@BIIJEBMB@Unexpected?5character@	; `string'
PUBLIC	??_C@_0BB@FKAIECKK@Unexpected?5token@		; `string'
PUBLIC	??_C@_0BB@DHPGECBL@?9unknown?5source?9@		; `string'
PUBLIC	??_C@_0BA@IGJLDFLP@Unexpected?5node@		; `string'
PUBLIC	??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@ ; `string'
PUBLIC	??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@ ; `string'
PUBLIC	??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@ ; `string'
PUBLIC	??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@ ; `string'
PUBLIC	??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@ ; `string'
PUBLIC	??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@	; `string'
PUBLIC	??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@	; `string'
PUBLIC	??_C@_03ECLNAHEM@?$CFs?$CI@			; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5@			; `string'
PUBLIC	??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@	; `string'
PUBLIC	??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@		; `string'
PUBLIC	??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@ ; `string'
PUBLIC	??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@ ; `string'
PUBLIC	??_C@_09NBGEJOP@?0?5near?5?$CFs@		; `string'
PUBLIC	??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@ ; `string'
PUBLIC	??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@ ; `string'
PUBLIC	??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@ ; `string'
PUBLIC	??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@ ; `string'
PUBLIC	??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@ ; `string'
PUBLIC	??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@	; `string'
PUBLIC	??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@	; `string'
PUBLIC	??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@ ; `string'
PUBLIC	??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@ ; `string'
PUBLIC	??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@ ; `string'
PUBLIC	??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@ ; `string'
PUBLIC	??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@ ; `string'
PUBLIC	??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@ ; `string'
PUBLIC	??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@ ; `string'
PUBLIC	??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@ ; `string'
PUBLIC	??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@ ; `string'
PUBLIC	??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@ ; `string'
PUBLIC	??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@ ; `string'
PUBLIC	??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@ ; `string'
PUBLIC	??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@ ; `string'
PUBLIC	??_C@_09MLMDPBIO@?$DMmissing?5@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	antlr3IntTrieNew:PROC
EXTRN	antlr3BitsetNew:PROC
EXTRN	antlr3BitsetLoad:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	antlr3StackNew:PROC
EXTRN	antlr3ExceptionNew:PROC
EXTRN	antlr3TokenFactoryNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BaseRecognizerNew DD imagerel $LN8
	DD	imagerel $LN8+1010
	DD	imagerel $unwind$antlr3BaseRecognizerNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RecognitionExceptionNew DD imagerel $LN20
	DD	imagerel $LN20+1091
	DD	imagerel $unwind$antlr3RecognitionExceptionNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3MTExceptionNew DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$antlr3MTExceptionNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginResync DD imagerel beginResync
	DD	imagerel beginResync+52
	DD	imagerel $unwind$beginResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$computeErrorRecoverySet DD imagerel computeErrorRecoverySet
	DD	imagerel computeErrorRecoverySet+34
	DD	imagerel $unwind$computeErrorRecoverySet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endResync DD imagerel endResync
	DD	imagerel endResync+52
	DD	imagerel $unwind$endResync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$beginBacktrack DD imagerel beginBacktrack
	DD	imagerel beginBacktrack+60
	DD	imagerel $unwind$beginBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$endBacktrack DD imagerel endBacktrack
	DD	imagerel endBacktrack+71
	DD	imagerel $unwind$endBacktrack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match DD	imagerel match
	DD	imagerel match+340
	DD	imagerel $unwind$match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchAny DD imagerel matchAny
	DD	imagerel matchAny+199
	DD	imagerel $unwind$matchAny
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mismatch DD imagerel mismatch
	DD	imagerel mismatch+323
	DD	imagerel $unwind$mismatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mismatchIsUnwantedToken DD imagerel mismatchIsUnwantedToken
	DD	imagerel mismatchIsUnwantedToken+102
	DD	imagerel $unwind$mismatchIsUnwantedToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mismatchIsMissingToken DD imagerel mismatchIsMissingToken
	DD	imagerel mismatchIsMissingToken+317
	DD	imagerel $unwind$mismatchIsMissingToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reportError DD imagerel reportError
	DD	imagerel reportError+160
	DD	imagerel $unwind$reportError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$computeCSRuleFollow DD imagerel computeCSRuleFollow
	DD	imagerel computeCSRuleFollow+34
	DD	imagerel $unwind$computeCSRuleFollow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$combineFollows DD imagerel combineFollows
	DD	imagerel combineFollows+320
	DD	imagerel $unwind$combineFollows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$displayRecognitionError DD imagerel displayRecognitionError
	DD	imagerel displayRecognitionError+2004
	DD	imagerel $unwind$displayRecognitionError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recover DD imagerel recover
	DD	imagerel recover+346
	DD	imagerel $unwind$recover
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recoverFromMismatchedToken DD imagerel recoverFromMismatchedToken
	DD	imagerel recoverFromMismatchedToken+685
	DD	imagerel $unwind$recoverFromMismatchedToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recoverFromMismatchedSet DD imagerel recoverFromMismatchedSet
	DD	imagerel recoverFromMismatchedSet+353
	DD	imagerel $unwind$recoverFromMismatchedSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recoverFromMismatchedElement DD imagerel recoverFromMismatchedElement
	DD	imagerel recoverFromMismatchedElement+405
	DD	imagerel $unwind$recoverFromMismatchedElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeUntil DD imagerel consumeUntil
	DD	imagerel consumeUntil+240
	DD	imagerel $unwind$consumeUntil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$consumeUntilSet DD imagerel consumeUntilSet
	DD	imagerel consumeUntilSet+255
	DD	imagerel $unwind$consumeUntilSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRuleInvocationStack DD imagerel getRuleInvocationStack
	DD	imagerel getRuleInvocationStack+10
	DD	imagerel $unwind$getRuleInvocationStack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRuleInvocationStackNamed DD imagerel getRuleInvocationStackNamed
	DD	imagerel getRuleInvocationStackNamed+15
	DD	imagerel $unwind$getRuleInvocationStackNamed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toStrings DD imagerel toStrings
	DD	imagerel toStrings+15
	DD	imagerel $unwind$toStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRuleMemoization DD imagerel getRuleMemoization
	DD	imagerel getRuleMemoization+279
	DD	imagerel $unwind$getRuleMemoization
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$alreadyParsedRule DD imagerel alreadyParsedRule
	DD	imagerel alreadyParsedRule+363
	DD	imagerel $unwind$alreadyParsedRule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memoize DD imagerel memoize
	DD	imagerel memoize+445
	DD	imagerel $unwind$memoize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$synpred DD imagerel synpred
	DD	imagerel synpred+324
	DD	imagerel $unwind$synpred
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset DD	imagerel reset
	DD	imagerel reset+276
	DD	imagerel $unwind$reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeBR DD imagerel freeBR
	DD	imagerel freeBR+297
	DD	imagerel $unwind$freeBR
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCurrentInputSymbol DD imagerel getCurrentInputSymbol
	DD	imagerel getCurrentInputSymbol+47
	DD	imagerel $unwind$getCurrentInputSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getMissingSymbol DD imagerel getMissingSymbol
	DD	imagerel getMissingSymbol+514
	DD	imagerel $unwind$getMissingSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getNumberOfSyntaxErrors DD imagerel getNumberOfSyntaxErrors
	DD	imagerel getNumberOfSyntaxErrors+20
	DD	imagerel $unwind$getNumberOfSyntaxErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeIntTrie DD imagerel freeIntTrie
	DD	imagerel freeIntTrie+29
	DD	imagerel $unwind$freeIntTrie
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLMDPBIO@?$DMmissing?5@
CONST	SEGMENT
??_C@_09MLMDPBIO@?$DMmissing?5@ DB '<missing ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@
CONST	SEGMENT
??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@ DB 'Base recogniz'
	DB	'er function ''synPred'' called by unknown parser type - provi'
	DB	'de override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@
CONST	SEGMENT
??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@ DB 'Base recognize'
	DB	'r function consumeUntilSet called by unknown parser type - pr'
	DB	'ovide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@
CONST	SEGMENT
??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@ DB 'Base recogniz'
	DB	'er function ''alreadyParsedRule'' called by unknown parser ty'
	DB	'pe - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@
CONST	SEGMENT
??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@ DB 'Base recogniz'
	DB	'er function ''consumeUntilSet'' called by unknown parser type'
	DB	' - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@
CONST	SEGMENT
??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@ DB 'Base recogniz'
	DB	'er function ''consumeUntil'' called by unknown parser type - '
	DB	'provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@
CONST	SEGMENT
??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@ DB 'Base recognize'
	DB	'r function recoverFromMismatchedSet called by unknown parser '
	DB	'type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@
CONST	SEGMENT
??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@ DB 'Base recognize'
	DB	'r function recoverFromMismatchedToken called by unknown parse'
	DB	'r type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@
CONST	SEGMENT
??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@ DB 'Base recognize'
	DB	'r function recover called by unknown parser type - provide ov'
	DB	'erride for this function', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@
CONST	SEGMENT
??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@ DB ' : syntax n'
	DB	'ot recognized...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@
CONST	SEGMENT
??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@ DB ' : missing elemen'
	DB	'ts...', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@
CONST	SEGMENT
??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@ DB 'I could no'
	DB	't work out what I was expecting, like so many of us these day'
	DB	's!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@
CONST	SEGMENT
??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@ DB 'Actually d'
	DB	'ude, we didn''t seem to be expecting anything here, or at lea'
	DB	'st', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@
CONST	SEGMENT
??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@ DB ' : unex'
	DB	'pected input...', 0aH, '  expected one of : ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@
CONST	SEGMENT
??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@ DB ' : cannot '
	DB	'match to any predicted input...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@ DB ' : expected %s ..'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@
CONST	SEGMENT
??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@ DB ' : expected <EOF>', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@
CONST	SEGMENT
??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@ DB ' : syntax error...', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@
CONST	SEGMENT
??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@ DB ' : Missing %s ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@
CONST	SEGMENT
??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@ DB ' : Missing <EOF>', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@
CONST	SEGMENT
??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@ DB ' : Mi'
	DB	'ssing token (%d)...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@
CONST	SEGMENT
??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@ DB ' : Extran'
	DB	'eous input - expected %s ...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@
CONST	SEGMENT
??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@ DB ' : Extran'
	DB	'eous input - expected <EOF>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@
CONST	SEGMENT
??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@ DB ' : Extraneous input'
	DB	'...', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@
CONST	SEGMENT
??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@ DB 'Base recognize'
	DB	'r function displayRecognitionError called by unknown parser t'
	DB	'ype - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBGEJOP@?0?5near?5?$CFs@
CONST	SEGMENT
??_C@_09NBGEJOP@?0?5near?5?$CFs@ DB ', near %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@
CONST	SEGMENT
??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@ DB 0aH, '    near %s', 0aH
	DB	'    ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@
CONST	SEGMENT
??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@ DB '<no text for th'
	DB	'e token>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@
CONST	SEGMENT
??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@ DB ', at <EOF>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@
CONST	SEGMENT
??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@ DB ', at offset %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@ DB ' : error %d : %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5@ DB '%d) ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECLNAHEM@?$CFs?$CI@
CONST	SEGMENT
??_C@_03ECLNAHEM@?$CFs?$CI@ DB '%s(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
CONST	SEGMENT
??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@ DB '-unknown source-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@
CONST	SEGMENT
??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@ DB '-end of input-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@
CONST	SEGMENT
??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@ DB 'org.antlr.runt'
	DB	'ime.MissingTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@
CONST	SEGMENT
??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@ DB 'org.antlr.runt'
	DB	'ime.UnwantedTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@
CONST	SEGMENT
??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@ DB 'Base recognize'
	DB	'r function ''mismatch'' called by unknown parser type - provi'
	DB	'de override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@
CONST	SEGMENT
??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@ DB 'Base recogniz'
	DB	'er function ''matchAny'' called by unknown parser type - prov'
	DB	'ide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@
CONST	SEGMENT
??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@ DB 'Base recogniz'
	DB	'er function ''match'' called by unknown parser type - provide'
	DB	' override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGJLDFLP@Unexpected?5node@
CONST	SEGMENT
??_C@_0BA@IGJLDFLP@Unexpected?5node@ DB 'Unexpected node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHPGECBL@?9unknown?5source?9@
CONST	SEGMENT
??_C@_0BB@DHPGECBL@?9unknown?5source?9@ DB '-unknown source-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKAIECKK@Unexpected?5token@
CONST	SEGMENT
??_C@_0BB@FKAIECKK@Unexpected?5token@ DB 'Unexpected token', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BIIJEBMB@Unexpected?5character@
CONST	SEGMENT
??_C@_0BF@BIIJEBMB@Unexpected?5character@ DB 'Unexpected character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@
CONST	SEGMENT
??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@ DB 'org.antlr.runt'
	DB	'ime.RecognitionException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@
CONST	SEGMENT
??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@ DB 'Base recognize'
	DB	'r function antlr3RecognitionExceptionNew called by unknown pa'
	DB	'rser type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@
CONST	SEGMENT
??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@ DB 'org.antlr.runt'
	DB	'ime.MismatchedTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeIntTrie DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getNumberOfSyntaxErrors DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getMissingSymbol DD 021901H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCurrentInputSymbol DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeBR DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$synpred DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memoize DD 021701H
	DD	07010f217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alreadyParsedRule DD 020f01H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRuleMemoization DD 021401H
	DD	07010b214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toStrings DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRuleInvocationStackNamed DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRuleInvocationStack DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeUntilSet DD 020f01H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$consumeUntil DD 020e01H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recoverFromMismatchedElement DD 020f01H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recoverFromMismatchedSet DD 020f01H
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recoverFromMismatchedToken DD 021301H
	DD	0700fb213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recover DD 020a01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$displayRecognitionError DD 031201H
	DD	01c0112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combineFollows DD 020e01H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$computeCSRuleFollow DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reportError DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mismatchIsMissingToken DD 021401H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mismatchIsUnwantedToken DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mismatch DD 021301H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchAny DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match DD 021301H
	DD	0700f9213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endBacktrack DD 021301H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginBacktrack DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$endResync DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$computeErrorRecoverySet DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$beginResync DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3MTExceptionNew DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RecognitionExceptionNew DD 020d01H
	DD	07006f20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BaseRecognizerNew DD 021201H
	DD	0700e5212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT freeIntTrie
_TEXT	SEGMENT
trie$ = 48
freeIntTrie PROC					; COMDAT

; 1839 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1840 :     ((pANTLR3_INT_TRIE)trie)->free((pANTLR3_INT_TRIE)trie);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR trie$[rsp]
  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR trie$[rsp]
  00014	ff 50 30	 call	 QWORD PTR [rax+48]

; 1841 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
freeIntTrie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getNumberOfSyntaxErrors
_TEXT	SEGMENT
recognizer$ = 16
getNumberOfSyntaxErrors PROC				; COMDAT

; 1311 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1312 : 	return	recognizer->state->errorCount;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0000f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]

; 1313 : }

  00012	5f		 pop	 rdi
  00013	c3		 ret	 0
getNumberOfSyntaxErrors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getMissingSymbol
_TEXT	SEGMENT
ts$ = 32
cts$ = 40
token$ = 48
current$ = 56
text$ = 64
tv173 = 72
recognizer$ = 96
istream$ = 104
e$ = 112
expectedTokenType$ = 120
follow$ = 128
getMissingSymbol PROC					; COMDAT

; 2167 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2168 : 	pANTLR3_TOKEN_STREAM			ts;
; 2169 : 	pANTLR3_COMMON_TOKEN_STREAM		cts;
; 2170 : 	pANTLR3_COMMON_TOKEN			token;
; 2171 : 	pANTLR3_COMMON_TOKEN			current;
; 2172 : 	pANTLR3_STRING					text;
; 2173 : 
; 2174 : 	// Dereference the standard pointers
; 2175 : 	//
; 2176 : 	ts		= (pANTLR3_TOKEN_STREAM)istream->super;

  00019	48 8b 44 24 68	 mov	 rax, QWORD PTR istream$[rsp]
  0001e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00022	48 89 44 24 20	 mov	 QWORD PTR ts$[rsp], rax

; 2177 : 	cts		= (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  0002c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00030	48 89 44 24 28	 mov	 QWORD PTR cts$[rsp], rax

; 2178 : 	
; 2179 : 	// Work out what to use as the current symbol to make a line and offset etc
; 2180 : 	// If we are at EOF, we use the token before EOF
; 2181 : 	//
; 2182 : 	current	= ts->_LT(ts, 1);

  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00044	ff 50 28	 call	 QWORD PTR [rax+40]
  00047	48 89 44 24 38	 mov	 QWORD PTR current$[rsp], rax

; 2183 : 	if	(current->getType(current) == ANTLR3_TOKEN_EOF)

  0004c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00051	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  00056	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0005c	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  0005f	75 17		 jne	 SHORT $LN2@getMissing

; 2184 : 	{
; 2185 : 		current = ts->_LT(ts, -1);

  00061	ba ff ff ff ff	 mov	 edx, -1
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  00070	ff 50 28	 call	 QWORD PTR [rax+40]
  00073	48 89 44 24 38	 mov	 QWORD PTR current$[rsp], rax
$LN2@getMissing:

; 2186 : 	}
; 2187 : 
; 2188 : 	// Create a new empty token
; 2189 : 	//
; 2190 : 	if	(recognizer->state->tokFactory == NULL)

  00078	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0007d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00081	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00086	75 1b		 jne	 SHORT $LN3@getMissing

; 2191 : 	{
; 2192 : 		// We don't yet have a token factory for making tokens
; 2193 : 		// we just need a fake one using the input stream of the current
; 2194 : 		// token.
; 2195 : 		//
; 2196 : 		recognizer->state->tokFactory = antlr3TokenFactoryNew(current->input);

  00088	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  0008d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00091	e8 00 00 00 00	 call	 antlr3TokenFactoryNew
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0009b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0009f	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN3@getMissing:

; 2197 : 	}
; 2198 : 	token	= recognizer->state->tokFactory->newToken(recognizer->state->tokFactory);

  000a3	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000b1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b5	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000b9	48 89 4c 24 48	 mov	 QWORD PTR tv173[rsp], rcx
  000be	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR tv173[rsp]
  000c7	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  000cd	48 89 44 24 30	 mov	 QWORD PTR token$[rsp], rax

; 2199 : 
; 2200 : 	// Set some of the token properties based on the current token
; 2201 : 	//
; 2202 : 	token->setLine					(token, current->getLine(current));

  000d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  000dc	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  000e2	8b d0		 mov	 edx, eax
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  000ee	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]

; 2203 : 	token->setCharPositionInLine	(token, current->getCharPositionInLine(current));

  000f4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  000f9	48 8b 44 24 38	 mov	 rax, QWORD PTR current$[rsp]
  000fe	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00104	8b d0		 mov	 edx, eax
  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00110	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 2204 : 	token->setChannel				(token, ANTLR3_TOKEN_DEFAULT_CHANNEL);

  00116	33 d2		 xor	 edx, edx
  00118	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  0011d	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00122	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 2205 : 	token->setType					(token, expectedTokenType);

  00128	8b 54 24 78	 mov	 edx, DWORD PTR expectedTokenType$[rsp]
  0012c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  00131	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00136	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 2206 :     token->user1                    = current->user1;

  0013c	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00141	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00146	8b 49 58	 mov	 ecx, DWORD PTR [rcx+88]
  00149	89 48 58	 mov	 DWORD PTR [rax+88], ecx

; 2207 :     token->user2                    = current->user2;

  0014c	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00151	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00156	8b 49 5c	 mov	 ecx, DWORD PTR [rcx+92]
  00159	89 48 5c	 mov	 DWORD PTR [rax+92], ecx

; 2208 :     token->user3                    = current->user3;

  0015c	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00161	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00166	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  00169	89 48 60	 mov	 DWORD PTR [rax+96], ecx

; 2209 :     token->custom                   = current->custom;

  0016c	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00171	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00176	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0017a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2210 :     token->lineStart                = current->lineStart;

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  00183	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current$[rsp]
  00188	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0018c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2211 :     
; 2212 : 	// Create the token text that shows it has been inserted
; 2213 : 	//
; 2214 : 	token->setText8(token, (pANTLR3_UINT8)"<missing ");

  00190	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MLMDPBIO@?$DMmissing?5@
  00197	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  0019c	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  001a1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2215 : 	text = token->getText(token);

  001a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR token$[rsp]
  001ac	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]
  001b1	ff 50 78	 call	 QWORD PTR [rax+120]
  001b4	48 89 44 24 40	 mov	 QWORD PTR text$[rsp], rax

; 2216 : 
; 2217 : 	if	(text != NULL)

  001b9	48 83 7c 24 40
	00		 cmp	 QWORD PTR text$[rsp], 0
  001bf	74 36		 je	 SHORT $LN4@getMissing

; 2218 : 	{
; 2219 : 		text->append8(text, (const char *)recognizer->state->tokenNames[expectedTokenType]);

  001c1	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  001c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001ca	8b 4c 24 78	 mov	 ecx, DWORD PTR expectedTokenType$[rsp]
  001ce	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  001d2	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  001d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR text$[rsp]
  001db	48 8b 44 24 40	 mov	 rax, QWORD PTR text$[rsp]
  001e0	ff 50 38	 call	 QWORD PTR [rax+56]

; 2220 : 		text->append8(text, (const char *)">");

  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PPODPGHN@?$DO@
  001ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR text$[rsp]
  001ef	48 8b 44 24 40	 mov	 rax, QWORD PTR text$[rsp]
  001f4	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@getMissing:

; 2221 : 	}
; 2222 : 	
; 2223 : 	// Finally return the pointer to our new token
; 2224 : 	//
; 2225 : 	return	token;

  001f7	48 8b 44 24 30	 mov	 rax, QWORD PTR token$[rsp]

; 2226 : }

  001fc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00200	5f		 pop	 rdi
  00201	c3		 ret	 0
getMissingSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getCurrentInputSymbol
_TEXT	SEGMENT
recognizer$ = 48
istream$ = 56
getCurrentInputSymbol PROC				; COMDAT

; 2157 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2158 : 	return ((pANTLR3_TOKEN_STREAM)istream->super)->_LT((pANTLR3_TOKEN_STREAM)istream->super, 1);

  0000f	48 8b 44 24 38	 mov	 rax, QWORD PTR istream$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	ba 01 00 00 00	 mov	 edx, 1
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR istream$[rsp]
  00022	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00026	ff 50 28	 call	 QWORD PTR [rax+40]

; 2159 : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
getCurrentInputSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT freeBR
_TEXT	SEGMENT
thisE$ = 32
tv145 = 40
tv139 = 48
tv135 = 56
recognizer$ = 80
freeBR	PROC						; COMDAT

; 199  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 200  :     pANTLR3_EXCEPTION thisE;
; 201  : 
; 202  : 	// Did we have a state allocated?
; 203  : 	//
; 204  : 	if	(recognizer->state != NULL)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00014	0f 84 fe 00 00
	00		 je	 $LN2@freeBR

; 205  : 	{
; 206  : 		// Free any rule memoization we set up
; 207  : 		//
; 208  : 		if	(recognizer->state->ruleMemo != NULL)

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00028	74 38		 je	 SHORT $LN3@freeBR

; 209  : 		{
; 210  : 			recognizer->state->ruleMemo->free(recognizer->state->ruleMemo);

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00038	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003c	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00040	48 89 4c 24 28	 mov	 QWORD PTR tv145[rsp], rcx
  00045	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR tv145[rsp]
  0004e	ff 50 30	 call	 QWORD PTR [rax+48]

; 211  : 			recognizer->state->ruleMemo = NULL;

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00056	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005a	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN3@freeBR:

; 212  : 		}
; 213  : 
; 214  : 		// Free any exception space we have left around
; 215  : 		//
; 216  : 		thisE = recognizer->state->exception;

  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00067	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006f	48 89 44 24 20	 mov	 QWORD PTR thisE$[rsp], rax

; 217  : 		if	(thisE != NULL)

  00074	48 83 7c 24 20
	00		 cmp	 QWORD PTR thisE$[rsp], 0
  0007a	74 10		 je	 SHORT $LN4@freeBR

; 218  : 		{
; 219  : 			thisE->freeEx(thisE);

  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thisE$[rsp]
  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR thisE$[rsp]
  00086	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN4@freeBR:

; 220  : 		}
; 221  : 
; 222  : 		// Free any rewrite streams we have allocated
; 223  : 		//
; 224  : 		if	(recognizer->state->rStreams != NULL)

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00091	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00095	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  0009d	74 30		 je	 SHORT $LN5@freeBR

; 225  : 		{
; 226  : 			recognizer->state->rStreams->free(recognizer->state->rStreams);

  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000ad	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b1	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  000b8	48 89 4c 24 30	 mov	 QWORD PTR tv139[rsp], rcx
  000bd	48 8b 88 b0 00
	00 00		 mov	 rcx, QWORD PTR [rax+176]
  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR tv139[rsp]
  000c9	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]
$LN5@freeBR:

; 227  : 		}
; 228  : 
; 229  : 		// Free up any token factory we created (error recovery for instance)
; 230  : 		//
; 231  : 		if	(recognizer->state->tokFactory != NULL)

  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000dd	74 2a		 je	 SHORT $LN6@freeBR

; 232  : 		{
; 233  : 			recognizer->state->tokFactory->close(recognizer->state->tokFactory);

  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000ed	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000f1	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000f5	48 89 4c 24 38	 mov	 QWORD PTR tv135[rsp], rcx
  000fa	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR tv135[rsp]
  00103	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]
$LN6@freeBR:

; 234  : 		}
; 235  : 		// Free the shared state memory
; 236  : 		//
; 237  : 		ANTLR3_FREE(recognizer->state);

  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010e	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@freeBR:

; 238  : 	}
; 239  : 
; 240  : 	// Free the actual recognizer space
; 241  : 	//
; 242  :     ANTLR3_FREE(recognizer);

  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 243  : }

  00123	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00127	5f		 pop	 rdi
  00128	c3		 ret	 0
freeBR	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT reset
_TEXT	SEGMENT
tv148 = 32
tv138 = 40
recognizer$ = 64
reset	PROC						; COMDAT

; 2121 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2122 :     if	(recognizer->state->following != NULL)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00018	74 27		 je	 SHORT $LN2@reset

; 2123 :     {
; 2124 : 		recognizer->state->following->free(recognizer->state->following);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00028	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00030	48 89 4c 24 20	 mov	 QWORD PTR tv148[rsp], rcx
  00035	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR tv148[rsp]
  0003e	ff 50 10	 call	 QWORD PTR [rax+16]
$LN2@reset:

; 2125 :     }
; 2126 : 
; 2127 : 	// Reset the state flags
; 2128 : 	//
; 2129 : 	recognizer->state->errorRecovery	= ANTLR3_FALSE;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 2130 : 	recognizer->state->lastErrorIndex	= -1;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00053	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00057	48 c7 40 28 ff
	ff ff ff	 mov	 QWORD PTR [rax+40], -1

; 2131 : 	recognizer->state->failed			= ANTLR3_FALSE;

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00064	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00068	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 2132 : 	recognizer->state->errorCount		= 0;

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00071	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00075	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 2133 : 	recognizer->state->backtracking		= 0;

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00081	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00085	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 2134 : 	recognizer->state->following		= NULL;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00091	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00095	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2135 : 
; 2136 : 	if	(recognizer->state != NULL)

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a2	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000a7	74 4e		 je	 SHORT $LN3@reset

; 2137 : 	{
; 2138 : 		if	(recognizer->state->ruleMemo != NULL)

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ae	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b2	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000b7	74 3e		 je	 SHORT $LN4@reset

; 2139 : 		{
; 2140 : 			recognizer->state->ruleMemo->free(recognizer->state->ruleMemo);

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  000be	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000c7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000cb	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000cf	48 89 4c 24 28	 mov	 QWORD PTR tv138[rsp], rcx
  000d4	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR tv138[rsp]
  000dd	ff 50 30	 call	 QWORD PTR [rax+48]

; 2141 : 			recognizer->state->ruleMemo = antlr3IntTrieNew(15);	/* 16 bit depth is enough for 32768 rules! */

  000e0	b9 0f 00 00 00	 mov	 ecx, 15
  000e5	e8 00 00 00 00	 call	 antlr3IntTrieNew
  000ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000ef	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000f3	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax
$LN4@reset:
$LN3@reset:

; 2142 : 		}
; 2143 : 	}
; 2144 : 	
; 2145 : 
; 2146 :     // Install a new following set
; 2147 :     //
; 2148 :     recognizer->state->following   = antlr3StackNew(8);

  000f7	b9 08 00 00 00	 mov	 ecx, 8
  000fc	e8 00 00 00 00	 call	 antlr3StackNew
  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00106	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0010a	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2149 : 
; 2150 : }

  0010e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT synpred
_TEXT	SEGMENT
start$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
recognizer$ = 96
ctx$ = 104
predicate$ = 112
synpred	PROC						; COMDAT

; 2056 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2057 :     ANTLR3_MARKER   start;
; 2058 :     pANTLR3_PARSER	    parser;
; 2059 :     pANTLR3_TREE_PARSER	    tparser;
; 2060 :     pANTLR3_INT_STREAM	    is;
; 2061 : 
; 2062 :     switch	(recognizer->type)

  00014	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00019	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001c	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  00020	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00025	74 09		 je	 SHORT $LN4@synpred
  00027	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  0002c	74 2c		 je	 SHORT $LN5@synpred
  0002e	eb 58		 jmp	 SHORT $LN6@synpred
$LN4@synpred:

; 2063 :     {
; 2064 : 		case	ANTLR3_TYPE_PARSER:
; 2065 : 
; 2066 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 2067 : 			tparser	= NULL;

  0003d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 2068 : 			is	= parser->tstream->istream;

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  0004b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00053	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 2069 : 
; 2070 : 			break;

  00058	eb 4f		 jmp	 SHORT $LN2@synpred
$LN5@synpred:

; 2071 : 
; 2072 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 2073 : 
; 2074 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00062	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 2075 : 			parser	= NULL;

  00067	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 2076 : 			is	= tparser->ctnstream->tnstream->istream;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00079	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00081	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 2077 : 
; 2078 : 			break;

  00086	eb 21		 jmp	 SHORT $LN2@synpred
$LN6@synpred:

; 2079 : 
; 2080 : 		default:
; 2081 : 		    
; 2082 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'synPred' called by unknown parser type - provide override for this function\n");

  00088	b9 02 00 00 00	 mov	 ecx, 2
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 fprintf

; 2083 : 			return ANTLR3_FALSE;

  000a2	32 c0		 xor	 al, al
  000a4	e9 95 00 00 00	 jmp	 $LN1@synpred
$LN2@synpred:

; 2084 : 
; 2085 : 			break;
; 2086 :     }
; 2087 : 
; 2088 :     /* Begin backtracking so we can get back to where we started after trying out
; 2089 :      * the syntactic predicate.
; 2090 :      */
; 2091 :     start   = is->mark(is);

  000a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000b3	ff 50 38	 call	 QWORD PTR [rax+56]
  000b6	48 89 44 24 20	 mov	 QWORD PTR start$[rsp], rax

; 2092 :     recognizer->state->backtracking++;

  000bb	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c4	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  000c7	ff c0		 inc	 eax
  000c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000ce	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000d2	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 2093 : 
; 2094 :     /* Try the syntactical predicate
; 2095 :      */
; 2096 :     predicate(ctx);

  000d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ctx$[rsp]
  000da	ff 54 24 70	 call	 QWORD PTR predicate$[rsp]

; 2097 : 
; 2098 :     /* Reset
; 2099 :      */
; 2100 :     is->rewind(is, start);

  000de	48 8b 54 24 20	 mov	 rdx, QWORD PTR start$[rsp]
  000e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000e8	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000ed	ff 50 48	 call	 QWORD PTR [rax+72]

; 2101 :     recognizer->state->backtracking--;

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000f5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f9	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  000fc	ff c8		 dec	 eax
  000fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00103	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00107	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 2102 : 
; 2103 :     if	(recognizer->state->failed == ANTLR3_TRUE)

  0010a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00113	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  00117	83 f8 01	 cmp	 eax, 1
  0011a	75 13		 jne	 SHORT $LN7@synpred

; 2104 :     {
; 2105 : 		/* Predicate failed
; 2106 : 		 */
; 2107 : 		recognizer->state->failed = ANTLR3_FALSE;

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00121	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00125	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 2108 : 		return	ANTLR3_FALSE;

  00129	32 c0		 xor	 al, al
  0012b	eb 11		 jmp	 SHORT $LN1@synpred

; 2109 :     }

  0012d	eb 0f		 jmp	 SHORT $LN8@synpred
$LN7@synpred:

; 2110 :     else
; 2111 :     {
; 2112 : 		/* Predicate was successful
; 2113 : 		 */
; 2114 : 		recognizer->state->failed	= ANTLR3_FALSE;

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00134	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00138	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 2115 : 		return	ANTLR3_TRUE;

  0013c	b0 01		 mov	 al, 1
$LN8@synpred:
$LN1@synpred:

; 2116 :     }
; 2117 : }

  0013e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00142	5f		 pop	 rdi
  00143	c3		 ret	 0
synpred	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT memoize
_TEXT	SEGMENT
ruleList$ = 48
entry$ = 56
stopIndex$ = 64
lexer$ = 72
parser$ = 80
tparser$ = 88
is$ = 96
tv65 = 104
tv91 = 112
tv135 = 120
recognizer$ = 144
ruleIndex$ = 152
ruleParseStart$ = 160
memoize	PROC						; COMDAT

; 1990 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1991 :     /* The rule memos are an ANTLR3_LIST of ANTLR3_LIST.
; 1992 :      */
; 1993 :     pANTLR3_INT_TRIE	    ruleList;
; 1994 :     pANTLR3_TRIE_ENTRY	    entry;
; 1995 :     ANTLR3_MARKER	    stopIndex;
; 1996 :     pANTLR3_LEXER	    lexer;
; 1997 :     pANTLR3_PARSER	    parser;
; 1998 :     pANTLR3_TREE_PARSER	    tparser;
; 1999 :     pANTLR3_INT_STREAM	    is;
; 2000 : 
; 2001 :     switch	(recognizer->type)

  00017	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00022	89 44 24 68	 mov	 DWORD PTR tv65[rsp], eax
  00026	83 7c 24 68 01	 cmp	 DWORD PTR tv65[rsp], 1
  0002b	74 74		 je	 SHORT $LN6@memoize
  0002d	83 7c 24 68 02	 cmp	 DWORD PTR tv65[rsp], 2
  00032	74 0c		 je	 SHORT $LN4@memoize
  00034	83 7c 24 68 04	 cmp	 DWORD PTR tv65[rsp], 4
  00039	74 35		 je	 SHORT $LN5@memoize
  0003b	e9 96 00 00 00	 jmp	 $LN7@memoize
$LN4@memoize:

; 2002 :     {
; 2003 : 		case	ANTLR3_TYPE_PARSER:
; 2004 : 
; 2005 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00040	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 44 24 50	 mov	 QWORD PTR parser$[rsp], rax

; 2006 : 			tparser	= NULL;

  00050	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 2007 : 			is	= parser->tstream->istream;

  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR parser$[rsp]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00066	48 89 44 24 60	 mov	 QWORD PTR is$[rsp], rax

; 2008 : 
; 2009 : 			break;

  0006b	e9 85 00 00 00	 jmp	 $LN2@memoize
$LN5@memoize:

; 2010 : 
; 2011 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 2012 : 
; 2013 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00070	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00078	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007b	48 89 44 24 58	 mov	 QWORD PTR tparser$[rsp], rax

; 2014 : 			parser	= NULL;

  00080	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 2015 : 			is	= tparser->ctnstream->tnstream->istream;

  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR tparser$[rsp]
  0008e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00092	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00096	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009a	48 89 44 24 60	 mov	 QWORD PTR is$[rsp], rax

; 2016 : 
; 2017 : 			break;

  0009f	eb 54		 jmp	 SHORT $LN2@memoize
$LN6@memoize:

; 2018 : 
; 2019 : 		case	ANTLR3_TYPE_LEXER:
; 2020 : 
; 2021 : 			lexer	= (pANTLR3_LEXER)   (recognizer->super);

  000a1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	48 89 44 24 48	 mov	 QWORD PTR lexer$[rsp], rax

; 2022 : 			parser	= NULL;

  000b1	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 2023 : 			tparser	= NULL;

  000ba	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 2024 : 			is		= lexer->input->istream;

  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR lexer$[rsp]
  000c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cf	48 89 44 24 60	 mov	 QWORD PTR is$[rsp], rax

; 2025 : 			break;

  000d4	eb 1f		 jmp	 SHORT $LN2@memoize
$LN7@memoize:

; 2026 : 
; 2027 : 		default:
; 2028 : 		    
; 2029 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function consumeUntilSet called by unknown parser type - provide override for this function\n");

  000d6	b9 02 00 00 00	 mov	 ecx, 2
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@
  000e8	48 8b c8	 mov	 rcx, rax
  000eb	e8 00 00 00 00	 call	 fprintf

; 2030 : 			return;

  000f0	e9 bf 00 00 00	 jmp	 $LN1@memoize
$LN2@memoize:

; 2031 : 
; 2032 : 			break;
; 2033 :     }
; 2034 :     
; 2035 :     stopIndex	= recognizer->state->failed == ANTLR3_TRUE ? MEMO_RULE_FAILED : is->index(is) - 1;

  000f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000fd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00101	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  00105	83 f8 01	 cmp	 eax, 1
  00108	75 0c		 jne	 SHORT $LN10@memoize
  0010a	b8 fe ff ff ff	 mov	 eax, -2
  0010f	48 89 44 24 70	 mov	 QWORD PTR tv91[rsp], rax
  00114	eb 15		 jmp	 SHORT $LN11@memoize
$LN10@memoize:
  00116	48 8b 4c 24 60	 mov	 rcx, QWORD PTR is$[rsp]
  0011b	48 8b 44 24 60	 mov	 rax, QWORD PTR is$[rsp]
  00120	ff 50 40	 call	 QWORD PTR [rax+64]
  00123	48 ff c8	 dec	 rax
  00126	48 89 44 24 70	 mov	 QWORD PTR tv91[rsp], rax
$LN11@memoize:
  0012b	48 8b 44 24 70	 mov	 rax, QWORD PTR tv91[rsp]
  00130	48 89 44 24 40	 mov	 QWORD PTR stopIndex$[rsp], rax

; 2036 : 
; 2037 :     entry	= recognizer->state->ruleMemo->get(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex);

  00135	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0013d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00141	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00149	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0014d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00151	48 89 4c 24 78	 mov	 QWORD PTR tv135[rsp], rcx
  00156	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  0015e	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00162	48 8b 44 24 78	 mov	 rax, QWORD PTR tv135[rsp]
  00167	ff 50 18	 call	 QWORD PTR [rax+24]
  0016a	48 89 44 24 38	 mov	 QWORD PTR entry$[rsp], rax

; 2038 : 
; 2039 :     if	(entry != NULL)

  0016f	48 83 7c 24 38
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00175	74 3d		 je	 SHORT $LN8@memoize

; 2040 :     {
; 2041 : 		ruleList = (pANTLR3_INT_TRIE)(entry->data.ptr);

  00177	48 8b 44 24 38	 mov	 rax, QWORD PTR entry$[rsp]
  0017c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00180	48 89 44 24 30	 mov	 QWORD PTR ruleList$[rsp], rax

; 2042 : 
; 2043 : 		/* If we don't already have this entry, append it. The memoize trie does not
; 2044 : 		 * accept duplicates so it won't add it if already there and we just ignore the
; 2045 : 		 * return code as we don't care if it is there already.
; 2046 : 		 */
; 2047 : 		ruleList->add(ruleList, ruleParseStart, ANTLR3_HASH_TYPE_INT, stopIndex, NULL, NULL);

  00185	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0018e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00197	4c 8b 4c 24 40	 mov	 r9, QWORD PTR stopIndex$[rsp]
  0019c	45 33 c0	 xor	 r8d, r8d
  0019f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ruleParseStart$[rsp]
  001a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ruleList$[rsp]
  001ac	48 8b 44 24 30	 mov	 rax, QWORD PTR ruleList$[rsp]
  001b1	ff 50 28	 call	 QWORD PTR [rax+40]
$LN8@memoize:
$LN1@memoize:

; 2048 :     }
; 2049 : }

  001b4	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001bb	5f		 pop	 rdi
  001bc	c3		 ret	 0
memoize	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT alreadyParsedRule
_TEXT	SEGMENT
stopIndex$ = 32
lexer$ = 40
parser$ = 48
tparser$ = 56
is$ = 64
tv65 = 72
recognizer$ = 96
ruleIndex$ = 104
alreadyParsedRule PROC					; COMDAT

; 1919 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1920 :     ANTLR3_MARKER			stopIndex;
; 1921 :     pANTLR3_LEXER			lexer;
; 1922 :     pANTLR3_PARSER			parser;
; 1923 :     pANTLR3_TREE_PARSER	    tparser;
; 1924 :     pANTLR3_INT_STREAM	    is;
; 1925 : 
; 1926 :     switch	(recognizer->type)

  0000f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00014	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00017	89 44 24 48	 mov	 DWORD PTR tv65[rsp], eax
  0001b	83 7c 24 48 01	 cmp	 DWORD PTR tv65[rsp], 1
  00020	0f 84 80 00 00
	00		 je	 $LN6@alreadyPar
  00026	83 7c 24 48 02	 cmp	 DWORD PTR tv65[rsp], 2
  0002b	74 0c		 je	 SHORT $LN4@alreadyPar
  0002d	83 7c 24 48 04	 cmp	 DWORD PTR tv65[rsp], 4
  00032	74 3b		 je	 SHORT $LN5@alreadyPar
  00034	e9 9f 00 00 00	 jmp	 $LN7@alreadyPar
$LN4@alreadyPar:

; 1927 :     {
; 1928 : 		case	ANTLR3_TYPE_PARSER:
; 1929 : 
; 1930 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1931 : 			tparser	= NULL;

  00046	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1932 : 			lexer	= NULL;

  0004f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lexer$[rsp], 0

; 1933 : 			is	= parser->tstream->istream;

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  0005d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00061	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00065	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1934 : 
; 1935 : 			break;

  0006a	e9 87 00 00 00	 jmp	 $LN2@alreadyPar
$LN5@alreadyPar:

; 1936 : 
; 1937 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1938 : 
; 1939 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0006f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00074	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00077	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1940 : 			parser	= NULL;

  0007c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1941 : 			lexer	= NULL;

  00085	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lexer$[rsp], 0

; 1942 : 			is	= tparser->ctnstream->tnstream->istream;

  0008e	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00093	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00097	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009f	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1943 : 
; 1944 : 			break;

  000a4	eb 50		 jmp	 SHORT $LN2@alreadyPar
$LN6@alreadyPar:

; 1945 : 
; 1946 : 		case	ANTLR3_TYPE_LEXER:
; 1947 : 
; 1948 : 			lexer	= (pANTLR3_LEXER)   (recognizer->super);

  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ab	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ae	48 89 44 24 28	 mov	 QWORD PTR lexer$[rsp], rax

; 1949 : 			parser	= NULL;

  000b3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1950 : 			tparser	= NULL;

  000bc	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1951 : 			is	= lexer->input->istream;

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$[rsp]
  000ca	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d1	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1952 : 			break;

  000d6	eb 1e		 jmp	 SHORT $LN2@alreadyPar
$LN7@alreadyPar:

; 1953 : 
; 1954 : 		default:
; 1955 : 		    
; 1956 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'alreadyParsedRule' called by unknown parser type - provide override for this function\n");

  000d8	b9 02 00 00 00	 mov	 ecx, 2
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 fprintf

; 1957 : 			return ANTLR3_FALSE;

  000f2	32 c0		 xor	 al, al
  000f4	eb 6f		 jmp	 SHORT $LN1@alreadyPar
$LN2@alreadyPar:

; 1958 : 
; 1959 : 			break;
; 1960 :     }
; 1961 : 
; 1962 :     /* See if we have a memo marker for this.
; 1963 :      */
; 1964 :     stopIndex	    = recognizer->getRuleMemoization(recognizer, ruleIndex, is->index(is));

  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  000fb	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00100	ff 50 40	 call	 QWORD PTR [rax+64]
  00103	4c 8b c0	 mov	 r8, rax
  00106	48 8b 54 24 68	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  0010b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00110	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00115	ff 90 e0 00 00
	00		 call	 QWORD PTR [rax+224]
  0011b	48 89 44 24 20	 mov	 QWORD PTR stopIndex$[rsp], rax

; 1965 : 
; 1966 :     if	(stopIndex  == MEMO_RULE_UNKNOWN)

  00120	b8 ff ff ff ff	 mov	 eax, -1
  00125	48 39 44 24 20	 cmp	 QWORD PTR stopIndex$[rsp], rax
  0012a	75 04		 jne	 SHORT $LN8@alreadyPar

; 1967 :     {
; 1968 : 		return ANTLR3_FALSE;

  0012c	32 c0		 xor	 al, al
  0012e	eb 35		 jmp	 SHORT $LN1@alreadyPar
$LN8@alreadyPar:

; 1969 :     }
; 1970 : 
; 1971 :     if	(stopIndex == MEMO_RULE_FAILED)

  00130	b8 fe ff ff ff	 mov	 eax, -2
  00135	48 39 44 24 20	 cmp	 QWORD PTR stopIndex$[rsp], rax
  0013a	75 0f		 jne	 SHORT $LN9@alreadyPar

; 1972 :     {
; 1973 : 		recognizer->state->failed = ANTLR3_TRUE;

  0013c	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00141	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00145	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 1974 :     }

  00149	eb 18		 jmp	 SHORT $LN10@alreadyPar
$LN9@alreadyPar:

; 1975 :     else
; 1976 :     {
; 1977 : 		is->seek(is, stopIndex+1);

  0014b	48 8b 44 24 20	 mov	 rax, QWORD PTR stopIndex$[rsp]
  00150	48 ff c0	 inc	 rax
  00153	48 8b d0	 mov	 rdx, rax
  00156	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0015b	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00160	ff 50 60	 call	 QWORD PTR [rax+96]
$LN10@alreadyPar:

; 1978 :     }
; 1979 : 
; 1980 :     /* If here then the rule was executed for this input already
; 1981 :      */
; 1982 :     return  ANTLR3_TRUE;

  00163	b0 01		 mov	 al, 1
$LN1@alreadyPar:

; 1983 : }

  00165	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00169	5f		 pop	 rdi
  0016a	c3		 ret	 0
alreadyParsedRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getRuleMemoization
_TEXT	SEGMENT
ruleList$ = 48
stopIndex$ = 56
entry$ = 64
tv130 = 72
tv95 = 80
recognizer$ = 112
ruleIndex$ = 120
ruleParseStart$ = 128
getRuleMemoization PROC					; COMDAT

; 1856 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1857 :     /* The rule memos are an ANTLR3_LIST of ANTLR3_LIST.
; 1858 :      */
; 1859 :     pANTLR3_INT_TRIE	ruleList;
; 1860 :     ANTLR3_MARKER	stopIndex;
; 1861 :     pANTLR3_TRIE_ENTRY	entry;
; 1862 : 
; 1863 :     /* See if we have a list in the ruleMemos for this rule, and if not, then create one
; 1864 :      * as we will need it eventually if we are being asked for the memo here.
; 1865 :      */
; 1866 :     entry	= recognizer->state->ruleMemo->get(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex);

  00014	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00019	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00022	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00026	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002a	48 89 4c 24 48	 mov	 QWORD PTR tv130[rsp], rcx
  0002f	48 8b 54 24 78	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  00034	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR tv130[rsp]
  0003d	ff 50 18	 call	 QWORD PTR [rax+24]
  00040	48 89 44 24 40	 mov	 QWORD PTR entry$[rsp], rax

; 1867 : 
; 1868 :     if	(entry == NULL)

  00045	48 83 7c 24 40
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0004b	75 69		 jne	 SHORT $LN2@getRuleMem

; 1869 :     {
; 1870 : 		/* Did not find it, so create a new one for it, with a bit depth based on the 
; 1871 : 		 * size of the input stream. We need the bit depth to incorporate the number if
; 1872 : 		 * bits required to represent the largest possible stop index in the input, which is the
; 1873 : 		 * last character. An int stream is free to return the largest 64 bit offset if it has
; 1874 : 		 * no idea of the size, but you should remember that this will cause the leftmost
; 1875 : 		 * bit match algorithm to run to 63 bits, which will be the whole time spent in the trie ;-)
; 1876 : 		 */
; 1877 : 		ruleList    = antlr3IntTrieNew(63);	/* Depth is theoretically 64 bits, but probably not ;-)	*/

  0004d	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00052	e8 00 00 00 00	 call	 antlr3IntTrieNew
  00057	48 89 44 24 30	 mov	 QWORD PTR ruleList$[rsp], rax

; 1878 : 
; 1879 : 		if (ruleList != NULL)

  0005c	48 83 7c 24 30
	00		 cmp	 QWORD PTR ruleList$[rsp], 0
  00062	74 4b		 je	 SHORT $LN3@getRuleMem

; 1880 : 		{
; 1881 : 			recognizer->state->ruleMemo->add(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex, ANTLR3_HASH_TYPE_STR, 0, ANTLR3_FUNC_PTR(ruleList), freeIntTrie);

  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00069	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00072	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00076	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0007a	48 89 4c 24 50	 mov	 QWORD PTR tv95[rsp], rcx
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:freeIntTrie
  00086	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0008b	48 8b 54 24 30	 mov	 rdx, QWORD PTR ruleList$[rsp]
  00090	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00095	45 33 c9	 xor	 r9d, r9d
  00098	41 b8 01 00 00
	00		 mov	 r8d, 1
  0009e	48 8b 54 24 78	 mov	 rdx, QWORD PTR ruleIndex$[rsp]
  000a3	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR tv95[rsp]
  000ac	ff 50 28	 call	 QWORD PTR [rax+40]
$LN3@getRuleMem:

; 1882 : 		}
; 1883 : 
; 1884 : 		/* We cannot have a stopIndex in a trie we have just created of course
; 1885 : 		 */
; 1886 : 		return	MEMO_RULE_UNKNOWN;

  000af	b8 ff ff ff ff	 mov	 eax, -1
  000b4	eb 5b		 jmp	 SHORT $LN1@getRuleMem
$LN2@getRuleMem:

; 1887 :     }
; 1888 : 
; 1889 :     ruleList	= (pANTLR3_INT_TRIE) (entry->data.ptr);

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000bb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000bf	48 89 44 24 30	 mov	 QWORD PTR ruleList$[rsp], rax

; 1890 : 
; 1891 :     /* See if there is a stop index associated with the supplied start index.
; 1892 :      */
; 1893 :     stopIndex	= 0;

  000c4	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR stopIndex$[rsp], 0

; 1894 : 
; 1895 :     entry = ruleList->get(ruleList, ruleParseStart);

  000cd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ruleParseStart$[rsp]
  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ruleList$[rsp]
  000da	48 8b 44 24 30	 mov	 rax, QWORD PTR ruleList$[rsp]
  000df	ff 50 18	 call	 QWORD PTR [rax+24]
  000e2	48 89 44 24 40	 mov	 QWORD PTR entry$[rsp], rax

; 1896 :     if (entry != NULL)

  000e7	48 83 7c 24 40
	00		 cmp	 QWORD PTR entry$[rsp], 0
  000ed	74 0e		 je	 SHORT $LN4@getRuleMem

; 1897 :     {
; 1898 : 		stopIndex = (ANTLR3_MARKER)(entry->data.intVal);

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR entry$[rsp]
  000f4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f8	48 89 44 24 38	 mov	 QWORD PTR stopIndex$[rsp], rax
$LN4@getRuleMem:

; 1899 :     }
; 1900 : 
; 1901 :     if	(stopIndex == 0)

  000fd	48 83 7c 24 38
	00		 cmp	 QWORD PTR stopIndex$[rsp], 0
  00103	75 07		 jne	 SHORT $LN5@getRuleMem

; 1902 :     {
; 1903 : 		return MEMO_RULE_UNKNOWN;

  00105	b8 ff ff ff ff	 mov	 eax, -1
  0010a	eb 05		 jmp	 SHORT $LN1@getRuleMem
$LN5@getRuleMem:

; 1904 :     }
; 1905 : 
; 1906 :     return  stopIndex;

  0010c	48 8b 44 24 38	 mov	 rax, QWORD PTR stopIndex$[rsp]
$LN1@getRuleMem:

; 1907 : }

  00111	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00115	5f		 pop	 rdi
  00116	c3		 ret	 0
getRuleMemoization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT toStrings
_TEXT	SEGMENT
recognizer$ = 16
tokens$ = 24
toStrings PROC						; COMDAT

; 1833 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 1834 :     return NULL;

  0000b	33 c0		 xor	 eax, eax

; 1835 : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
toStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getRuleInvocationStackNamed
_TEXT	SEGMENT
recognizer$ = 16
name$ = 24
getRuleInvocationStackNamed PROC			; COMDAT

; 1825 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 1826 :     return NULL;

  0000b	33 c0		 xor	 eax, eax

; 1827 : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getRuleInvocationStackNamed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT getRuleInvocationStack
_TEXT	SEGMENT
recognizer$ = 16
getRuleInvocationStack PROC				; COMDAT

; 1819 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1820 :     return NULL;

  00006	33 c0		 xor	 eax, eax

; 1821 : }

  00008	5f		 pop	 rdi
  00009	c3		 ret	 0
getRuleInvocationStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT consumeUntilSet
_TEXT	SEGMENT
ttype$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
recognizer$ = 96
set$ = 104
consumeUntilSet PROC					; COMDAT

; 1767 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1768 :     ANTLR3_UINT32	    ttype;
; 1769 :     pANTLR3_PARSER	    parser;
; 1770 :     pANTLR3_TREE_PARSER	    tparser;
; 1771 :     pANTLR3_INT_STREAM	    is;
; 1772 : 
; 1773 :     switch	(recognizer->type)

  0000f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00014	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00017	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0001b	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00020	74 09		 je	 SHORT $LN6@consumeUnt
  00022	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  00027	74 2c		 je	 SHORT $LN7@consumeUnt
  00029	eb 58		 jmp	 SHORT $LN8@consumeUnt
$LN6@consumeUnt:

; 1774 :     {
; 1775 : 		case	ANTLR3_TYPE_PARSER:
; 1776 : 
; 1777 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 1778 : 			tparser	= NULL;

  00038	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1779 : 			is	= parser->tstream->istream;

  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1780 : 
; 1781 : 			break;

  00053	eb 4a		 jmp	 SHORT $LN2@consumeUnt
$LN7@consumeUnt:

; 1782 : 
; 1783 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1784 : 
; 1785 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 1786 : 			parser	= NULL;

  00062	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1787 : 			is	= tparser->ctnstream->tnstream->istream;

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  00070	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00074	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1788 : 
; 1789 : 			break;

  00081	eb 1c		 jmp	 SHORT $LN2@consumeUnt
$LN8@consumeUnt:

; 1790 : 
; 1791 : 		default:
; 1792 : 		    
; 1793 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'consumeUntilSet' called by unknown parser type - provide override for this function\n");

  00083	b9 02 00 00 00	 mov	 ecx, 2
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 fprintf

; 1794 : 			return;

  0009d	eb 5a		 jmp	 SHORT $LN1@consumeUnt
$LN2@consumeUnt:

; 1795 : 
; 1796 : 			break;
; 1797 :     }
; 1798 : 
; 1799 :     // What do have at the moment?
; 1800 :     //
; 1801 :     ttype	= is->_LA(is, 1);

  0009f	ba 01 00 00 00	 mov	 edx, 1
  000a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000a9	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000ae	ff 50 30	 call	 QWORD PTR [rax+48]
  000b1	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax
$LN4@consumeUnt:

; 1802 : 
; 1803 :     // Start eating tokens until we get to one we want.
; 1804 :     //
; 1805 :     while   (ttype != ANTLR3_TOKEN_EOF && set->isMember(set, ttype) == ANTLR3_FALSE)

  000b5	83 7c 24 20 ff	 cmp	 DWORD PTR ttype$[rsp], -1 ; ffffffffH
  000ba	74 3d		 je	 SHORT $LN5@consumeUnt
  000bc	8b 54 24 20	 mov	 edx, DWORD PTR ttype$[rsp]
  000c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR set$[rsp]
  000c5	48 8b 44 24 68	 mov	 rax, QWORD PTR set$[rsp]
  000ca	ff 50 48	 call	 QWORD PTR [rax+72]
  000cd	0f b6 c0	 movzx	 eax, al
  000d0	85 c0		 test	 eax, eax
  000d2	75 25		 jne	 SHORT $LN5@consumeUnt

; 1806 :     {
; 1807 : 		is->consume(is);

  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000d9	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000de	ff 50 28	 call	 QWORD PTR [rax+40]

; 1808 : 		ttype	= is->_LA(is, 1);

  000e1	ba 01 00 00 00	 mov	 edx, 1
  000e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000f0	ff 50 30	 call	 QWORD PTR [rax+48]
  000f3	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax

; 1809 :     }

  000f7	eb bc		 jmp	 SHORT $LN4@consumeUnt
$LN5@consumeUnt:
$LN1@consumeUnt:

; 1810 : }

  000f9	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
consumeUntilSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT consumeUntil
_TEXT	SEGMENT
ttype$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
recognizer$ = 96
tokenType$ = 104
consumeUntil PROC					; COMDAT

; 1717 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1718 :     ANTLR3_UINT32			ttype;
; 1719 :     pANTLR3_PARSER			parser;
; 1720 :     pANTLR3_TREE_PARSER	    tparser;
; 1721 :     pANTLR3_INT_STREAM	    is;
; 1722 : 
; 1723 :     switch	(recognizer->type)

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00013	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00016	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0001a	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001f	74 09		 je	 SHORT $LN6@consumeUnt
  00021	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  00026	74 2c		 je	 SHORT $LN7@consumeUnt
  00028	eb 58		 jmp	 SHORT $LN8@consumeUnt
$LN6@consumeUnt:

; 1724 :     {
; 1725 : 		case	ANTLR3_TYPE_PARSER:
; 1726 : 
; 1727 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 1728 : 			tparser	= NULL;

  00037	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1729 : 			is	= parser->tstream->istream;

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1730 : 
; 1731 : 			break;

  00052	eb 4a		 jmp	 SHORT $LN2@consumeUnt
$LN7@consumeUnt:

; 1732 : 
; 1733 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1734 : 
; 1735 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 1736 : 			parser	= NULL;

  00061	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1737 : 			is	= tparser->ctnstream->tnstream->istream;

  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  0006f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00073	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00077	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007b	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1738 : 
; 1739 : 			break;

  00080	eb 1c		 jmp	 SHORT $LN2@consumeUnt
$LN8@consumeUnt:

; 1740 : 
; 1741 : 		default:
; 1742 : 		    
; 1743 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'consumeUntil' called by unknown parser type - provide override for this function\n");

  00082	b9 02 00 00 00	 mov	 ecx, 2
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 fprintf

; 1744 : 			return;

  0009c	eb 4c		 jmp	 SHORT $LN1@consumeUnt
$LN2@consumeUnt:

; 1745 : 
; 1746 : 			break;
; 1747 :     }
; 1748 : 
; 1749 :     // What do have at the moment?
; 1750 :     //
; 1751 :     ttype	= is->_LA(is, 1);

  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000ad	ff 50 30	 call	 QWORD PTR [rax+48]
  000b0	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax
$LN4@consumeUnt:

; 1752 : 
; 1753 :     // Start eating tokens until we get to the one we want.
; 1754 :     //
; 1755 :     while   (ttype != ANTLR3_TOKEN_EOF && ttype != tokenType)

  000b4	83 7c 24 20 ff	 cmp	 DWORD PTR ttype$[rsp], -1 ; ffffffffH
  000b9	74 2f		 je	 SHORT $LN5@consumeUnt
  000bb	8b 44 24 68	 mov	 eax, DWORD PTR tokenType$[rsp]
  000bf	39 44 24 20	 cmp	 DWORD PTR ttype$[rsp], eax
  000c3	74 25		 je	 SHORT $LN5@consumeUnt

; 1756 :     {
; 1757 : 		is->consume(is);

  000c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000ca	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000cf	ff 50 28	 call	 QWORD PTR [rax+40]

; 1758 : 		ttype	= is->_LA(is, 1);

  000d2	ba 01 00 00 00	 mov	 edx, 1
  000d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000dc	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000e1	ff 50 30	 call	 QWORD PTR [rax+48]
  000e4	89 44 24 20	 mov	 DWORD PTR ttype$[rsp], eax

; 1759 :     }

  000e8	eb ca		 jmp	 SHORT $LN4@consumeUnt
$LN5@consumeUnt:
$LN1@consumeUnt:

; 1760 : }

  000ea	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
consumeUntil ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recoverFromMismatchedElement
_TEXT	SEGMENT
viableToksFollowingRule$ = 32
follow$ = 40
parser$ = 48
tparser$ = 56
is$ = 64
tv65 = 72
recognizer$ = 96
followBits$ = 104
recoverFromMismatchedElement PROC			; COMDAT

; 1620 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1621 :     pANTLR3_BITSET	    viableToksFollowingRule;
; 1622 :     pANTLR3_BITSET	    follow;
; 1623 :     pANTLR3_PARSER	    parser;
; 1624 :     pANTLR3_TREE_PARSER	    tparser;
; 1625 :     pANTLR3_INT_STREAM	    is;
; 1626 : 
; 1627 :     switch	(recognizer->type)

  0000f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00014	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00017	89 44 24 48	 mov	 DWORD PTR tv65[rsp], eax
  0001b	83 7c 24 48 02	 cmp	 DWORD PTR tv65[rsp], 2
  00020	74 09		 je	 SHORT $LN4@recoverFro
  00022	83 7c 24 48 04	 cmp	 DWORD PTR tv65[rsp], 4
  00027	74 2c		 je	 SHORT $LN5@recoverFro
  00029	eb 58		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1628 :     {
; 1629 :     case	ANTLR3_TYPE_PARSER:
; 1630 : 
; 1631 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1632 : 		tparser	= NULL;

  00038	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1633 : 		is	= parser->tstream->istream;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1634 : 
; 1635 : 	break;

  00053	eb 4f		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1636 : 
; 1637 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1638 : 
; 1639 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1640 : 		parser	= NULL;

  00062	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1641 : 		is	= tparser->ctnstream->tnstream->istream;

  0006b	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00070	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00074	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1642 : 
; 1643 : 	break;

  00081	eb 21		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1644 : 
; 1645 :     default:
; 1646 : 	    
; 1647 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recover called by unknown parser type - provide override for this function\n");

  00083	b9 02 00 00 00	 mov	 ecx, 2
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 fprintf

; 1648 : 		return ANTLR3_FALSE;

  0009d	32 c0		 xor	 al, al
  0009f	e9 eb 00 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1649 : 
; 1650 : 	break;
; 1651 :     }
; 1652 : 
; 1653 :     follow	= antlr3BitsetLoad(followBits);

  000a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR followBits$[rsp]
  000a9	e8 00 00 00 00	 call	 antlr3BitsetLoad
  000ae	48 89 44 24 28	 mov	 QWORD PTR follow$[rsp], rax

; 1654 : 
; 1655 :     if	(follow == NULL)

  000b3	48 83 7c 24 28
	00		 cmp	 QWORD PTR follow$[rsp], 0
  000b9	75 07		 jne	 SHORT $LN7@recoverFro

; 1656 :     {
; 1657 : 		/* The follow set is NULL, which means we don't know what can come 
; 1658 : 		 * next, so we "hit and hope" by just signifying that we cannot
; 1659 : 		 * recover, which will just cause the next token to be consumed,
; 1660 : 		 * which might dig us out.
; 1661 : 		 */
; 1662 : 		return	ANTLR3_FALSE;

  000bb	32 c0		 xor	 al, al
  000bd	e9 cd 00 00 00	 jmp	 $LN1@recoverFro
$LN7@recoverFro:

; 1663 :     }
; 1664 : 
; 1665 :     /* We have a bitmap for the follow set, hence we can compute 
; 1666 :      * what can follow this grammar element reference.
; 1667 :      */
; 1668 :     if	(follow->isMember(follow, ANTLR3_EOR_TOKEN_TYPE) == ANTLR3_TRUE)

  000c2	ba 01 00 00 00	 mov	 edx, 1
  000c7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  000d1	ff 50 48	 call	 QWORD PTR [rax+72]
  000d4	0f b6 c0	 movzx	 eax, al
  000d7	83 f8 01	 cmp	 eax, 1
  000da	75 34		 jne	 SHORT $LN8@recoverFro

; 1669 :     {
; 1670 : 		/* First we need to know which of the available tokens are viable
; 1671 : 		 * to follow this reference.
; 1672 : 		 */
; 1673 : 		viableToksFollowingRule	= recognizer->computeCSRuleFollow(recognizer);

  000dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000e1	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e6	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  000ec	48 89 44 24 20	 mov	 QWORD PTR viableToksFollowingRule$[rsp], rax

; 1674 : 
; 1675 : 		/* Remove the EOR token, which we do not wish to compute with
; 1676 : 		 */
; 1677 : 		follow->remove(follow, ANTLR3_EOR_TOKEN_TYPE);

  000f1	ba 01 00 00 00	 mov	 edx, 1
  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  00100	ff 50 58	 call	 QWORD PTR [rax+88]

; 1678 : 		viableToksFollowingRule->free(viableToksFollowingRule);

  00103	48 8b 4c 24 20	 mov	 rcx, QWORD PTR viableToksFollowingRule$[rsp]
  00108	48 8b 44 24 20	 mov	 rax, QWORD PTR viableToksFollowingRule$[rsp]
  0010d	ff 50 70	 call	 QWORD PTR [rax+112]
$LN8@recoverFro:

; 1679 : 		/* We now have the computed set of what can follow the current token
; 1680 : 		 */
; 1681 :     }
; 1682 : 
; 1683 :     /* We can now see if the current token works with the set of tokens
; 1684 :      * that could follow the current grammar reference. If it looks like it
; 1685 :      * is consistent, then we can "insert" that token by not throwing
; 1686 :      * an exception and assuming that we saw it. 
; 1687 :      */
; 1688 :     if	( follow->isMember(follow, is->_LA(is, 1)) == ANTLR3_TRUE)

  00110	ba 01 00 00 00	 mov	 edx, 1
  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  0011a	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0011f	ff 50 30	 call	 QWORD PTR [rax+48]
  00122	8b d0		 mov	 edx, eax
  00124	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  00129	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  0012e	ff 50 48	 call	 QWORD PTR [rax+72]
  00131	0f b6 c0	 movzx	 eax, al
  00134	83 f8 01	 cmp	 eax, 1
  00137	75 3f		 jne	 SHORT $LN9@recoverFro

; 1689 :     {
; 1690 : 		/* report the error, but don't cause any rules to abort and stuff
; 1691 : 		 */
; 1692 : 		recognizer->reportError(recognizer);

  00139	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0013e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00143	ff 50 48	 call	 QWORD PTR [rax+72]

; 1693 : 		if	(follow != NULL)

  00146	48 83 7c 24 28
	00		 cmp	 QWORD PTR follow$[rsp], 0
  0014c	74 0d		 je	 SHORT $LN10@recoverFro

; 1694 : 		{
; 1695 : 			follow->free(follow);

  0014e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  00153	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  00158	ff 50 70	 call	 QWORD PTR [rax+112]
$LN10@recoverFro:

; 1696 : 		}
; 1697 : 		recognizer->state->error			= ANTLR3_FALSE;

  0015b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00160	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00164	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1698 : 		recognizer->state->failed			= ANTLR3_FALSE;

  00167	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0016c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00170	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 1699 : 		return ANTLR3_TRUE;	/* Success in recovery	*/

  00174	b0 01		 mov	 al, 1
  00176	eb 17		 jmp	 SHORT $LN1@recoverFro
$LN9@recoverFro:

; 1700 :     }
; 1701 : 
; 1702 :     if	(follow != NULL)

  00178	48 83 7c 24 28
	00		 cmp	 QWORD PTR follow$[rsp], 0
  0017e	74 0d		 je	 SHORT $LN11@recoverFro

; 1703 :     {
; 1704 : 		follow->free(follow);

  00180	48 8b 4c 24 28	 mov	 rcx, QWORD PTR follow$[rsp]
  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR follow$[rsp]
  0018a	ff 50 70	 call	 QWORD PTR [rax+112]
$LN11@recoverFro:

; 1705 :     }
; 1706 : 
; 1707 :     /* We could not find anything viable to do, so this is going to 
; 1708 :      * cause an exception.
; 1709 :      */
; 1710 :     return  ANTLR3_FALSE;

  0018d	32 c0		 xor	 al, al
$LN1@recoverFro:

; 1711 : }

  0018f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00193	5f		 pop	 rdi
  00194	c3		 ret	 0
recoverFromMismatchedElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recoverFromMismatchedSet
_TEXT	SEGMENT
parser$ = 48
tparser$ = 56
is$ = 64
matchedSymbol$ = 72
tv65 = 80
recognizer$ = 112
follow$ = 120
recoverFromMismatchedSet PROC				; COMDAT

; 1556 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1557 :     pANTLR3_PARSER			parser;
; 1558 :     pANTLR3_TREE_PARSER	    tparser;
; 1559 :     pANTLR3_INT_STREAM	    is;
; 1560 : 	pANTLR3_COMMON_TOKEN	matchedSymbol;
; 1561 : 
; 1562 :     switch	(recognizer->type)

  0000f	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00014	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00017	89 44 24 50	 mov	 DWORD PTR tv65[rsp], eax
  0001b	83 7c 24 50 02	 cmp	 DWORD PTR tv65[rsp], 2
  00020	74 09		 je	 SHORT $LN4@recoverFro
  00022	83 7c 24 50 04	 cmp	 DWORD PTR tv65[rsp], 4
  00027	74 2c		 je	 SHORT $LN5@recoverFro
  00029	eb 58		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1563 :     {
; 1564 :     case	ANTLR3_TYPE_PARSER:
; 1565 : 
; 1566 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1567 : 		tparser	= NULL;

  00038	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1568 : 		is	= parser->tstream->istream;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1569 : 
; 1570 : 	break;

  00053	eb 4f		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1571 : 
; 1572 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1573 : 
; 1574 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00055	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1575 : 		parser	= NULL;

  00062	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1576 : 		is	= tparser->ctnstream->tnstream->istream;

  0006b	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00070	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00074	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1577 : 
; 1578 : 	break;

  00081	eb 21		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1579 : 
; 1580 :     default:
; 1581 : 	    
; 1582 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recoverFromMismatchedSet called by unknown parser type - provide override for this function\n");

  00083	b9 02 00 00 00	 mov	 ecx, 2
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 fprintf

; 1583 : 		return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 b7 00 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1584 : 
; 1585 : 	break;
; 1586 :     }
; 1587 : 
; 1588 : 	if	(recognizer->mismatchIsMissingToken(recognizer, is, follow) == ANTLR3_TRUE)

  000a4	4c 8b 44 24 78	 mov	 r8, QWORD PTR follow$[rsp]
  000a9	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  000ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000b3	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b8	ff 50 38	 call	 QWORD PTR [rax+56]
  000bb	0f b6 c0	 movzx	 eax, al
  000be	83 f8 01	 cmp	 eax, 1
  000c1	75 7d		 jne	 SHORT $LN7@recoverFro

; 1589 : 	{
; 1590 : 		// We can fake the missing token and proceed
; 1591 : 		//
; 1592 : 		matchedSymbol = recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ANTLR3_TOKEN_INVALID, follow);

  000c3	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR follow$[rsp]
  000d1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000d6	45 33 c9	 xor	 r9d, r9d
  000d9	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000dd	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  000e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000e7	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ec	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  000f2	48 89 44 24 48	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 1593 : 		recognizer->state->exception->type	= ANTLR3_MISSING_TOKEN_EXCEPTION;

  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000fc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00100	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00104	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 1594 : 		recognizer->state->exception->token	= matchedSymbol;

  0010a	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00113	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00117	48 8b 4c 24 48	 mov	 rcx, QWORD PTR matchedSymbol$[rsp]
  0011c	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1595 : 
; 1596 : 		// Print out the error after we insert so that ANTLRWorks sees the
; 1597 : 		// token in the exception.
; 1598 : 		//
; 1599 : 		recognizer->reportError(recognizer);

  00120	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00125	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0012a	ff 50 48	 call	 QWORD PTR [rax+72]

; 1600 : 
; 1601 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  0012d	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00132	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00136	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1602 : 
; 1603 : 		return	matchedSymbol;

  00139	48 8b 44 24 48	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  0013e	eb 1b		 jmp	 SHORT $LN1@recoverFro
$LN7@recoverFro:

; 1604 : 	}
; 1605 : 
; 1606 :     // TODO - Single token deletion like in recoverFromMismatchedToken()
; 1607 :     //
; 1608 :     recognizer->state->error	= ANTLR3_TRUE;

  00140	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00145	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00149	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1609 : 	recognizer->state->failed	= ANTLR3_TRUE;

  0014c	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00151	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00155	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 1610 : 	return NULL;

  00159	33 c0		 xor	 eax, eax
$LN1@recoverFro:

; 1611 : }

  0015b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0015f	5f		 pop	 rdi
  00160	c3		 ret	 0
recoverFromMismatchedSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recoverFromMismatchedToken
_TEXT	SEGMENT
parser$ = 48
tparser$ = 56
is$ = 64
matchedSymbol$ = 72
tv65 = 80
recognizer$ = 112
ttype$ = 120
follow$ = 128
recoverFromMismatchedToken PROC				; COMDAT

; 1433 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1434 : 	pANTLR3_PARSER			  parser;
; 1435 : 	pANTLR3_TREE_PARSER	      tparser;
; 1436 : 	pANTLR3_INT_STREAM	      is;
; 1437 : 	void					* matchedSymbol;
; 1438 : 
; 1439 : 
; 1440 : 
; 1441 : 	switch	(recognizer->type)

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001b	89 44 24 50	 mov	 DWORD PTR tv65[rsp], eax
  0001f	83 7c 24 50 02	 cmp	 DWORD PTR tv65[rsp], 2
  00024	74 09		 je	 SHORT $LN4@recoverFro
  00026	83 7c 24 50 04	 cmp	 DWORD PTR tv65[rsp], 4
  0002b	74 2c		 je	 SHORT $LN5@recoverFro
  0002d	eb 58		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1442 : 	{
; 1443 : 	case	ANTLR3_TYPE_PARSER:
; 1444 : 
; 1445 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 1446 : 		tparser	= NULL;

  0003c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1447 : 		is	= parser->tstream->istream;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00052	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1448 : 
; 1449 : 		break;

  00057	eb 4f		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1450 : 
; 1451 : 	case	ANTLR3_TYPE_TREE_PARSER:
; 1452 : 
; 1453 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00059	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 1454 : 		parser	= NULL;

  00066	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1455 : 		is	= tparser->ctnstream->tnstream->istream;

  0006f	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  00074	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00080	48 89 44 24 40	 mov	 QWORD PTR is$[rsp], rax

; 1456 : 
; 1457 : 		break;

  00085	eb 21		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1458 : 
; 1459 : 	default:
; 1460 : 
; 1461 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recoverFromMismatchedToken called by unknown parser type - provide override for this function\n");

  00087	b9 02 00 00 00	 mov	 ecx, 2
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 fprintf

; 1462 : 		return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 ff 01 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1463 : 
; 1464 : 		break;
; 1465 : 	}
; 1466 : 
; 1467 : 	// Create an exception if we need one
; 1468 : 	//
; 1469 : 	if	(recognizer->state->exception == NULL)

  000a8	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ad	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b1	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000b6	75 0a		 jne	 SHORT $LN7@recoverFro

; 1470 : 	{
; 1471 : 		antlr3RecognitionExceptionNew(recognizer);

  000b8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000bd	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew
$LN7@recoverFro:

; 1472 : 	}
; 1473 : 
; 1474 : 	// If the next token after the one we are looking at in the input stream
; 1475 : 	// is what we are looking for then we remove the one we have discovered
; 1476 : 	// from the stream by consuming it, then consume this next one along too as
; 1477 : 	// if nothing had happened.
; 1478 : 	//
; 1479 : 	if	( recognizer->mismatchIsUnwantedToken(recognizer, is, ttype) == ANTLR3_TRUE)

  000c2	44 8b 44 24 78	 mov	 r8d, DWORD PTR ttype$[rsp]
  000c7	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  000cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000d1	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	0f b6 c0	 movzx	 eax, al
  000dc	83 f8 01	 cmp	 eax, 1
  000df	0f 85 e4 00 00
	00		 jne	 $LN8@recoverFro

; 1480 : 	{
; 1481 : 		recognizer->state->exception->type		= ANTLR3_UNWANTED_TOKEN_EXCEPTION;

  000e5	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ea	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ee	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f2	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 1482 : 		recognizer->state->exception->message	= ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME;

  000f8	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  000fd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00101	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@
  0010c	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1483 : 
; 1484 : 		// Call resync hook (for debuggers and so on)
; 1485 : 		//
; 1486 : 		if	(recognizer->debugger != NULL)

  00110	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00115	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0011a	74 18		 je	 SHORT $LN9@recoverFro

; 1487 : 		{
; 1488 : 			recognizer->debugger->beginResync(recognizer->debugger);

  0011c	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00121	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00125	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0012a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0012e	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]
$LN9@recoverFro:

; 1489 : 		}
; 1490 : 
; 1491 : 		// "delete" the extra token
; 1492 : 		//
; 1493 : 		recognizer->beginResync(recognizer);

  00134	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00139	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0013e	ff 50 68	 call	 QWORD PTR [rax+104]

; 1494 : 		is->consume(is);

  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0014b	ff 50 28	 call	 QWORD PTR [rax+40]

; 1495 : 		recognizer->endResync(recognizer);

  0014e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00153	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00158	ff 50 70	 call	 QWORD PTR [rax+112]

; 1496 : 		// End resync hook 
; 1497 : 		//
; 1498 : 		if	(recognizer->debugger != NULL)

  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00160	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00165	74 18		 je	 SHORT $LN10@recoverFro

; 1499 : 		{
; 1500 : 			recognizer->debugger->endResync(recognizer->debugger);

  00167	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0016c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00170	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00175	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00179	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
$LN10@recoverFro:

; 1501 : 		}
; 1502 : 
; 1503 : 		// Print out the error after we consume so that ANTLRWorks sees the
; 1504 : 		// token in the exception.
; 1505 : 		//
; 1506 : 		recognizer->reportError(recognizer);

  0017f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00184	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00189	ff 50 48	 call	 QWORD PTR [rax+72]

; 1507 : 
; 1508 : 		// Return the token we are actually matching
; 1509 : 		//
; 1510 : 		matchedSymbol = recognizer->getCurrentInputSymbol(recognizer, is);

  0018c	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  00191	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0019b	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  001a1	48 89 44 24 48	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 1511 : 
; 1512 : 		// Consume the token that the rule actually expected to get as if everything
; 1513 : 		// was hunky dory.
; 1514 : 		//
; 1515 : 		is->consume(is);

  001a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  001ab	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  001b0	ff 50 28	 call	 QWORD PTR [rax+40]

; 1516 : 
; 1517 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  001b3	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  001b8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001bc	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1518 : 
; 1519 : 		return	matchedSymbol;

  001bf	48 8b 44 24 48	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  001c4	e9 de 00 00 00	 jmp	 $LN1@recoverFro
$LN8@recoverFro:

; 1520 : 	}
; 1521 : 
; 1522 : 	// Single token deletion (Unwanted above) did not work
; 1523 : 	// so we see if we can insert a token instead by calculating which
; 1524 : 	// token would be missing
; 1525 : 	//
; 1526 : 	if	(mismatchIsMissingToken(recognizer, is, follow))

  001c9	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR follow$[rsp]
  001d1	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  001d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  001db	e8 00 00 00 00	 call	 mismatchIsMissingToken
  001e0	0f b6 c0	 movzx	 eax, al
  001e3	85 c0		 test	 eax, eax
  001e5	0f 84 ae 00 00
	00		 je	 $LN11@recoverFro

; 1527 : 	{
; 1528 : 		// We can fake the missing token and proceed
; 1529 : 		//
; 1530 : 		matchedSymbol = recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ttype, follow);

  001eb	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  001f0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR follow$[rsp]
  001fc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00201	44 8b 4c 24 78	 mov	 r9d, DWORD PTR ttype$[rsp]
  00206	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0020a	48 8b 54 24 40	 mov	 rdx, QWORD PTR is$[rsp]
  0020f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00214	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00219	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  0021f	48 89 44 24 48	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 1531 : 		recognizer->state->exception->type		= ANTLR3_MISSING_TOKEN_EXCEPTION;

  00224	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00229	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0022d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00231	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 1532 : 		recognizer->state->exception->message	= ANTLR3_MISSING_TOKEN_EXCEPTION_NAME;

  00237	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0023c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00240	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@
  0024b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1533 : 		recognizer->state->exception->token		= matchedSymbol;

  0024f	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00254	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00258	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0025c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR matchedSymbol$[rsp]
  00261	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1534 : 		recognizer->state->exception->expecting	= ttype;

  00265	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0026a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0026e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00272	8b 4c 24 78	 mov	 ecx, DWORD PTR ttype$[rsp]
  00276	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 1535 : 
; 1536 : 		// Print out the error after we insert so that ANTLRWorks sees the
; 1537 : 		// token in the exception.
; 1538 : 		//
; 1539 : 		recognizer->reportError(recognizer);

  00279	48 8b 4c 24 70	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0027e	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  00283	ff 50 48	 call	 QWORD PTR [rax+72]

; 1540 : 
; 1541 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  00286	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0028b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0028f	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1542 : 
; 1543 : 		return	matchedSymbol;

  00292	48 8b 44 24 48	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  00297	eb 0e		 jmp	 SHORT $LN1@recoverFro
$LN11@recoverFro:

; 1544 : 	}
; 1545 : 
; 1546 : 
; 1547 : 	// Neither deleting nor inserting tokens allows recovery
; 1548 : 	// must just report the exception.
; 1549 : 	//
; 1550 : 	recognizer->state->error	    = ANTLR3_TRUE;

  00299	48 8b 44 24 70	 mov	 rax, QWORD PTR recognizer$[rsp]
  0029e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002a2	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1551 : 	return NULL;

  002a5	33 c0		 xor	 eax, eax
$LN1@recoverFro:

; 1552 : }

  002a7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002ab	5f		 pop	 rdi
  002ac	c3		 ret	 0
recoverFromMismatchedToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT recover
_TEXT	SEGMENT
followSet$ = 32
parser$ = 40
tparser$ = 48
is$ = 56
tv65 = 64
tv143 = 72
recognizer$ = 96
recover	PROC						; COMDAT

; 1321 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1322 :     // Used to compute the follow set of tokens
; 1323 :     //
; 1324 :     pANTLR3_BITSET			followSet;
; 1325 :     pANTLR3_PARSER			parser;
; 1326 :     pANTLR3_TREE_PARSER	    tparser;
; 1327 :     pANTLR3_INT_STREAM	    is;
; 1328 : 
; 1329 :     switch	(recognizer->type)

  0000a	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  00016	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001b	74 09		 je	 SHORT $LN4@recover
  0001d	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  00022	74 2c		 je	 SHORT $LN5@recover
  00024	eb 58		 jmp	 SHORT $LN6@recover
$LN4@recover:

; 1330 :     {
; 1331 : 		case	ANTLR3_TYPE_PARSER:
; 1332 : 
; 1333 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 44 24 28	 mov	 QWORD PTR parser$[rsp], rax

; 1334 : 		tparser	= NULL;

  00033	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1335 : 		is		= parser->tstream->istream;

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR parser$[rsp]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1336 : 
; 1337 : 	break;

  0004e	eb 4d		 jmp	 SHORT $LN2@recover
$LN5@recover:

; 1338 : 
; 1339 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1340 : 
; 1341 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00050	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 89 44 24 30	 mov	 QWORD PTR tparser$[rsp], rax

; 1342 : 		parser	= NULL;

  0005d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1343 : 		is		= tparser->ctnstream->tnstream->istream;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR tparser$[rsp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00073	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00077	48 89 44 24 38	 mov	 QWORD PTR is$[rsp], rax

; 1344 : 
; 1345 : 	break;

  0007c	eb 1f		 jmp	 SHORT $LN2@recover
$LN6@recover:

; 1346 : 
; 1347 :     default:
; 1348 : 	    
; 1349 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recover called by unknown parser type - provide override for this function\n");

  0007e	b9 02 00 00 00	 mov	 ecx, 2
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 fprintf

; 1350 : 		return;

  00098	e9 b7 00 00 00	 jmp	 $LN1@recover
$LN2@recover:

; 1351 : 
; 1352 : 	break;
; 1353 :     }
; 1354 : 
; 1355 : 	// Are we about to repeat the same error?
; 1356 : 	//
; 1357 :     if	(recognizer->state->lastErrorIndex == is->index(is))

  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a6	48 89 44 24 48	 mov	 QWORD PTR tv143[rsp], rax
  000ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000b0	48 8b 54 24 38	 mov	 rdx, QWORD PTR is$[rsp]
  000b5	ff 52 40	 call	 QWORD PTR [rdx+64]
  000b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv143[rsp]
  000bd	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000c1	75 0d		 jne	 SHORT $LN7@recover

; 1358 :     {
; 1359 : 		// The last error was at the same token index point. This must be a case
; 1360 : 		// where LT(1) is in the recovery token set so nothing is
; 1361 : 		// consumed. Consume a single token so at least to prevent
; 1362 : 		// an infinite loop; this is a failsafe.
; 1363 : 		//
; 1364 : 		is->consume(is);

  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000cd	ff 50 28	 call	 QWORD PTR [rax+40]
$LN7@recover:

; 1365 :     }
; 1366 : 
; 1367 :     // Record error index position
; 1368 :     //
; 1369 :     recognizer->state->lastErrorIndex	 = is->index(is);

  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR is$[rsp]
  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR is$[rsp]
  000da	ff 50 40	 call	 QWORD PTR [rax+64]
  000dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000e2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000e6	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1370 :     
; 1371 :     // Work out the follows set for error recovery
; 1372 :     //
; 1373 :     followSet	= recognizer->computeErrorRecoverySet(recognizer);

  000ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000f4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000fa	48 89 44 24 20	 mov	 QWORD PTR followSet$[rsp], rax

; 1374 : 
; 1375 :     // Call resync hook (for debuggers and so on)
; 1376 :     //
; 1377 :     recognizer->beginResync(recognizer);

  000ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00104	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00109	ff 50 68	 call	 QWORD PTR [rax+104]

; 1378 : 
; 1379 :     // Consume tokens until we have resynced to something in the follows set
; 1380 :     //
; 1381 :     recognizer->consumeUntilSet(recognizer, followSet);

  0010c	48 8b 54 24 20	 mov	 rdx, QWORD PTR followSet$[rsp]
  00111	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00116	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0011b	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]

; 1382 : 
; 1383 :     // End resync hook 
; 1384 :     //
; 1385 :     recognizer->endResync(recognizer);

  00121	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00126	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0012b	ff 50 70	 call	 QWORD PTR [rax+112]

; 1386 : 
; 1387 :     // Destroy the temporary bitset we produced.
; 1388 :     //
; 1389 :     followSet->free(followSet);

  0012e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR followSet$[rsp]
  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]
  00138	ff 50 70	 call	 QWORD PTR [rax+112]

; 1390 : 
; 1391 :     // Reset the inError flag so we don't re-report the exception
; 1392 :     //
; 1393 :     recognizer->state->error	= ANTLR3_FALSE;

  0013b	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00140	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00144	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1394 :     recognizer->state->failed	= ANTLR3_FALSE;

  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0014c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00150	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0
$LN1@recover:

; 1395 : }

  00154	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00158	5f		 pop	 rdi
  00159	c3		 ret	 0
recover	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT displayRecognitionError
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
ttext$ = 56
ftext$ = 64
ex$ = 72
theToken$ = 80
theBaseTree$ = 88
theCommonTree$ = 96
count$1 = 104
bit$2 = 108
size$3 = 112
numbits$4 = 116
errBits$5 = 120
tv353 = 128
tv351 = 136
tv349 = 144
tv143 = 152
tv344 = 160
tv171 = 168
tv194 = 176
tv213 = 180
tv227 = 184
tv249 = 192
tv273 = 200
tv312 = 208
tv307 = 216
recognizer$ = 240
tokenNames$ = 248
displayRecognitionError PROC				; COMDAT

; 1009 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H

; 1010 : 	pANTLR3_PARSER			parser;
; 1011 : 	pANTLR3_TREE_PARSER	    tparser;
; 1012 : 	pANTLR3_INT_STREAM	    is;
; 1013 : 	pANTLR3_STRING			ttext;
; 1014 : 	pANTLR3_STRING			ftext;
; 1015 : 	pANTLR3_EXCEPTION	    ex;
; 1016 : 	pANTLR3_COMMON_TOKEN    theToken;
; 1017 : 	pANTLR3_BASE_TREE	    theBaseTree;
; 1018 : 	pANTLR3_COMMON_TREE	    theCommonTree;
; 1019 : 
; 1020 : 	// Retrieve some info for easy reading.
; 1021 : 	//
; 1022 : 	ex	    =		recognizer->state->exception;

  00012	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00022	48 89 44 24 48	 mov	 QWORD PTR ex$[rsp], rax

; 1023 : 	ttext   =		NULL;

  00027	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ttext$[rsp], 0

; 1024 : 
; 1025 : 	// See if there is a 'filename' we can use
; 1026 : 	//
; 1027 : 	if	(ex->streamName == NULL)

  00030	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00035	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0003a	75 46		 jne	 SHORT $LN9@displayRec

; 1028 : 	{
; 1029 : 		if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00041	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00045	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  00048	75 1c		 jne	 SHORT $LN11@displayRec

; 1030 : 		{
; 1031 : 			ANTLR3_FPRINTF(stderr, "-end of input-(");

  0004a	b9 02 00 00 00	 mov	 ecx, 2
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 fprintf

; 1032 : 		}

  00064	eb 1a		 jmp	 SHORT $LN12@displayRec
$LN11@displayRec:

; 1033 : 		else
; 1034 : 		{
; 1035 : 			ANTLR3_FPRINTF(stderr, "-unknown source-(");

  00066	b9 02 00 00 00	 mov	 ecx, 2
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
  00078	48 8b c8	 mov	 rcx, rax
  0007b	e8 00 00 00 00	 call	 fprintf
$LN12@displayRec:

; 1036 : 		}
; 1037 : 	}

  00080	eb 40		 jmp	 SHORT $LN10@displayRec
$LN9@displayRec:

; 1038 : 	else
; 1039 : 	{
; 1040 : 		ftext = ex->streamName->to8(ex->streamName);

  00082	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00087	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ex$[rsp]
  00090	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00094	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  0009a	48 89 44 24 40	 mov	 QWORD PTR ftext$[rsp], rax

; 1041 : 		ANTLR3_FPRINTF(stderr, "%s(", ftext->chars);

  0009f	b9 02 00 00 00	 mov	 ecx, 2
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ftext$[rsp]
  000af	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ECLNAHEM@?$CFs?$CI@
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 fprintf
$LN10@displayRec:

; 1042 : 	}
; 1043 : 
; 1044 : 	// Next comes the line number
; 1045 : 	//
; 1046 : 
; 1047 : 	ANTLR3_FPRINTF(stderr, "%d) ", recognizer->state->exception->line);

  000c2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ca	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ce	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv353[rsp], rax
  000da	b9 02 00 00 00	 mov	 ecx, 2
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv353[rsp]
  000ed	44 8b 41 54	 mov	 r8d, DWORD PTR [rcx+84]
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CGKAJBAP@?$CFd?$CJ?5@
  000f8	48 8b c8	 mov	 rcx, rax
  000fb	e8 00 00 00 00	 call	 fprintf

; 1048 : 	ANTLR3_FPRINTF(stderr, " : error %d : %s", 

  00100	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00108	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00110	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv351[rsp], rax
  00118	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00120	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00124	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00128	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv349[rsp], rcx
  00130	b9 02 00 00 00	 mov	 ecx, 2
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv351[rsp]
  00143	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00147	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv349[rsp]
  0014f	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 fprintf

; 1049 : 										recognizer->state->exception->type,
; 1050 : 					(pANTLR3_UINT8)	   (recognizer->state->exception->message));
; 1051 : 
; 1052 : 
; 1053 : 	// How we determine the next piece is dependent on which thing raised the
; 1054 : 	// error.
; 1055 : 	//
; 1056 : 	switch	(recognizer->type)

  00161	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00169	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0016c	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv143[rsp], eax
  00173	83 bc 24 98 00
	00 00 02	 cmp	 DWORD PTR tv143[rsp], 2
  0017b	74 13		 je	 SHORT $LN13@displayRec
  0017d	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR tv143[rsp], 4
  00185	0f 84 1b 01 00
	00		 je	 $LN17@displayRec
  0018b	e9 03 02 00 00	 jmp	 $LN20@displayRec
$LN13@displayRec:

; 1057 : 	{
; 1058 : 	case	ANTLR3_TYPE_PARSER:
; 1059 : 
; 1060 : 		// Prepare the knowledge we know we have
; 1061 : 		//
; 1062 : 		parser	    = (pANTLR3_PARSER) (recognizer->super);

  00190	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00198	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019b	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 1063 : 		tparser	    = NULL;

  001a0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 1064 : 		is			= parser->tstream->istream;

  001a9	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  001ae	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001b2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001b6	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 1065 : 		theToken    = (pANTLR3_COMMON_TOKEN)(recognizer->state->exception->token);

  001bb	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  001c3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001c7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001cb	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001cf	48 89 44 24 50	 mov	 QWORD PTR theToken$[rsp], rax

; 1066 : 		ttext	    = theToken->toString(theToken);

  001d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR theToken$[rsp]
  001d9	48 8b 44 24 50	 mov	 rax, QWORD PTR theToken$[rsp]
  001de	ff 90 00 01 00
	00		 call	 QWORD PTR [rax+256]
  001e4	48 89 44 24 38	 mov	 QWORD PTR ttext$[rsp], rax

; 1067 : 
; 1068 : 		ANTLR3_FPRINTF(stderr, ", at offset %d", recognizer->state->exception->charPositionInLine);

  001e9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  001f1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001f5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv344[rsp], rax
  00201	b9 02 00 00 00	 mov	 ecx, 2
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv344[rsp]
  00214	44 8b 41 58	 mov	 r8d, DWORD PTR [rcx+88]
  00218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@
  0021f	48 8b c8	 mov	 rcx, rax
  00222	e8 00 00 00 00	 call	 fprintf

; 1069 : 		if  (theToken != NULL)

  00227	48 83 7c 24 50
	00		 cmp	 QWORD PTR theToken$[rsp], 0
  0022d	74 72		 je	 SHORT $LN14@displayRec

; 1070 : 		{
; 1071 : 			if (theToken->type == ANTLR3_TOKEN_EOF)

  0022f	48 8b 44 24 50	 mov	 rax, QWORD PTR theToken$[rsp]
  00234	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  00237	75 1c		 jne	 SHORT $LN15@displayRec

; 1072 : 			{
; 1073 : 				ANTLR3_FPRINTF(stderr, ", at <EOF>");

  00239	b9 02 00 00 00	 mov	 ecx, 2
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00244	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@
  0024b	48 8b c8	 mov	 rcx, rax
  0024e	e8 00 00 00 00	 call	 fprintf

; 1074 : 			}

  00253	eb 4c		 jmp	 SHORT $LN16@displayRec
$LN15@displayRec:

; 1075 : 			else
; 1076 : 			{
; 1077 : 				// Guard against null text in a token
; 1078 : 				//
; 1079 : 				ANTLR3_FPRINTF(stderr, "\n    near %s\n    ", ttext == NULL ? (pANTLR3_UINT8)"<no text for the token>" : ttext->chars);

  00255	48 83 7c 24 38
	00		 cmp	 QWORD PTR ttext$[rsp], 0
  0025b	75 11		 jne	 SHORT $LN45@displayRec
  0025d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@
  00264	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  0026c	eb 11		 jmp	 SHORT $LN46@displayRec
$LN45@displayRec:
  0026e	48 8b 44 24 38	 mov	 rax, QWORD PTR ttext$[rsp]
  00273	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00277	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
$LN46@displayRec:
  0027f	b9 02 00 00 00	 mov	 ecx, 2
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0028a	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR tv171[rsp]
  00292	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@
  00299	48 8b c8	 mov	 rcx, rax
  0029c	e8 00 00 00 00	 call	 fprintf
$LN16@displayRec:
$LN14@displayRec:

; 1080 : 			}
; 1081 : 		}
; 1082 : 		break;

  002a1	e9 0c 01 00 00	 jmp	 $LN2@displayRec
$LN17@displayRec:

; 1083 : 
; 1084 : 	case	ANTLR3_TYPE_TREE_PARSER:
; 1085 : 
; 1086 : 		tparser		= (pANTLR3_TREE_PARSER) (recognizer->super);

  002a6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  002ae	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b1	48 89 44 24 28	 mov	 QWORD PTR tparser$[rsp], rax

; 1087 : 		parser		= NULL;

  002b6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 1088 : 		is			= tparser->ctnstream->tnstream->istream;

  002bf	48 8b 44 24 28	 mov	 rax, QWORD PTR tparser$[rsp]
  002c4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002c8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002cc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002d0	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 1089 : 		theBaseTree	= (pANTLR3_BASE_TREE)(recognizer->state->exception->token);

  002d5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  002dd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002e1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002e5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002e9	48 89 44 24 58	 mov	 QWORD PTR theBaseTree$[rsp], rax

; 1090 : 		ttext		= theBaseTree->toStringTree(theBaseTree);

  002ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR theBaseTree$[rsp]
  002f3	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  002f8	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  002fe	48 89 44 24 38	 mov	 QWORD PTR ttext$[rsp], rax

; 1091 : 
; 1092 : 		if  (theBaseTree != NULL)

  00303	48 83 7c 24 58
	00		 cmp	 QWORD PTR theBaseTree$[rsp], 0
  00309	0f 84 82 00 00
	00		 je	 $LN18@displayRec

; 1093 : 		{
; 1094 : 			theCommonTree	= (pANTLR3_COMMON_TREE)	    theBaseTree->super;

  0030f	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  00314	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00317	48 89 44 24 60	 mov	 QWORD PTR theCommonTree$[rsp], rax

; 1095 : 
; 1096 : 			if	(theCommonTree != NULL)

  0031c	48 83 7c 24 60
	00		 cmp	 QWORD PTR theCommonTree$[rsp], 0
  00322	74 12		 je	 SHORT $LN19@displayRec

; 1097 : 			{
; 1098 : 				theToken	= (pANTLR3_COMMON_TOKEN)    theBaseTree->getToken(theBaseTree);

  00324	48 8b 4c 24 58	 mov	 rcx, QWORD PTR theBaseTree$[rsp]
  00329	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  0032e	ff 50 28	 call	 QWORD PTR [rax+40]
  00331	48 89 44 24 50	 mov	 QWORD PTR theToken$[rsp], rax
$LN19@displayRec:

; 1099 : 			}
; 1100 : 			ANTLR3_FPRINTF(stderr, ", at offset %d", theBaseTree->getCharPositionInLine(theBaseTree));

  00336	48 8b 4c 24 58	 mov	 rcx, QWORD PTR theBaseTree$[rsp]
  0033b	48 8b 44 24 58	 mov	 rax, QWORD PTR theBaseTree$[rsp]
  00340	ff 50 68	 call	 QWORD PTR [rax+104]
  00343	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  0034a	b9 02 00 00 00	 mov	 ecx, 2
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00355	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  0035c	44 8b c1	 mov	 r8d, ecx
  0035f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@
  00366	48 8b c8	 mov	 rcx, rax
  00369	e8 00 00 00 00	 call	 fprintf

; 1101 : 			ANTLR3_FPRINTF(stderr, ", near %s", ttext->chars);

  0036e	b9 02 00 00 00	 mov	 ecx, 2
  00373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00379	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttext$[rsp]
  0037e	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00382	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NBGEJOP@?0?5near?5?$CFs@
  00389	48 8b c8	 mov	 rcx, rax
  0038c	e8 00 00 00 00	 call	 fprintf
$LN18@displayRec:

; 1102 : 		}
; 1103 : 		break;

  00391	eb 1f		 jmp	 SHORT $LN2@displayRec
$LN20@displayRec:

; 1104 : 
; 1105 : 	default:
; 1106 : 
; 1107 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function displayRecognitionError called by unknown parser type - provide override for this function\n");

  00393	b9 02 00 00 00	 mov	 ecx, 2
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0039e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@
  003a5	48 8b c8	 mov	 rcx, rax
  003a8	e8 00 00 00 00	 call	 fprintf

; 1108 : 		return;

  003ad	e9 f0 03 00 00	 jmp	 $LN1@displayRec
$LN2@displayRec:

; 1109 : 		break;
; 1110 : 	}
; 1111 : 
; 1112 : 	// Although this function should generally be provided by the implementation, this one
; 1113 : 	// should be as helpful as possible for grammar developers and serve as an example
; 1114 : 	// of what you can do with each exception type. In general, when you make up your
; 1115 : 	// 'real' handler, you should debug the routine with all possible errors you expect
; 1116 : 	// which will then let you be as specific as possible about all circumstances.
; 1117 : 	//
; 1118 : 	// Note that in the general case, errors thrown by tree parsers indicate a problem
; 1119 : 	// with the output of the parser or with the tree grammar itself. The job of the parser
; 1120 : 	// is to produce a perfect (in traversal terms) syntactically correct tree, so errors
; 1121 : 	// at that stage should really be semantic errors that your own code determines and handles
; 1122 : 	// in whatever way is appropriate.
; 1123 : 	//
; 1124 : 	switch  (ex->type)

  003b2	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  003b7	8b 00		 mov	 eax, DWORD PTR [rax]
  003b9	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  003c0	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  003c7	ff c8		 dec	 eax
  003c9	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  003d0	83 bc 24 b4 00
	00 00 09	 cmp	 DWORD PTR tv213[rsp], 9
  003d8	0f 87 aa 03 00
	00		 ja	 $LN43@displayRec
  003de	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  003e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  003ec	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN49@displayRec[rcx+rax*4]
  003f3	48 03 c1	 add	 rax, rcx
  003f6	ff e0		 jmp	 rax
$LN21@displayRec:

; 1125 : 	{
; 1126 : 	case	ANTLR3_UNWANTED_TOKEN_EXCEPTION:
; 1127 : 
; 1128 : 		// Indicates that the recognizer was fed a token which seesm to be
; 1129 : 		// spurious input. We can detect this when the token that follows
; 1130 : 		// this unwanted token would normally be part of the syntactically
; 1131 : 		// correct stream. Then we can see that the token we are looking at
; 1132 : 		// is just something that should not be there and throw this exception.
; 1133 : 		//
; 1134 : 		if	(tokenNames == NULL)

  003f8	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tokenNames$[rsp], 0
  00401	75 1c		 jne	 SHORT $LN22@displayRec

; 1135 : 		{
; 1136 : 			ANTLR3_FPRINTF(stderr, " : Extraneous input...");

  00403	b9 02 00 00 00	 mov	 ecx, 2
  00408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@
  00415	48 8b c8	 mov	 rcx, rax
  00418	e8 00 00 00 00	 call	 fprintf

; 1137 : 		}

  0041d	eb 65		 jmp	 SHORT $LN23@displayRec
$LN22@displayRec:

; 1138 : 		else
; 1139 : 		{
; 1140 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  0041f	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00424	83 78 38 ff	 cmp	 DWORD PTR [rax+56], -1	; ffffffffH
  00428	75 1c		 jne	 SHORT $LN24@displayRec

; 1141 : 			{
; 1142 : 				ANTLR3_FPRINTF(stderr, " : Extraneous input - expected <EOF>\n");

  0042a	b9 02 00 00 00	 mov	 ecx, 2
  0042f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00435	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@
  0043c	48 8b c8	 mov	 rcx, rax
  0043f	e8 00 00 00 00	 call	 fprintf

; 1143 : 			}

  00444	eb 3e		 jmp	 SHORT $LN25@displayRec
$LN24@displayRec:

; 1144 : 			else
; 1145 : 			{
; 1146 : 				ANTLR3_FPRINTF(stderr, " : Extraneous input - expected %s ...\n", tokenNames[ex->expecting]);

  00446	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  0044b	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0044e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
  00456	b9 02 00 00 00	 mov	 ecx, 2
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00461	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  00469	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv227[rsp]
  00471	4c 8b 04 d1	 mov	 r8, QWORD PTR [rcx+rdx*8]
  00475	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@
  0047c	48 8b c8	 mov	 rcx, rax
  0047f	e8 00 00 00 00	 call	 fprintf
$LN25@displayRec:
$LN23@displayRec:

; 1147 : 			}
; 1148 : 		}
; 1149 : 		break;

  00484	e9 19 03 00 00	 jmp	 $LN4@displayRec
$LN26@displayRec:

; 1150 : 
; 1151 : 	case	ANTLR3_MISSING_TOKEN_EXCEPTION:
; 1152 : 
; 1153 : 		// Indicates that the recognizer detected that the token we just
; 1154 : 		// hit would be valid syntactically if preceeded by a particular 
; 1155 : 		// token. Perhaps a missing ';' at line end or a missing ',' in an
; 1156 : 		// expression list, and such like.
; 1157 : 		//
; 1158 : 		if	(tokenNames == NULL)

  00489	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tokenNames$[rsp], 0
  00492	75 25		 jne	 SHORT $LN27@displayRec

; 1159 : 		{
; 1160 : 			ANTLR3_FPRINTF(stderr, " : Missing token (%d)...\n", ex->expecting);

  00494	b9 02 00 00 00	 mov	 ecx, 2
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0049f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ex$[rsp]
  004a4	44 8b 41 38	 mov	 r8d, DWORD PTR [rcx+56]
  004a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@
  004af	48 8b c8	 mov	 rcx, rax
  004b2	e8 00 00 00 00	 call	 fprintf

; 1161 : 		}

  004b7	eb 65		 jmp	 SHORT $LN28@displayRec
$LN27@displayRec:

; 1162 : 		else
; 1163 : 		{
; 1164 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  004b9	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  004be	83 78 38 ff	 cmp	 DWORD PTR [rax+56], -1	; ffffffffH
  004c2	75 1c		 jne	 SHORT $LN29@displayRec

; 1165 : 			{
; 1166 : 				ANTLR3_FPRINTF(stderr, " : Missing <EOF>\n");

  004c4	b9 02 00 00 00	 mov	 ecx, 2
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	e8 00 00 00 00	 call	 fprintf

; 1167 : 			}

  004de	eb 3e		 jmp	 SHORT $LN30@displayRec
$LN29@displayRec:

; 1168 : 			else
; 1169 : 			{
; 1170 : 				ANTLR3_FPRINTF(stderr, " : Missing %s \n", tokenNames[ex->expecting]);

  004e0	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  004e5	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  004e8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  004f0	b9 02 00 00 00	 mov	 ecx, 2
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004fb	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  00503	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv249[rsp]
  0050b	4c 8b 04 d1	 mov	 r8, QWORD PTR [rcx+rdx*8]
  0050f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@
  00516	48 8b c8	 mov	 rcx, rax
  00519	e8 00 00 00 00	 call	 fprintf
$LN30@displayRec:
$LN28@displayRec:

; 1171 : 			}
; 1172 : 		}
; 1173 : 		break;

  0051e	e9 7f 02 00 00	 jmp	 $LN4@displayRec
$LN31@displayRec:

; 1174 : 
; 1175 : 	case	ANTLR3_RECOGNITION_EXCEPTION:
; 1176 : 
; 1177 : 		// Indicates that the recognizer received a token
; 1178 : 		// in the input that was not predicted. This is the basic exception type 
; 1179 : 		// from which all others are derived. So we assume it was a syntax error.
; 1180 : 		// You may get this if there are not more tokens and more are needed
; 1181 : 		// to complete a parse for instance.
; 1182 : 		//
; 1183 : 		ANTLR3_FPRINTF(stderr, " : syntax error...\n");    

  00523	b9 02 00 00 00	 mov	 ecx, 2
  00528	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0052e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@
  00535	48 8b c8	 mov	 rcx, rax
  00538	e8 00 00 00 00	 call	 fprintf

; 1184 : 		break;

  0053d	e9 60 02 00 00	 jmp	 $LN4@displayRec
$LN32@displayRec:

; 1185 : 
; 1186 : 	case    ANTLR3_MISMATCHED_TOKEN_EXCEPTION:
; 1187 : 
; 1188 : 		// We were expecting to see one thing and got another. This is the
; 1189 : 		// most common error if we coudl not detect a missing or unwanted token.
; 1190 : 		// Here you can spend your efforts to
; 1191 : 		// derive more useful error messages based on the expected
; 1192 : 		// token set and the last token and so on. The error following
; 1193 : 		// bitmaps do a good job of reducing the set that we were looking
; 1194 : 		// for down to something small. Knowing what you are parsing may be
; 1195 : 		// able to allow you to be even more specific about an error.
; 1196 : 		//
; 1197 : 		if	(tokenNames == NULL)

  00542	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tokenNames$[rsp], 0
  0054b	75 1c		 jne	 SHORT $LN33@displayRec

; 1198 : 		{
; 1199 : 			ANTLR3_FPRINTF(stderr, " : syntax error...\n");

  0054d	b9 02 00 00 00	 mov	 ecx, 2
  00552	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00558	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@
  0055f	48 8b c8	 mov	 rcx, rax
  00562	e8 00 00 00 00	 call	 fprintf

; 1200 : 		}

  00567	eb 65		 jmp	 SHORT $LN34@displayRec
$LN33@displayRec:

; 1201 : 		else
; 1202 : 		{
; 1203 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  00569	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  0056e	83 78 38 ff	 cmp	 DWORD PTR [rax+56], -1	; ffffffffH
  00572	75 1c		 jne	 SHORT $LN35@displayRec

; 1204 : 			{
; 1205 : 				ANTLR3_FPRINTF(stderr, " : expected <EOF>\n");

  00574	b9 02 00 00 00	 mov	 ecx, 2
  00579	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@
  00586	48 8b c8	 mov	 rcx, rax
  00589	e8 00 00 00 00	 call	 fprintf

; 1206 : 			}

  0058e	eb 3e		 jmp	 SHORT $LN36@displayRec
$LN35@displayRec:

; 1207 : 			else
; 1208 : 			{
; 1209 : 				ANTLR3_FPRINTF(stderr, " : expected %s ...\n", tokenNames[ex->expecting]);

  00590	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00595	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00598	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  005a0	b9 02 00 00 00	 mov	 ecx, 2
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ab	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  005b3	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv273[rsp]
  005bb	4c 8b 04 d1	 mov	 r8, QWORD PTR [rcx+rdx*8]
  005bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@
  005c6	48 8b c8	 mov	 rcx, rax
  005c9	e8 00 00 00 00	 call	 fprintf
$LN36@displayRec:
$LN34@displayRec:

; 1210 : 			}
; 1211 : 		}
; 1212 : 		break;

  005ce	e9 cf 01 00 00	 jmp	 $LN4@displayRec
$LN37@displayRec:

; 1213 : 
; 1214 : 	case	ANTLR3_NO_VIABLE_ALT_EXCEPTION:
; 1215 : 
; 1216 : 		// We could not pick any alt decision from the input given
; 1217 : 		// so god knows what happened - however when you examine your grammar,
; 1218 : 		// you should. It means that at the point where the current token occurred
; 1219 : 		// that the DFA indicates nowhere to go from here.
; 1220 : 		//
; 1221 : 		ANTLR3_FPRINTF(stderr, " : cannot match to any predicted input...\n");

  005d3	b9 02 00 00 00	 mov	 ecx, 2
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@
  005e5	48 8b c8	 mov	 rcx, rax
  005e8	e8 00 00 00 00	 call	 fprintf

; 1222 : 
; 1223 : 		break;

  005ed	e9 b0 01 00 00	 jmp	 $LN4@displayRec
$LN38@displayRec:

; 1224 : 
; 1225 : 	case	ANTLR3_MISMATCHED_SET_EXCEPTION:
; 1226 : 
; 1227 : 		{
; 1228 : 			ANTLR3_UINT32	  count;
; 1229 : 			ANTLR3_UINT32	  bit;
; 1230 : 			ANTLR3_UINT32	  size;
; 1231 : 			ANTLR3_UINT32	  numbits;
; 1232 : 			pANTLR3_BITSET	  errBits;
; 1233 : 
; 1234 : 			// This means we were able to deal with one of a set of
; 1235 : 			// possible tokens at this point, but we did not see any
; 1236 : 			// member of that set.
; 1237 : 			//
; 1238 : 			ANTLR3_FPRINTF(stderr, " : unexpected input...\n  expected one of : ");

  005f2	b9 02 00 00 00	 mov	 ecx, 2
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@
  00604	48 8b c8	 mov	 rcx, rax
  00607	e8 00 00 00 00	 call	 fprintf

; 1239 : 
; 1240 : 			// What tokens could we have accepted at this point in the
; 1241 : 			// parse?
; 1242 : 			//
; 1243 : 			count   = 0;

  0060c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR count$1[rsp], 0

; 1244 : 			errBits = antlr3BitsetLoad		(ex->expectingSet);

  00614	48 8b 44 24 48	 mov	 rax, QWORD PTR ex$[rsp]
  00619	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0061d	e8 00 00 00 00	 call	 antlr3BitsetLoad
  00622	48 89 44 24 78	 mov	 QWORD PTR errBits$5[rsp], rax

; 1245 : 			numbits = errBits->numBits		(errBits);

  00627	48 8b 4c 24 78	 mov	 rcx, QWORD PTR errBits$5[rsp]
  0062c	48 8b 44 24 78	 mov	 rax, QWORD PTR errBits$5[rsp]
  00631	ff 50 50	 call	 QWORD PTR [rax+80]
  00634	89 44 24 74	 mov	 DWORD PTR numbits$4[rsp], eax

; 1246 : 			size    = errBits->size			(errBits);

  00638	48 8b 4c 24 78	 mov	 rcx, QWORD PTR errBits$5[rsp]
  0063d	48 8b 44 24 78	 mov	 rax, QWORD PTR errBits$5[rsp]
  00642	ff 50 28	 call	 QWORD PTR [rax+40]
  00645	89 44 24 70	 mov	 DWORD PTR size$3[rsp], eax

; 1247 : 
; 1248 : 			if  (size > 0)

  00649	83 7c 24 70 00	 cmp	 DWORD PTR size$3[rsp], 0
  0064e	0f 86 e2 00 00
	00		 jbe	 $LN39@displayRec

; 1249 : 			{
; 1250 : 				// However many tokens we could have dealt with here, it is usually
; 1251 : 				// not useful to print ALL of the set here. I arbitrarily chose 8
; 1252 : 				// here, but you should do whatever makes sense for you of course.
; 1253 : 				// No token number 0, so look for bit 1 and on.
; 1254 : 				//
; 1255 : 				for	(bit = 1; bit < numbits && count < 8 && count < size; bit++)

  00654	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR bit$2[rsp], 1
  0065c	eb 0a		 jmp	 SHORT $LN8@displayRec
$LN6@displayRec:
  0065e	8b 44 24 6c	 mov	 eax, DWORD PTR bit$2[rsp]
  00662	ff c0		 inc	 eax
  00664	89 44 24 6c	 mov	 DWORD PTR bit$2[rsp], eax
$LN8@displayRec:
  00668	8b 44 24 74	 mov	 eax, DWORD PTR numbits$4[rsp]
  0066c	39 44 24 6c	 cmp	 DWORD PTR bit$2[rsp], eax
  00670	0f 83 a4 00 00
	00		 jae	 $LN7@displayRec
  00676	83 7c 24 68 08	 cmp	 DWORD PTR count$1[rsp], 8
  0067b	0f 83 99 00 00
	00		 jae	 $LN7@displayRec
  00681	8b 44 24 70	 mov	 eax, DWORD PTR size$3[rsp]
  00685	39 44 24 68	 cmp	 DWORD PTR count$1[rsp], eax
  00689	0f 83 8b 00 00
	00		 jae	 $LN7@displayRec

; 1256 : 				{
; 1257 : 					// TODO: This doesn;t look right - should be asking if the bit is set!!
; 1258 : 					//
; 1259 : 					if  (tokenNames[bit])

  0068f	8b 44 24 6c	 mov	 eax, DWORD PTR bit$2[rsp]
  00693	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  0069b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  006a0	74 73		 je	 SHORT $LN41@displayRec

; 1260 : 					{
; 1261 : 						ANTLR3_FPRINTF(stderr, "%s%s", count > 0 ? ", " : "", tokenNames[bit]); 

  006a2	83 7c 24 68 00	 cmp	 DWORD PTR count$1[rsp], 0
  006a7	76 11		 jbe	 SHORT $LN47@displayRec
  006a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02KEGNLNML@?0?5@
  006b0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv312[rsp], rax
  006b8	eb 0f		 jmp	 SHORT $LN48@displayRec
$LN47@displayRec:
  006ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  006c1	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv312[rsp], rax
$LN48@displayRec:
  006c9	8b 44 24 6c	 mov	 eax, DWORD PTR bit$2[rsp]
  006cd	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv307[rsp], rax
  006d5	b9 02 00 00 00	 mov	 ecx, 2
  006da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tokenNames$[rsp]
  006e8	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv307[rsp]
  006f0	4c 8b 0c d1	 mov	 r9, QWORD PTR [rcx+rdx*8]
  006f4	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR tv312[rsp]
  006fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HDOCAJNK@?$CFs?$CFs@
  00703	48 8b c8	 mov	 rcx, rax
  00706	e8 00 00 00 00	 call	 fprintf

; 1262 : 						count++;

  0070b	8b 44 24 68	 mov	 eax, DWORD PTR count$1[rsp]
  0070f	ff c0		 inc	 eax
  00711	89 44 24 68	 mov	 DWORD PTR count$1[rsp], eax
$LN41@displayRec:

; 1263 : 					}
; 1264 : 				}

  00715	e9 44 ff ff ff	 jmp	 $LN6@displayRec
$LN7@displayRec:

; 1265 : 				ANTLR3_FPRINTF(stderr, "\n");

  0071a	b9 02 00 00 00	 mov	 ecx, 2
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00725	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
  0072c	48 8b c8	 mov	 rcx, rax
  0072f	e8 00 00 00 00	 call	 fprintf

; 1266 : 			}

  00734	eb 34		 jmp	 SHORT $LN40@displayRec
$LN39@displayRec:

; 1267 : 			else
; 1268 : 			{
; 1269 : 				ANTLR3_FPRINTF(stderr, "Actually dude, we didn't seem to be expecting anything here, or at least\n");

  00736	b9 02 00 00 00	 mov	 ecx, 2
  0073b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00741	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@
  00748	48 8b c8	 mov	 rcx, rax
  0074b	e8 00 00 00 00	 call	 fprintf

; 1270 : 				ANTLR3_FPRINTF(stderr, "I could not work out what I was expecting, like so many of us these days!\n");

  00750	b9 02 00 00 00	 mov	 ecx, 2
  00755	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0075b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@
  00762	48 8b c8	 mov	 rcx, rax
  00765	e8 00 00 00 00	 call	 fprintf
$LN40@displayRec:

; 1271 : 			}
; 1272 : 		}
; 1273 : 		break;

  0076a	eb 36		 jmp	 SHORT $LN4@displayRec
$LN42@displayRec:

; 1274 : 
; 1275 : 	case	ANTLR3_EARLY_EXIT_EXCEPTION:
; 1276 : 
; 1277 : 		// We entered a loop requiring a number of token sequences
; 1278 : 		// but found a token that ended that sequence earlier than
; 1279 : 		// we should have done.
; 1280 : 		//
; 1281 : 		ANTLR3_FPRINTF(stderr, " : missing elements...\n");

  0076c	b9 02 00 00 00	 mov	 ecx, 2
  00771	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00777	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@
  0077e	48 8b c8	 mov	 rcx, rax
  00781	e8 00 00 00 00	 call	 fprintf

; 1282 : 		break;

  00786	eb 1a		 jmp	 SHORT $LN4@displayRec
$LN43@displayRec:

; 1283 : 
; 1284 : 	default:
; 1285 : 
; 1286 : 		// We don't handle any other exceptions here, but you can
; 1287 : 		// if you wish. If we get an exception that hits this point
; 1288 : 		// then we are just going to report what we know about the
; 1289 : 		// token.
; 1290 : 		//
; 1291 : 		ANTLR3_FPRINTF(stderr, " : syntax not recognized...\n");

  00788	b9 02 00 00 00	 mov	 ecx, 2
  0078d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00793	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@
  0079a	48 8b c8	 mov	 rcx, rax
  0079d	e8 00 00 00 00	 call	 fprintf
$LN4@displayRec:
$LN1@displayRec:

; 1292 : 		break;
; 1293 : 	}
; 1294 : 
; 1295 : 	// Here you have the token that was in error which if this is
; 1296 : 	// the standard implementation will tell you the line and offset
; 1297 : 	// and also record the address of the start of the line in the
; 1298 : 	// input stream. You could therefore print the source line and so on.
; 1299 : 	// Generally though, I would expect that your lexer/parser will keep
; 1300 : 	// its own map of lines and source pointers or whatever as there
; 1301 : 	// are a lot of specific things you need to know about the input
; 1302 : 	// to do something like that.
; 1303 : 	// Here is where you do it though :-).
; 1304 : 	//
; 1305 : }

  007a2	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  007a9	5f		 pop	 rdi
  007aa	c3		 ret	 0
  007ab	90		 npad	 1
$LN49@displayRec:
  007ac	00 00 00 00	 DD	 $LN31@displayRec
  007b0	00 00 00 00	 DD	 $LN32@displayRec
  007b4	00 00 00 00	 DD	 $LN37@displayRec
  007b8	00 00 00 00	 DD	 $LN38@displayRec
  007bc	00 00 00 00	 DD	 $LN42@displayRec
  007c0	00 00 00 00	 DD	 $LN43@displayRec
  007c4	00 00 00 00	 DD	 $LN43@displayRec
  007c8	00 00 00 00	 DD	 $LN43@displayRec
  007cc	00 00 00 00	 DD	 $LN21@displayRec
  007d0	00 00 00 00	 DD	 $LN26@displayRec
displayRecognitionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT combineFollows
_TEXT	SEGMENT
followSet$ = 32
localFollowSet$ = 40
top$ = 48
i$ = 52
tv143 = 56
tv140 = 64
recognizer$ = 96
exact$ = 104
combineFollows PROC					; COMDAT

; 948  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 949  :     pANTLR3_BITSET	followSet;
; 950  :     pANTLR3_BITSET	localFollowSet;
; 951  :     ANTLR3_UINT32	top;
; 952  :     ANTLR3_UINT32	i;
; 953  : 
; 954  :     top	= recognizer->state->following->size(recognizer->state->following);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0001c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00020	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00024	48 89 4c 24 38	 mov	 QWORD PTR tv143[rsp], rcx
  00029	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0002d	48 8b 44 24 38	 mov	 rax, QWORD PTR tv143[rsp]
  00032	ff 50 30	 call	 QWORD PTR [rax+48]
  00035	89 44 24 30	 mov	 DWORD PTR top$[rsp], eax

; 955  : 
; 956  :     followSet	    = antlr3BitsetNew(0);

  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 antlr3BitsetNew
  00040	48 89 44 24 20	 mov	 QWORD PTR followSet$[rsp], rax

; 957  : 	localFollowSet	= NULL;

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR localFollowSet$[rsp], 0

; 958  : 
; 959  :     for (i = top; i>0; i--)

  0004e	8b 44 24 30	 mov	 eax, DWORD PTR top$[rsp]
  00052	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
  00056	eb 0a		 jmp	 SHORT $LN4@combineFol
$LN2@combineFol:
  00058	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0005c	ff c8		 dec	 eax
  0005e	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@combineFol:
  00062	83 7c 24 34 00	 cmp	 DWORD PTR i$[rsp], 0
  00067	0f 86 b3 00 00
	00		 jbe	 $LN3@combineFol

; 960  :     {
; 961  : 		localFollowSet = antlr3BitsetLoad((pANTLR3_BITSET_LIST) recognizer->state->following->get(recognizer->state->following, i-1));

  0006d	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00071	ff c8		 dec	 eax
  00073	8b c0		 mov	 eax, eax
  00075	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0007a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007e	48 8b 54 24 60	 mov	 rdx, QWORD PTR recognizer$[rsp]
  00083	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00087	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0008b	48 89 54 24 40	 mov	 QWORD PTR tv140[rsp], rdx
  00090	8b d0		 mov	 edx, eax
  00092	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00096	48 8b 44 24 40	 mov	 rax, QWORD PTR tv140[rsp]
  0009b	ff 50 20	 call	 QWORD PTR [rax+32]
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	e8 00 00 00 00	 call	 antlr3BitsetLoad
  000a6	48 89 44 24 28	 mov	 QWORD PTR localFollowSet$[rsp], rax

; 962  : 
; 963  : 		if  (localFollowSet != NULL)

  000ab	48 83 7c 24 28
	00		 cmp	 QWORD PTR localFollowSet$[rsp], 0
  000b1	74 68		 je	 SHORT $LN5@combineFol

; 964  : 		{
; 965  : 			followSet->borInPlace(followSet, localFollowSet);

  000b3	48 8b 54 24 28	 mov	 rdx, QWORD PTR localFollowSet$[rsp]
  000b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR followSet$[rsp]
  000bd	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]
  000c2	ff 50 20	 call	 QWORD PTR [rax+32]

; 966  : 
; 967  : 			if	(exact == ANTLR3_TRUE)

  000c5	0f b6 44 24 68	 movzx	 eax, BYTE PTR exact$[rsp]
  000ca	83 f8 01	 cmp	 eax, 1
  000cd	75 36		 jne	 SHORT $LN6@combineFol

; 968  : 			{
; 969  : 				if	(localFollowSet->isMember(localFollowSet, ANTLR3_EOR_TOKEN_TYPE) == ANTLR3_FALSE)

  000cf	ba 01 00 00 00	 mov	 edx, 1
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR localFollowSet$[rsp]
  000d9	48 8b 44 24 28	 mov	 rax, QWORD PTR localFollowSet$[rsp]
  000de	ff 50 48	 call	 QWORD PTR [rax+72]
  000e1	0f b6 c0	 movzx	 eax, al
  000e4	85 c0		 test	 eax, eax
  000e6	75 1b		 jne	 SHORT $LN7@combineFol

; 970  : 				{
; 971  : 					// Only leave EOR in the set if at top (start rule); this lets us know
; 972  : 					// if we have to include the follow(start rule); I.E., EOF
; 973  : 					//
; 974  : 					if	(i>1)

  000e8	83 7c 24 34 01	 cmp	 DWORD PTR i$[rsp], 1
  000ed	76 12		 jbe	 SHORT $LN9@combineFol

; 975  : 					{
; 976  : 						followSet->remove(followSet, ANTLR3_EOR_TOKEN_TYPE);

  000ef	ba 01 00 00 00	 mov	 edx, 1
  000f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR followSet$[rsp]
  000f9	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]
  000fe	ff 50 58	 call	 QWORD PTR [rax+88]
$LN9@combineFol:

; 977  : 					}
; 978  : 				}

  00101	eb 02		 jmp	 SHORT $LN8@combineFol
$LN7@combineFol:

; 979  : 				else
; 980  : 				{
; 981  : 					break;	// Cannot see End Of Rule from here, just drop out

  00103	eb 1b		 jmp	 SHORT $LN3@combineFol
$LN8@combineFol:
$LN6@combineFol:

; 982  : 				}
; 983  : 			}
; 984  : 			localFollowSet->free(localFollowSet);

  00105	48 8b 4c 24 28	 mov	 rcx, QWORD PTR localFollowSet$[rsp]
  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR localFollowSet$[rsp]
  0010f	ff 50 70	 call	 QWORD PTR [rax+112]

; 985  : 			localFollowSet = NULL;

  00112	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR localFollowSet$[rsp], 0
$LN5@combineFol:

; 986  : 		}
; 987  :     }

  0011b	e9 38 ff ff ff	 jmp	 $LN2@combineFol
$LN3@combineFol:

; 988  : 
; 989  : 	if	(localFollowSet != NULL)

  00120	48 83 7c 24 28
	00		 cmp	 QWORD PTR localFollowSet$[rsp], 0
  00126	74 0d		 je	 SHORT $LN10@combineFol

; 990  : 	{
; 991  : 		localFollowSet->free(localFollowSet);

  00128	48 8b 4c 24 28	 mov	 rcx, QWORD PTR localFollowSet$[rsp]
  0012d	48 8b 44 24 28	 mov	 rax, QWORD PTR localFollowSet$[rsp]
  00132	ff 50 70	 call	 QWORD PTR [rax+112]
$LN10@combineFol:

; 992  : 	}
; 993  :     return  followSet;

  00135	48 8b 44 24 20	 mov	 rax, QWORD PTR followSet$[rsp]

; 994  : }

  0013a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0013e	5f		 pop	 rdi
  0013f	c3		 ret	 0
combineFollows ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT computeCSRuleFollow
_TEXT	SEGMENT
recognizer$ = 48
computeCSRuleFollow PROC				; COMDAT

; 940  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 941  :     return   recognizer->combineFollows(recognizer, ANTLR3_FALSE);

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00016	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 942  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
computeCSRuleFollow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT reportError
_TEXT	SEGMENT
tv129 = 32
recognizer$ = 64
reportError PROC					; COMDAT

; 722  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 723  :     	// Invoke the debugger event if there is a debugger listening to us
; 724  : 	//
; 725  : 	if	(recognizer->debugger != NULL)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00014	74 2f		 je	 SHORT $LN2@reportErro

; 726  : 	{
; 727  : 		recognizer->debugger->recognitionException(recognizer->debugger, recognizer->state->exception);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00024	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00028	48 89 4c 24 20	 mov	 QWORD PTR tv129[rsp], rcx
  0002d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00036	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR tv129[rsp]
  0003f	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
$LN2@reportErro:

; 728  : 	}
; 729  : 
; 730  :     if	(recognizer->state->errorRecovery == ANTLR3_TRUE)

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00052	83 f8 01	 cmp	 eax, 1
  00055	75 02		 jne	 SHORT $LN3@reportErro

; 731  :     {
; 732  : 		// Already in error recovery so don't display another error while doing so
; 733  : 		//
; 734  : 		return;

  00057	eb 41		 jmp	 SHORT $LN1@reportErro
$LN3@reportErro:

; 735  :     }
; 736  : 
; 737  :     // Signal we are in error recovery now
; 738  :     //
; 739  :     recognizer->state->errorRecovery = ANTLR3_TRUE;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00062	c6 40 20 01	 mov	 BYTE PTR [rax+32], 1

; 740  : 	
; 741  : 	// Indicate this recognizer had an error while processing.
; 742  : 	//
; 743  : 	recognizer->state->errorCount++;

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00072	ff c0		 inc	 eax
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00079	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007d	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 744  : 
; 745  : 	// Call the error display routine
; 746  : 	//
; 747  :     recognizer->displayRecognitionError(recognizer, recognizer->state->tokenNames);

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00089	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00097	ff 50 50	 call	 QWORD PTR [rax+80]
$LN1@reportErro:

; 748  : }

  0009a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
reportError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT mismatchIsMissingToken
_TEXT	SEGMENT
retcode$ = 32
followClone$ = 40
viableTokensFollowingThisRule$ = 48
recognizer$ = 80
is$ = 88
follow$ = 96
mismatchIsMissingToken PROC				; COMDAT

; 553  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 554  : 	ANTLR3_BOOLEAN	retcode;
; 555  : 	pANTLR3_BITSET	followClone;
; 556  : 	pANTLR3_BITSET	viableTokensFollowingThisRule;
; 557  : 
; 558  : 	if	(follow == NULL)

  00014	48 83 7c 24 60
	00		 cmp	 QWORD PTR follow$[rsp], 0
  0001a	75 07		 jne	 SHORT $LN2@mismatchIs

; 559  : 	{
; 560  : 		// There is no information about the tokens that can follow the last one
; 561  : 		// hence we must say that the current one we found is not a member of the 
; 562  : 		// follow set and does not indicate a missing token. We will just consume this
; 563  : 		// single token and see if the parser works it out from there.
; 564  : 		//
; 565  : 		return	ANTLR3_FALSE;

  0001c	32 c0		 xor	 al, al
  0001e	e9 14 01 00 00	 jmp	 $LN1@mismatchIs
$LN2@mismatchIs:

; 566  : 	}
; 567  : 
; 568  : 	followClone						= NULL;

  00023	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR followClone$[rsp], 0

; 569  : 	viableTokensFollowingThisRule	= NULL;

  0002c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR viableTokensFollowingThisRule$[rsp], 0

; 570  : 
; 571  : 	// The C bitset maps are laid down at compile time by the
; 572  : 	// C code generation. Hence we cannot remove things from them
; 573  : 	// and so on. So, in order to remove EOR (if we need to) then
; 574  : 	// we clone the static bitset.
; 575  : 	//
; 576  : 	followClone = antlr3BitsetLoad(follow);

  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR follow$[rsp]
  0003a	e8 00 00 00 00	 call	 antlr3BitsetLoad
  0003f	48 89 44 24 28	 mov	 QWORD PTR followClone$[rsp], rax

; 577  : 	if	(followClone == NULL)

  00044	48 83 7c 24 28
	00		 cmp	 QWORD PTR followClone$[rsp], 0
  0004a	75 07		 jne	 SHORT $LN3@mismatchIs

; 578  : 	{
; 579  : 		return ANTLR3_FALSE;

  0004c	32 c0		 xor	 al, al
  0004e	e9 e4 00 00 00	 jmp	 $LN1@mismatchIs
$LN3@mismatchIs:

; 580  : 	}
; 581  : 
; 582  : 	// Compute what can follow this grammar reference
; 583  : 	//
; 584  : 	if	(followClone->isMember(followClone, ANTLR3_EOR_TOKEN_TYPE))

  00053	ba 01 00 00 00	 mov	 edx, 1
  00058	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  00062	ff 50 48	 call	 QWORD PTR [rax+72]
  00065	0f b6 c0	 movzx	 eax, al
  00068	85 c0		 test	 eax, eax
  0006a	74 4f		 je	 SHORT $LN4@mismatchIs

; 585  : 	{
; 586  : 		// EOR can follow, but if we are not the start symbol, we
; 587  : 		// need to remove it.
; 588  : 		//
; 589  : 		if	(recognizer->state->following->vector->count >= 0)

  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00071	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00075	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00080	72 12		 jb	 SHORT $LN5@mismatchIs

; 590  : 		{
; 591  : 			followClone->remove(followClone, ANTLR3_EOR_TOKEN_TYPE);

  00082	ba 01 00 00 00	 mov	 edx, 1
  00087	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  0008c	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  00091	ff 50 58	 call	 QWORD PTR [rax+88]
$LN5@mismatchIs:

; 592  : 		}
; 593  : 
; 594  : 		// Now compute the visiable tokens that can follow this rule, according to context
; 595  : 		// and make them part of the follow set.
; 596  : 		//
; 597  : 		viableTokensFollowingThisRule = recognizer->computeCSRuleFollow(recognizer);

  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0009e	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  000a4	48 89 44 24 30	 mov	 QWORD PTR viableTokensFollowingThisRule$[rsp], rax

; 598  : 		followClone->borInPlace(followClone, viableTokensFollowingThisRule);

  000a9	48 8b 54 24 30	 mov	 rdx, QWORD PTR viableTokensFollowingThisRule$[rsp]
  000ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  000b3	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  000b8	ff 50 20	 call	 QWORD PTR [rax+32]
$LN4@mismatchIs:

; 599  : 	}
; 600  : 
; 601  : 	/// if current token is consistent with what could come after set
; 602  : 	/// then we know we're missing a token; error recovery is free to
; 603  : 	/// "insert" the missing token
; 604  : 	///
; 605  : 	/// BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
; 606  : 	/// in follow set to indicate that the fall of the start symbol is
; 607  : 	/// in the set (EOF can follow).
; 608  : 	///
; 609  : 	if	(		followClone->isMember(followClone, is->_LA(is, 1))
; 610  : 			||	followClone->isMember(followClone, ANTLR3_EOR_TOKEN_TYPE)

  000bb	ba 01 00 00 00	 mov	 edx, 1
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR is$[rsp]
  000c5	48 8b 44 24 58	 mov	 rax, QWORD PTR is$[rsp]
  000ca	ff 50 30	 call	 QWORD PTR [rax+48]
  000cd	8b d0		 mov	 edx, eax
  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  000d4	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  000d9	ff 50 48	 call	 QWORD PTR [rax+72]
  000dc	0f b6 c0	 movzx	 eax, al
  000df	85 c0		 test	 eax, eax
  000e1	75 19		 jne	 SHORT $LN8@mismatchIs
  000e3	ba 01 00 00 00	 mov	 edx, 1
  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  000f2	ff 50 48	 call	 QWORD PTR [rax+72]
  000f5	0f b6 c0	 movzx	 eax, al
  000f8	85 c0		 test	 eax, eax
  000fa	74 07		 je	 SHORT $LN6@mismatchIs
$LN8@mismatchIs:

; 611  : 		)
; 612  : 	{
; 613  : 		retcode = ANTLR3_TRUE;

  000fc	c6 44 24 20 01	 mov	 BYTE PTR retcode$[rsp], 1

; 614  : 	}

  00101	eb 05		 jmp	 SHORT $LN7@mismatchIs
$LN6@mismatchIs:

; 615  : 	else
; 616  : 	{
; 617  : 		retcode	= ANTLR3_FALSE;

  00103	c6 44 24 20 00	 mov	 BYTE PTR retcode$[rsp], 0
$LN7@mismatchIs:

; 618  : 	}
; 619  : 
; 620  : 	if	(viableTokensFollowingThisRule != NULL)

  00108	48 83 7c 24 30
	00		 cmp	 QWORD PTR viableTokensFollowingThisRule$[rsp], 0
  0010e	74 0d		 je	 SHORT $LN9@mismatchIs

; 621  : 	{
; 622  : 		viableTokensFollowingThisRule->free(viableTokensFollowingThisRule);

  00110	48 8b 4c 24 30	 mov	 rcx, QWORD PTR viableTokensFollowingThisRule$[rsp]
  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR viableTokensFollowingThisRule$[rsp]
  0011a	ff 50 70	 call	 QWORD PTR [rax+112]
$LN9@mismatchIs:

; 623  : 	}
; 624  : 	if	(followClone != NULL)

  0011d	48 83 7c 24 28
	00		 cmp	 QWORD PTR followClone$[rsp], 0
  00123	74 0d		 je	 SHORT $LN10@mismatchIs

; 625  : 	{
; 626  : 		followClone->free(followClone);

  00125	48 8b 4c 24 28	 mov	 rcx, QWORD PTR followClone$[rsp]
  0012a	48 8b 44 24 28	 mov	 rax, QWORD PTR followClone$[rsp]
  0012f	ff 50 70	 call	 QWORD PTR [rax+112]
$LN10@mismatchIs:

; 627  : 	}
; 628  : 
; 629  : 	return retcode;

  00132	0f b6 44 24 20	 movzx	 eax, BYTE PTR retcode$[rsp]
$LN1@mismatchIs:

; 630  : 
; 631  : }

  00137	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
mismatchIsMissingToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT mismatchIsUnwantedToken
_TEXT	SEGMENT
nextt$ = 32
recognizer$ = 64
is$ = 72
ttype$ = 80
mismatchIsUnwantedToken PROC				; COMDAT

; 530  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 531  : 	ANTLR3_UINT32 nextt;
; 532  : 
; 533  : 	nextt = is->_LA(is, 2);

  00014	ba 02 00 00 00	 mov	 edx, 2
  00019	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  0001e	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  00023	ff 50 30	 call	 QWORD PTR [rax+48]
  00026	89 44 24 20	 mov	 DWORD PTR nextt$[rsp], eax

; 534  : 
; 535  : 	if	(nextt == ttype)

  0002a	8b 44 24 50	 mov	 eax, DWORD PTR ttype$[rsp]
  0002e	39 44 24 20	 cmp	 DWORD PTR nextt$[rsp], eax
  00032	75 2a		 jne	 SHORT $LN2@mismatchIs

; 536  : 	{
; 537  : 		if	(recognizer->state->exception != NULL)

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00039	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00042	74 14		 je	 SHORT $LN4@mismatchIs

; 538  : 		{
; 539  : 			recognizer->state->exception->expecting = nextt;

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR recognizer$[rsp]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00051	8b 4c 24 20	 mov	 ecx, DWORD PTR nextt$[rsp]
  00055	89 48 38	 mov	 DWORD PTR [rax+56], ecx
$LN4@mismatchIs:

; 540  : 		}
; 541  : 		return ANTLR3_TRUE;		// This token is unknown, but the next one is the one we wanted

  00058	b0 01		 mov	 al, 1
  0005a	eb 04		 jmp	 SHORT $LN1@mismatchIs

; 542  : 	}

  0005c	eb 02		 jmp	 SHORT $LN3@mismatchIs
$LN2@mismatchIs:

; 543  : 	else
; 544  : 	{
; 545  : 		return ANTLR3_FALSE;	// Neither this token, nor the one following is the one we wanted

  0005e	32 c0		 xor	 al, al
$LN3@mismatchIs:
$LN1@mismatchIs:

; 546  : 	}
; 547  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
mismatchIsUnwantedToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT mismatch
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
tv69 = 56
recognizer$ = 80
ttype$ = 88
follow$ = 96
mismatch PROC						; COMDAT

; 643  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 644  :     pANTLR3_PARSER	    parser;
; 645  :     pANTLR3_TREE_PARSER	    tparser;
; 646  :     pANTLR3_INT_STREAM	    is;
; 647  : 
; 648  :     // Install a mismatched token exception in the exception stack
; 649  :     //
; 650  :     antlr3MTExceptionNew(recognizer);

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00018	e8 00 00 00 00	 call	 antlr3MTExceptionNew

; 651  :     recognizer->state->exception->expecting    = ttype;

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00022	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002a	8b 4c 24 58	 mov	 ecx, DWORD PTR ttype$[rsp]
  0002e	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 652  : 
; 653  :     switch	(recognizer->type)

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00036	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00039	89 44 24 38	 mov	 DWORD PTR tv69[rsp], eax
  0003d	83 7c 24 38 02	 cmp	 DWORD PTR tv69[rsp], 2
  00042	74 02		 je	 SHORT $LN4@mismatch
  00044	eb 2a		 jmp	 SHORT $LN5@mismatch
$LN4@mismatch:

; 654  :     {
; 655  : 		case	ANTLR3_TYPE_PARSER:
; 656  : 
; 657  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 658  : 			tparser	= NULL;

  00053	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 659  : 			is	= parser->tstream->istream;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  00061	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00065	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00069	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 660  : 
; 661  : 			break;

  0006e	eb 1f		 jmp	 SHORT $LN2@mismatch
$LN5@mismatch:

; 662  : 
; 663  : 		default:
; 664  : 		    
; 665  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'mismatch' called by unknown parser type - provide override for this function\n");

  00070	b9 02 00 00 00	 mov	 ecx, 2
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 fprintf

; 666  : 			return;

  0008a	e9 ae 00 00 00	 jmp	 $LN1@mismatch
$LN2@mismatch:

; 667  : 
; 668  : 			break;
; 669  :     }
; 670  : 
; 671  : 	if	(mismatchIsUnwantedToken(recognizer, is, ttype))

  0008f	44 8b 44 24 58	 mov	 r8d, DWORD PTR ttype$[rsp]
  00094	48 8b 54 24 30	 mov	 rdx, QWORD PTR is$[rsp]
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0009e	e8 00 00 00 00	 call	 mismatchIsUnwantedToken
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	85 c0		 test	 eax, eax
  000a8	74 37		 je	 SHORT $LN6@mismatch

; 672  : 	{
; 673  : 		// Create a basic recognition exception structure
; 674  : 		//
; 675  : 	    antlr3RecognitionExceptionNew(recognizer);

  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000af	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew

; 676  : 		
; 677  : 		// Now update it to indicate this is an unwanted token exception
; 678  : 		//
; 679  : 		recognizer->state->exception->name		= ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000bd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@
  000c8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 680  : 		recognizer->state->exception->type		= ANTLR3_UNWANTED_TOKEN_EXCEPTION;

  000cc	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d9	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 681  : 
; 682  : 		return;

  000df	eb 5c		 jmp	 SHORT $LN1@mismatch
$LN6@mismatch:

; 683  : 	}
; 684  : 	
; 685  : 	if	(mismatchIsMissingToken(recognizer, is, follow))

  000e1	4c 8b 44 24 60	 mov	 r8, QWORD PTR follow$[rsp]
  000e6	48 8b 54 24 30	 mov	 rdx, QWORD PTR is$[rsp]
  000eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000f0	e8 00 00 00 00	 call	 mismatchIsMissingToken
  000f5	0f b6 c0	 movzx	 eax, al
  000f8	85 c0		 test	 eax, eax
  000fa	74 37		 je	 SHORT $LN7@mismatch

; 686  : 	{
; 687  : 		// Create a basic recognition exception structure
; 688  : 		//
; 689  : 	    antlr3RecognitionExceptionNew(recognizer);

  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00101	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew

; 690  : 		
; 691  : 		// Now update it to indicate this is an unwanted token exception
; 692  : 		//
; 693  : 		recognizer->state->exception->name		= ANTLR3_MISSING_TOKEN_EXCEPTION_NAME;

  00106	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@
  0011a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 694  : 		recognizer->state->exception->type		= ANTLR3_MISSING_TOKEN_EXCEPTION;

  0011e	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00123	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00127	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0012b	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 695  : 
; 696  : 		return;

  00131	eb 0a		 jmp	 SHORT $LN1@mismatch
$LN7@mismatch:

; 697  : 	}
; 698  : 
; 699  : 	// Just a mismatched token is all we can dtermine
; 700  : 	//
; 701  : 	antlr3MTExceptionNew(recognizer);

  00133	48 8b 4c 24 50	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00138	e8 00 00 00 00	 call	 antlr3MTExceptionNew
$LN1@mismatch:

; 702  : 
; 703  : 	return;
; 704  : }

  0013d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00141	5f		 pop	 rdi
  00142	c3		 ret	 0
mismatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT matchAny
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
tv65 = 56
recognizer$ = 80
matchAny PROC						; COMDAT

; 490  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 491  :     pANTLR3_PARSER	    parser;
; 492  :     pANTLR3_TREE_PARSER	    tparser;
; 493  :     pANTLR3_INT_STREAM	    is;
; 494  : 
; 495  :     switch	(recognizer->type)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	89 44 24 38	 mov	 DWORD PTR tv65[rsp], eax
  00016	83 7c 24 38 02	 cmp	 DWORD PTR tv65[rsp], 2
  0001b	74 09		 je	 SHORT $LN4@matchAny
  0001d	83 7c 24 38 04	 cmp	 DWORD PTR tv65[rsp], 4
  00022	74 2c		 je	 SHORT $LN5@matchAny
  00024	eb 58		 jmp	 SHORT $LN6@matchAny
$LN4@matchAny:

; 496  :     {
; 497  : 		case	ANTLR3_TYPE_PARSER:
; 498  : 
; 499  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 500  : 			tparser	= NULL;

  00033	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 501  : 			is	= parser->tstream->istream;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 502  : 
; 503  : 			break;

  0004e	eb 4a		 jmp	 SHORT $LN2@matchAny
$LN5@matchAny:

; 504  : 
; 505  : 		case	ANTLR3_TYPE_TREE_PARSER:
; 506  : 
; 507  : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 89 44 24 28	 mov	 QWORD PTR tparser$[rsp], rax

; 508  : 			parser	= NULL;

  0005d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 509  : 			is	= tparser->ctnstream->tnstream->istream;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR tparser$[rsp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00073	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00077	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 510  : 
; 511  : 			break;

  0007c	eb 1c		 jmp	 SHORT $LN2@matchAny
$LN6@matchAny:

; 512  : 
; 513  : 		default:
; 514  : 		    
; 515  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'matchAny' called by unknown parser type - provide override for this function\n");

  0007e	b9 02 00 00 00	 mov	 ecx, 2
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 fprintf

; 516  : 			return;

  00098	eb 27		 jmp	 SHORT $LN1@matchAny
$LN2@matchAny:

; 517  : 
; 518  : 		break;
; 519  :     }
; 520  :     recognizer->state->errorRecovery	= ANTLR3_FALSE;

  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  0009f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a3	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 521  :     recognizer->state->failed		    = ANTLR3_FALSE;

  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ac	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b0	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 522  :     is->consume(is);

  000b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  000be	ff 50 28	 call	 QWORD PTR [rax+40]
$LN1@matchAny:

; 523  : 
; 524  :     return;
; 525  : }

  000c1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
matchAny ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT match
_TEXT	SEGMENT
parser$ = 32
tparser$ = 40
is$ = 48
matchedSymbol$ = 56
tv65 = 64
recognizer$ = 96
ttype$ = 104
follow$ = 112
match	PROC						; COMDAT

; 417  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 418  :     pANTLR3_PARSER			parser;
; 419  :     pANTLR3_TREE_PARSER	    tparser;
; 420  :     pANTLR3_INT_STREAM	    is;
; 421  : 	void					* matchedSymbol;
; 422  : 
; 423  :     switch	(recognizer->type)

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001b	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  0001f	83 7c 24 40 02	 cmp	 DWORD PTR tv65[rsp], 2
  00024	74 09		 je	 SHORT $LN4@match
  00026	83 7c 24 40 04	 cmp	 DWORD PTR tv65[rsp], 4
  0002b	74 2c		 je	 SHORT $LN5@match
  0002d	eb 58		 jmp	 SHORT $LN6@match
$LN4@match:

; 424  :     {
; 425  : 		case	ANTLR3_TYPE_PARSER:
; 426  : 
; 427  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 20	 mov	 QWORD PTR parser$[rsp], rax

; 428  : 			tparser	= NULL;

  0003c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 429  : 			is	= parser->tstream->istream;

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR parser$[rsp]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00052	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 430  : 
; 431  : 			break;

  00057	eb 4f		 jmp	 SHORT $LN2@match
$LN5@match:

; 432  : 
; 433  : 		case	ANTLR3_TYPE_TREE_PARSER:
; 434  : 
; 435  : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00059	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 89 44 24 28	 mov	 QWORD PTR tparser$[rsp], rax

; 436  : 			parser	= NULL;

  00066	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 437  : 			is	= tparser->ctnstream->tnstream->istream;

  0006f	48 8b 44 24 28	 mov	 rax, QWORD PTR tparser$[rsp]
  00074	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00080	48 89 44 24 30	 mov	 QWORD PTR is$[rsp], rax

; 438  : 
; 439  : 			break;

  00085	eb 21		 jmp	 SHORT $LN2@match
$LN6@match:

; 440  : 
; 441  : 		default:
; 442  : 		    
; 443  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'match' called by unknown parser type - provide override for this function\n");

  00087	b9 02 00 00 00	 mov	 ecx, 2
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 fprintf

; 444  : 			return ANTLR3_FALSE;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 a6 00 00 00	 jmp	 $LN1@match
$LN2@match:

; 445  : 
; 446  : 			break;
; 447  :     }
; 448  : 
; 449  : 	// Pick up the current input token/node for assignment to labels
; 450  : 	//
; 451  : 	matchedSymbol = recognizer->getCurrentInputSymbol(recognizer, is);

  000a8	48 8b 54 24 30	 mov	 rdx, QWORD PTR is$[rsp]
  000ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  000b2	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b7	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  000bd	48 89 44 24 38	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 452  : 
; 453  :     if	(is->_LA(is, 1) == ttype)

  000c2	ba 01 00 00 00	 mov	 edx, 1
  000c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  000d1	ff 50 30	 call	 QWORD PTR [rax+48]
  000d4	3b 44 24 68	 cmp	 eax, DWORD PTR ttype$[rsp]
  000d8	75 2e		 jne	 SHORT $LN7@match

; 454  :     {
; 455  : 		// The token was the one we were told to expect
; 456  : 		//
; 457  : 		is->consume(is);									// Consume that token from the stream

  000da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  000e4	ff 50 28	 call	 QWORD PTR [rax+40]

; 458  : 		recognizer->state->errorRecovery	= ANTLR3_FALSE;	// Not in error recovery now (if we were)

  000e7	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ec	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f0	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 459  : 		recognizer->state->failed			= ANTLR3_FALSE;	// The match was a success

  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  000f9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fd	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 460  : 		return matchedSymbol;								// We are done

  00101	48 8b 44 24 38	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  00106	eb 46		 jmp	 SHORT $LN1@match
$LN7@match:

; 461  :     }
; 462  : 
; 463  :     // We did not find the expected token type, if we are backtracking then
; 464  :     // we just set the failed flag and return.
; 465  :     //
; 466  :     if	(recognizer->state->backtracking > 0)

  00108	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0010d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00111	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00115	7e 14		 jle	 SHORT $LN8@match

; 467  :     {
; 468  : 		// Backtracking is going on
; 469  : 		//
; 470  : 		recognizer->state->failed  = ANTLR3_TRUE;

  00117	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0011c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00120	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 471  : 		return matchedSymbol;

  00124	48 8b 44 24 38	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
  00129	eb 23		 jmp	 SHORT $LN1@match
$LN8@match:

; 472  : 	}
; 473  : 
; 474  :     // We did not find the expected token and there is no backtracking
; 475  :     // going on, so we mismatch, which creates an exception in the recognizer exception
; 476  :     // stack.
; 477  :     //
; 478  : 	matchedSymbol = recognizer->recoverFromMismatchedToken(recognizer, ttype, follow);

  0012b	4c 8b 44 24 70	 mov	 r8, QWORD PTR follow$[rsp]
  00130	8b 54 24 68	 mov	 edx, DWORD PTR ttype$[rsp]
  00134	48 8b 4c 24 60	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00139	48 8b 44 24 60	 mov	 rax, QWORD PTR recognizer$[rsp]
  0013e	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00144	48 89 44 24 38	 mov	 QWORD PTR matchedSymbol$[rsp], rax

; 479  :     return matchedSymbol;

  00149	48 8b 44 24 38	 mov	 rax, QWORD PTR matchedSymbol$[rsp]
$LN1@match:

; 480  : }

  0014e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00152	5f		 pop	 rdi
  00153	c3		 ret	 0
match	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT endBacktrack
_TEXT	SEGMENT
recognizer$ = 48
level$ = 56
successful$ = 64
endBacktrack PROC					; COMDAT

; 761  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 762  : 	if	(recognizer->debugger != NULL)

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00018	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0001d	74 22		 je	 SHORT $LN2@endBacktra

; 763  : 	{
; 764  : 		recognizer->debugger->endBacktrack(recognizer->debugger, level, successful);

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00024	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00028	44 0f b6 44 24
	40		 movzx	 r8d, BYTE PTR successful$[rsp]
  0002e	8b 54 24 38	 mov	 edx, DWORD PTR level$[rsp]
  00032	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00037	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003b	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
$LN2@endBacktra:

; 765  : 	}
; 766  : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
endBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT beginBacktrack
_TEXT	SEGMENT
recognizer$ = 48
level$ = 56
beginBacktrack PROC					; COMDAT

; 752  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 753  : 	if	(recognizer->debugger != NULL)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00013	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00018	74 1c		 je	 SHORT $LN2@beginBackt

; 754  : 	{
; 755  : 		recognizer->debugger->beginBacktrack(recognizer->debugger, level);

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00023	8b 54 24 38	 mov	 edx, DWORD PTR level$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0002c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00030	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]
$LN2@beginBackt:

; 756  : 	}
; 757  : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
beginBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT endResync
_TEXT	SEGMENT
recognizer$ = 48
endResync PROC						; COMDAT

; 778  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 779  : 	if	(recognizer->debugger != NULL)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00014	74 18		 je	 SHORT $LN2@endResync

; 780  : 	{
; 781  : 		recognizer->debugger->endResync(recognizer->debugger);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00024	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00028	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
$LN2@endResync:

; 782  : 	}
; 783  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
endResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT computeErrorRecoverySet
_TEXT	SEGMENT
recognizer$ = 48
computeErrorRecoverySet PROC				; COMDAT

; 880  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 881  :     return   recognizer->combineFollows(recognizer, ANTLR3_FALSE);

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00016	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 882  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
computeErrorRecoverySet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT beginResync
_TEXT	SEGMENT
recognizer$ = 48
beginResync PROC					; COMDAT

; 769  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 770  : 	if	(recognizer->debugger != NULL)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0000f	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00014	74 18		 je	 SHORT $LN2@beginResyn

; 771  : 	{
; 772  : 		recognizer->debugger->beginResync(recognizer->debugger);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00024	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00028	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]
$LN2@beginResyn:

; 773  : 	}
; 774  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
beginResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT antlr3MTExceptionNew
_TEXT	SEGMENT
recognizer$ = 48
antlr3MTExceptionNew PROC				; COMDAT

; 255  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 256  :     /* Create a basic recognition exception structure
; 257  :      */
; 258  :     antlr3RecognitionExceptionNew(recognizer);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recognizer$[rsp]
  0000f	e8 00 00 00 00	 call	 antlr3RecognitionExceptionNew

; 259  : 
; 260  :     /* Now update it to indicate this is a Mismatched token exception
; 261  :      */
; 262  :     recognizer->state->exception->name		= ANTLR3_MISMATCHED_EX_NAME;

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00019	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@
  00028	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 263  :     recognizer->state->exception->type		= ANTLR3_MISMATCHED_TOKEN_EXCEPTION;

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR recognizer$[rsp]
  00031	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 264  : 
; 265  :     return;
; 266  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
antlr3MTExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT antlr3RecognitionExceptionNew
_TEXT	SEGMENT
ex$ = 32
lexer$ = 40
parser$ = 48
tparser$ = 56
ins$ = 64
is$ = 72
cts$ = 80
tns$ = 88
tnode$1 = 96
tv65 = 104
tv92 = 108
tv253 = 112
tv243 = 120
recognizer$ = 144
antlr3RecognitionExceptionNew PROC			; COMDAT

; 270  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 271  : 	pANTLR3_EXCEPTION				ex;
; 272  : 	pANTLR3_LEXER					lexer;
; 273  : 	pANTLR3_PARSER					parser;
; 274  : 	pANTLR3_TREE_PARSER				tparser;
; 275  : 
; 276  : 	pANTLR3_INPUT_STREAM			ins;
; 277  : 	pANTLR3_INT_STREAM				is;
; 278  : 	pANTLR3_COMMON_TOKEN_STREAM	    cts;
; 279  : 	pANTLR3_TREE_NODE_STREAM	    tns;
; 280  : 
; 281  : 	ins	    = NULL;

  0000d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR ins$[rsp], 0

; 282  : 	cts	    = NULL;

  00016	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR cts$[rsp], 0

; 283  : 	tns	    = NULL;

  0001f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tns$[rsp], 0

; 284  : 	is	    = NULL;

  00028	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR is$[rsp], 0

; 285  : 	lexer   = NULL;

  00031	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR lexer$[rsp], 0

; 286  : 	parser  = NULL;

  0003a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR parser$[rsp], 0

; 287  : 	tparser = NULL;

  00043	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tparser$[rsp], 0

; 288  : 
; 289  : 	switch	(recognizer->type)

  0004c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00054	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00057	89 44 24 68	 mov	 DWORD PTR tv65[rsp], eax
  0005b	83 7c 24 68 01	 cmp	 DWORD PTR tv65[rsp], 1
  00060	74 13		 je	 SHORT $LN6@antlr3Reco
  00062	83 7c 24 68 02	 cmp	 DWORD PTR tv65[rsp], 2
  00067	74 3c		 je	 SHORT $LN7@antlr3Reco
  00069	83 7c 24 68 04	 cmp	 DWORD PTR tv65[rsp], 4
  0006e	74 6b		 je	 SHORT $LN8@antlr3Reco
  00070	e9 98 00 00 00	 jmp	 $LN9@antlr3Reco
$LN6@antlr3Reco:

; 290  : 	{
; 291  : 	case	ANTLR3_TYPE_LEXER:
; 292  : 
; 293  : 		lexer	= (pANTLR3_LEXER) (recognizer->super);

  00075	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0007d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00080	48 89 44 24 28	 mov	 QWORD PTR lexer$[rsp], rax

; 294  : 		ins	= lexer->input;

  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$[rsp]
  0008a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008e	48 89 44 24 40	 mov	 QWORD PTR ins$[rsp], rax

; 295  : 		is	= ins->istream;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR ins$[rsp]
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 89 44 24 48	 mov	 QWORD PTR is$[rsp], rax

; 296  : 
; 297  : 		break;

  000a0	e9 87 00 00 00	 jmp	 $LN2@antlr3Reco
$LN7@antlr3Reco:

; 298  : 
; 299  : 	case	ANTLR3_TYPE_PARSER:
; 300  : 
; 301  : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  000a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	48 89 44 24 30	 mov	 QWORD PTR parser$[rsp], rax

; 302  : 		cts	= (pANTLR3_COMMON_TOKEN_STREAM)(parser->tstream->super);

  000b5	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  000ba	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000be	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c2	48 89 44 24 50	 mov	 QWORD PTR cts$[rsp], rax

; 303  : 		is	= parser->tstream->istream;

  000c7	48 8b 44 24 30	 mov	 rax, QWORD PTR parser$[rsp]
  000cc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d4	48 89 44 24 48	 mov	 QWORD PTR is$[rsp], rax

; 304  : 
; 305  : 		break;

  000d9	eb 51		 jmp	 SHORT $LN2@antlr3Reco
$LN8@antlr3Reco:

; 306  : 
; 307  : 	case	ANTLR3_TYPE_TREE_PARSER:
; 308  : 
; 309  : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  000db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e6	48 89 44 24 38	 mov	 QWORD PTR tparser$[rsp], rax

; 310  : 		tns	= tparser->ctnstream->tnstream;

  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR tparser$[rsp]
  000f0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f8	48 89 44 24 58	 mov	 QWORD PTR tns$[rsp], rax

; 311  : 		is	= tns->istream;

  000fd	48 8b 44 24 58	 mov	 rax, QWORD PTR tns$[rsp]
  00102	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00106	48 89 44 24 48	 mov	 QWORD PTR is$[rsp], rax

; 312  : 
; 313  : 		break;

  0010b	eb 1f		 jmp	 SHORT $LN2@antlr3Reco
$LN9@antlr3Reco:

; 314  : 
; 315  : 	default:
; 316  : 
; 317  : 		ANTLR3_FPRINTF(stderr, "Base recognizer function antlr3RecognitionExceptionNew called by unknown parser type - provide override for this function\n");

  0010d	b9 02 00 00 00	 mov	 ecx, 2
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@
  0011f	48 8b c8	 mov	 rcx, rax
  00122	e8 00 00 00 00	 call	 fprintf

; 318  : 		return;

  00127	e9 0e 03 00 00	 jmp	 $LN1@antlr3Reco
$LN2@antlr3Reco:

; 319  : 
; 320  : 		break;
; 321  : 	}
; 322  : 
; 323  : 	/* Create a basic exception structure
; 324  : 	 */
; 325  : 	ex = antlr3ExceptionNew(ANTLR3_RECOGNITION_EXCEPTION,

  0012c	45 33 c9	 xor	 r9d, r9d
  0012f	45 33 c0	 xor	 r8d, r8d
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@
  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	e8 00 00 00 00	 call	 antlr3ExceptionNew
  00143	48 89 44 24 20	 mov	 QWORD PTR ex$[rsp], rax

; 326  : 		(void *)ANTLR3_RECOGNITION_EX_NAME,
; 327  : 		NULL,
; 328  : 		ANTLR3_FALSE);
; 329  : 
; 330  : 	/* Rest of information depends on the base type of the 
; 331  : 	 * input stream.
; 332  : 	 */
; 333  : 	switch  (is->type & ANTLR3_INPUT_MASK)

  00148	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  0014d	8b 00		 mov	 eax, DWORD PTR [rax]
  0014f	83 e0 07	 and	 eax, 7
  00152	89 44 24 6c	 mov	 DWORD PTR tv92[rsp], eax
  00156	83 7c 24 6c 01	 cmp	 DWORD PTR tv92[rsp], 1
  0015b	74 1b		 je	 SHORT $LN10@antlr3Reco
  0015d	83 7c 24 6c 02	 cmp	 DWORD PTR tv92[rsp], 2
  00162	0f 84 97 00 00
	00		 je	 $LN11@antlr3Reco
  00168	83 7c 24 6c 04	 cmp	 DWORD PTR tv92[rsp], 4
  0016d	0f 84 67 01 00
	00		 je	 $LN14@antlr3Reco
  00173	e9 77 02 00 00	 jmp	 $LN4@antlr3Reco
$LN10@antlr3Reco:

; 334  : 	{
; 335  : 	case    ANTLR3_CHARSTREAM:
; 336  : 
; 337  : 		ex->c			= is->_LA		    	(is, 1);					/* Current input character			*/

  00178	ba 01 00 00 00	 mov	 edx, 1
  0017d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  00182	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  00187	ff 50 30	 call	 QWORD PTR [rax+48]
  0018a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0018f	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 338  : 		ex->line		= ins->getLine			(ins);						/* Line number comes from stream		*/

  00192	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ins$[rsp]
  00197	48 8b 44 24 40	 mov	 rax, QWORD PTR ins$[rsp]
  0019c	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  001a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001a7	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 339  : 		ex->charPositionInLine	= ins->getCharPositionInLine	(ins);	    /* Line offset also comes from the stream   */

  001aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ins$[rsp]
  001af	48 8b 44 24 40	 mov	 rax, QWORD PTR ins$[rsp]
  001b4	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  001ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001bf	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 340  : 		ex->index		= is->index			(is);

  001c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  001c7	48 8b 44 24 48	 mov	 rax, QWORD PTR is$[rsp]
  001cc	ff 50 40	 call	 QWORD PTR [rax+64]
  001cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  001d4	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 341  : 		ex->streamName		= ins->fileName;

  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  001dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ins$[rsp]
  001e2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001e6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 342  : 		ex->message		= "Unexpected character";

  001ea	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@BIIJEBMB@Unexpected?5character@
  001f6	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 343  : 		break;

  001fa	e9 f0 01 00 00	 jmp	 $LN4@antlr3Reco
$LN11@antlr3Reco:

; 344  : 
; 345  : 	case    ANTLR3_TOKENSTREAM:
; 346  : 
; 347  : 		ex->token		= cts->tstream->_LT						(cts->tstream, 1);	    /* Current input token			    */

  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR cts$[rsp]
  00204	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00207	ba 01 00 00 00	 mov	 edx, 1
  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cts$[rsp]
  00211	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00214	ff 50 28	 call	 QWORD PTR [rax+40]
  00217	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0021c	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 348  : 		ex->line		= ((pANTLR3_COMMON_TOKEN)(ex->token))->getLine			(ex->token);

  00220	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00225	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00229	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0022e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00232	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  00238	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0023d	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 349  : 		ex->charPositionInLine	= ((pANTLR3_COMMON_TOKEN)(ex->token))->getCharPositionInLine	(ex->token);

  00240	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00245	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00249	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0024e	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00252	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00258	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0025d	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 350  : 		ex->index		= cts->tstream->istream->index					(cts->tstream->istream);

  00260	48 8b 44 24 50	 mov	 rax, QWORD PTR cts$[rsp]
  00265	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00268	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cts$[rsp]
  0026d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00270	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00274	48 89 4c 24 70	 mov	 QWORD PTR tv253[rsp], rcx
  00279	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0027d	48 8b 44 24 70	 mov	 rax, QWORD PTR tv253[rsp]
  00282	ff 50 40	 call	 QWORD PTR [rax+64]
  00285	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0028a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 351  : 		if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)

  0028e	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00293	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00297	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  0029a	75 0f		 jne	 SHORT $LN12@antlr3Reco

; 352  : 		{
; 353  : 			ex->streamName		= NULL;

  0029c	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002a1	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 354  : 		}

  002a9	eb 1a		 jmp	 SHORT $LN13@antlr3Reco
$LN12@antlr3Reco:

; 355  : 		else
; 356  : 		{
; 357  : 			ex->streamName		= ((pANTLR3_COMMON_TOKEN)(ex->token))->input->fileName;

  002ab	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002b0	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002b4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  002bd	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002c1	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN13@antlr3Reco:

; 358  : 		}
; 359  : 		ex->message		= "Unexpected token";

  002c5	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FKAIECKK@Unexpected?5token@
  002d1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 360  : 		break;

  002d5	e9 15 01 00 00	 jmp	 $LN4@antlr3Reco
$LN14@antlr3Reco:

; 361  : 
; 362  : 	case    ANTLR3_COMMONTREENODE:
; 363  : 
; 364  : 		ex->token		= tns->_LT						    (tns, 1);	    /* Current input tree node			    */

  002da	ba 01 00 00 00	 mov	 edx, 1
  002df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tns$[rsp]
  002e4	48 8b 44 24 58	 mov	 rax, QWORD PTR tns$[rsp]
  002e9	ff 50 10	 call	 QWORD PTR [rax+16]
  002ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  002f1	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 365  : 		ex->line		= ((pANTLR3_BASE_TREE)(ex->token))->getLine		    (ex->token);

  002f5	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  002fa	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  002fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00303	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00307	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  0030d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00312	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 366  : 		ex->charPositionInLine	= ((pANTLR3_BASE_TREE)(ex->token))->getCharPositionInLine   (ex->token);

  00315	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  0031a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0031e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00323	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00327	ff 50 68	 call	 QWORD PTR [rax+104]
  0032a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0032f	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 367  : 		ex->index		= tns->istream->index					    (tns->istream);

  00332	48 8b 44 24 58	 mov	 rax, QWORD PTR tns$[rsp]
  00337	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0033b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tns$[rsp]
  00340	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00344	ff 50 40	 call	 QWORD PTR [rax+64]
  00347	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0034c	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 368  : 
; 369  : 		// Are you ready for this? Deep breath now...
; 370  : 		//
; 371  : 		{
; 372  : 			pANTLR3_COMMON_TREE tnode;
; 373  : 
; 374  : 			tnode		= ((pANTLR3_COMMON_TREE)(((pANTLR3_BASE_TREE)(ex->token))->super));

  00350	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00355	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00359	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035c	48 89 44 24 60	 mov	 QWORD PTR tnode$1[rsp], rax

; 375  : 
; 376  : 			if	(tnode->token    == NULL)

  00361	48 8b 44 24 60	 mov	 rax, QWORD PTR tnode$1[rsp]
  00366	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0036b	75 39		 jne	 SHORT $LN15@antlr3Reco

; 377  : 			{
; 378  : 				ex->streamName = ((pANTLR3_BASE_TREE)(ex->token))->strFactory->newStr(((pANTLR3_BASE_TREE)(ex->token))->strFactory, (pANTLR3_UINT8)"-unknown source-");

  0036d	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  00372	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00376	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0037b	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0037f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00383	48 89 4c 24 78	 mov	 QWORD PTR tv243[rsp], rcx
  00388	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@DHPGECBL@?9unknown?5source?9@
  0038f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00393	48 8b 44 24 78	 mov	 rax, QWORD PTR tv243[rsp]
  00398	ff 50 30	 call	 QWORD PTR [rax+48]
  0039b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  003a0	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 379  : 			}

  003a4	eb 39		 jmp	 SHORT $LN16@antlr3Reco
$LN15@antlr3Reco:

; 380  : 			else
; 381  : 			{
; 382  : 				if	(tnode->token->input == NULL)

  003a6	48 8b 44 24 60	 mov	 rax, QWORD PTR tnode$1[rsp]
  003ab	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003af	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  003b4	75 0f		 jne	 SHORT $LN17@antlr3Reco

; 383  : 				{
; 384  : 					ex->streamName		= NULL;

  003b6	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  003bb	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 385  : 				}

  003c3	eb 1a		 jmp	 SHORT $LN18@antlr3Reco
$LN17@antlr3Reco:

; 386  : 				else
; 387  : 				{
; 388  : 					ex->streamName		= tnode->token->input->fileName;

  003c5	48 8b 44 24 60	 mov	 rax, QWORD PTR tnode$1[rsp]
  003ca	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003ce	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  003d7	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  003db	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN18@antlr3Reco:
$LN16@antlr3Reco:

; 389  : 				}
; 390  : 			}
; 391  : 			ex->message		= "Unexpected node";

  003df	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  003e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@IGJLDFLP@Unexpected?5node@
  003eb	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN4@antlr3Reco:

; 392  : 		}
; 393  : 		break;
; 394  : 	}
; 395  : 
; 396  : 	ex->input						= is;

  003ef	48 8b 44 24 20	 mov	 rax, QWORD PTR ex$[rsp]
  003f4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR is$[rsp]
  003f9	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 397  : 	ex->nextException				= recognizer->state->exception;	/* So we don't leak the memory */

  003fd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00405	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00409	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  0040e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00412	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 398  : 	recognizer->state->exception	= ex;

  00416	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0041e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00422	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ex$[rsp]
  00427	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 399  : 	recognizer->state->error	    = ANTLR3_TRUE;	    /* Exception is outstanding	*/

  0042b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  00433	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00437	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN1@antlr3Reco:

; 400  : 
; 401  : 	return;
; 402  : }

  0043a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00441	5f		 pop	 rdi
  00442	c3		 ret	 0
antlr3RecognitionExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Nix_LabN3\Nix_LabN1\libantlr3c-3.4\src\antlr3baserecognizer.c
;	COMDAT antlr3BaseRecognizerNew
_TEXT	SEGMENT
recognizer$ = 32
type$ = 64
sizeHint$ = 72
state$ = 80
antlr3BaseRecognizerNew PROC				; COMDAT

; 85   : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 86   :     pANTLR3_BASE_RECOGNIZER recognizer;
; 87   : 
; 88   :     // Allocate memory for the structure
; 89   :     //
; 90   :     recognizer	    = (pANTLR3_BASE_RECOGNIZER) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BASE_RECOGNIZER));

  00012	b9 28 01 00 00	 mov	 ecx, 296		; 00000128H
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001d	48 89 44 24 20	 mov	 QWORD PTR recognizer$[rsp], rax

; 91   : 
; 92   :     if	(recognizer == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR recognizer$[rsp], 0
  00028	75 07		 jne	 SHORT $LN2@antlr3Base

; 93   :     {
; 94   : 		// Allocation failed
; 95   : 		//
; 96   : 		return	NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 bb 03 00 00	 jmp	 $LN1@antlr3Base
$LN2@antlr3Base:

; 97   :     }
; 98   : 
; 99   : 	
; 100  : 	// If we have been supplied with a pre-existing recognizer state
; 101  : 	// then we just install it, otherwise we must create one from scratch
; 102  : 	//
; 103  : 	if	(state == NULL)

  00031	48 83 7c 24 50
	00		 cmp	 QWORD PTR state$[rsp], 0
  00037	0f 85 34 01 00
	00		 jne	 $LN3@antlr3Base

; 104  : 	{
; 105  : 		recognizer->state = (pANTLR3_RECOGNIZER_SHARED_STATE) ANTLR3_CALLOC(1, (size_t)sizeof(ANTLR3_RECOGNIZER_SHARED_STATE));

  0003d	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  00042	b9 01 00 00 00	 mov	 ecx, 1
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00052	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 106  : 
; 107  : 		if	(recognizer->state == NULL)

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0005b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00060	75 12		 jne	 SHORT $LN5@antlr3Base

; 108  : 		{
; 109  : 			ANTLR3_FREE(recognizer);

  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 110  : 			return	NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 78 03 00 00	 jmp	 $LN1@antlr3Base
$LN5@antlr3Base:

; 111  : 		}
; 112  : 
; 113  : 		// Initialize any new recognizer state
; 114  : 		//
; 115  : 		recognizer->state->errorRecovery	= ANTLR3_FALSE;

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00079	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007d	c6 40 20 00	 mov	 BYTE PTR [rax+32], 0

; 116  : 		recognizer->state->lastErrorIndex	= -1;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00086	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008a	48 c7 40 28 ff
	ff ff ff	 mov	 QWORD PTR [rax+40], -1

; 117  : 		recognizer->state->failed		= ANTLR3_FALSE;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00097	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009b	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 118  : 		recognizer->state->errorCount		= 0;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000a4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a8	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 119  : 		recognizer->state->backtracking		= 0;

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000b4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b8	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 120  : 		recognizer->state->following		= NULL;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000c4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c8	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 121  : 		recognizer->state->ruleMemo		= NULL;

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000d5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d9	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 122  : 		recognizer->state->tokenNames		= NULL;

  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000e6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ea	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 123  : 		recognizer->state->sizeHint             = sizeHint;

  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  000f7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fb	8b 4c 24 48	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  000ff	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 124  : 		recognizer->state->tokSource		= NULL;

  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00107	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0010b	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 125  :                 recognizer->state->tokFactory           = NULL;

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00118	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0011c	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 126  : 
; 127  : 		// Rather than check to see if we must initialize
; 128  : 		// the stack every time we are asked for an new rewrite stream
; 129  : 		// we just always create an empty stack and then just
; 130  : 		// free it when the base recognizer is freed.
; 131  : 		//
; 132  : 		recognizer->state->rStreams		= antlr3VectorNew(0);  // We don't know the size.

  00124	33 c9		 xor	 ecx, ecx
  00126	e8 00 00 00 00	 call	 antlr3VectorNew
  0012b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00130	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00134	48 89 81 b0 00
	00 00		 mov	 QWORD PTR [rcx+176], rax

; 133  : 
; 134  : 		if	(recognizer->state->rStreams == NULL)

  0013b	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00140	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00144	48 83 b8 b0 00
	00 00 00	 cmp	 QWORD PTR [rax+176], 0
  0014c	75 21		 jne	 SHORT $LN6@antlr3Base

; 135  : 		{
; 136  : 			// Out of memory
; 137  : 			//
; 138  : 			ANTLR3_FREE(recognizer->state);

  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00153	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 139  : 			ANTLR3_FREE(recognizer);

  0015d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR recognizer$[rsp]
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 140  : 			return	NULL;

  00168	33 c0		 xor	 eax, eax
  0016a	e9 7d 02 00 00	 jmp	 $LN1@antlr3Base
$LN6@antlr3Base:

; 141  : 		}
; 142  : 	}

  0016f	eb 0e		 jmp	 SHORT $LN4@antlr3Base
$LN3@antlr3Base:

; 143  : 	else
; 144  : 	{
; 145  : 		// Install the one we were given, and do not reset it here
; 146  : 		// as it will either already have been initialized or will
; 147  : 		// be in a state that needs to be preserved.
; 148  : 		//
; 149  : 		recognizer->state = state;

  00171	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00176	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0017b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN4@antlr3Base:

; 150  : 	}
; 151  : 		
; 152  :     // Install the BR API
; 153  :     //
; 154  :     recognizer->alreadyParsedRule           = alreadyParsedRule;

  0017f	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:alreadyParsedRule
  0018b	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 155  :     recognizer->beginResync                 = beginResync;

  00192	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginResync
  0019e	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 156  :     recognizer->combineFollows              = combineFollows;

  001a2	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:combineFollows
  001ae	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 157  :     recognizer->beginBacktrack              = beginBacktrack;

  001b5	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:beginBacktrack
  001c1	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 158  :     recognizer->endBacktrack                = endBacktrack;

  001c5	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endBacktrack
  001d1	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 159  :     recognizer->computeCSRuleFollow         = computeCSRuleFollow;

  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:computeCSRuleFollow
  001e4	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 160  :     recognizer->computeErrorRecoverySet     = computeErrorRecoverySet;

  001eb	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:computeErrorRecoverySet
  001f7	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 161  :     recognizer->consumeUntil                = consumeUntil;

  001fe	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeUntil
  0020a	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 162  :     recognizer->consumeUntilSet             = consumeUntilSet;

  00211	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:consumeUntilSet
  0021d	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 163  :     recognizer->displayRecognitionError     = displayRecognitionError;

  00224	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:displayRecognitionError
  00230	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 164  :     recognizer->endResync                   = endResync;

  00234	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:endResync
  00240	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 165  :     recognizer->exConstruct                 = antlr3MTExceptionNew;

  00244	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3MTExceptionNew
  00250	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 166  :     recognizer->getRuleInvocationStack      = getRuleInvocationStack;

  00257	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getRuleInvocationStack
  00263	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 167  :     recognizer->getRuleInvocationStackNamed = getRuleInvocationStackNamed;

  0026a	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getRuleInvocationStackNamed
  00276	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 168  :     recognizer->getRuleMemoization          = getRuleMemoization;

  0027d	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getRuleMemoization
  00289	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 169  :     recognizer->match                       = match;

  00290	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:match
  0029c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 170  :     recognizer->matchAny                    = matchAny;

  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchAny
  002ac	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 171  :     recognizer->memoize                     = memoize;

  002b0	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:memoize
  002bc	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 172  :     recognizer->mismatch                    = mismatch;

  002c3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mismatch
  002cf	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 173  :     recognizer->mismatchIsUnwantedToken     = mismatchIsUnwantedToken;

  002d3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mismatchIsUnwantedToken
  002df	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 174  :     recognizer->mismatchIsMissingToken      = mismatchIsMissingToken;

  002e3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mismatchIsMissingToken
  002ef	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 175  :     recognizer->recover                     = recover;

  002f3	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recover
  002ff	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 176  :     recognizer->recoverFromMismatchedElement= recoverFromMismatchedElement;

  00303	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recoverFromMismatchedElement
  0030f	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 177  :     recognizer->recoverFromMismatchedSet    = recoverFromMismatchedSet;

  00316	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recoverFromMismatchedSet
  00322	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 178  :     recognizer->recoverFromMismatchedToken  = recoverFromMismatchedToken;

  00329	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recoverFromMismatchedToken
  00335	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 179  :     recognizer->getNumberOfSyntaxErrors     = getNumberOfSyntaxErrors;

  0033c	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00341	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getNumberOfSyntaxErrors
  00348	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 180  :     recognizer->reportError                 = reportError;

  0034c	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00351	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reportError
  00358	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 181  :     recognizer->reset                       = reset;

  0035c	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reset
  00368	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 182  :     recognizer->synpred                     = synpred;

  0036f	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:synpred
  0037b	48 89 88 08 01
	00 00		 mov	 QWORD PTR [rax+264], rcx

; 183  :     recognizer->toStrings                   = toStrings;

  00382	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  00387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toStrings
  0038e	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 184  :     recognizer->getCurrentInputSymbol       = getCurrentInputSymbol;

  00395	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCurrentInputSymbol
  003a1	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 185  :     recognizer->getMissingSymbol            = getMissingSymbol;

  003a8	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getMissingSymbol
  003b4	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 186  :     recognizer->debugger                    = NULL;

  003bb	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003c0	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 187  : 
; 188  :     recognizer->free = freeBR;

  003c8	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeBR
  003d4	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 189  : 
; 190  :     /* Initialize variables
; 191  :      */
; 192  :     recognizer->type			= type;

  003db	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
  003e0	8b 4c 24 40	 mov	 ecx, DWORD PTR type$[rsp]
  003e4	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 193  : 
; 194  : 
; 195  :     return  recognizer;

  003e7	48 8b 44 24 20	 mov	 rax, QWORD PTR recognizer$[rsp]
$LN1@antlr3Base:

; 196  : }

  003ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003f0	5f		 pop	 rdi
  003f1	c3		 ret	 0
antlr3BaseRecognizerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  0004b	e8 00 00 00 00	 call	 _vfprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 842  :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 843  :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 844  :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
