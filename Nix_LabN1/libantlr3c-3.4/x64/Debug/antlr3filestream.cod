; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3FileStreamNew
PUBLIC	antlr3StringStreamNew
PUBLIC	antlr3Fopen
PUBLIC	antlr3Fclose
PUBLIC	antlr3Fsize
PUBLIC	antlr3read8Bit
PUBLIC	antlr3Fread
PUBLIC	??_C@_02JDPG@rb@				; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__stat64i32:PROC
EXTRN	antlr38BitSetupStream:PROC
EXTRN	antlr3UTF16SetupStream:PROC
EXTRN	antlr3UTF32SetupStream:PROC
EXTRN	antlr3UTF8SetupStream:PROC
EXTRN	antlr3EBCDICSetupStream:PROC
EXTRN	antlr3GenericSetupStream:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3FileStreamNew DD imagerel $LN4
	DD	imagerel $LN4+136
	DD	imagerel $unwind$antlr3FileStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StringStreamNew DD imagerel $LN4
	DD	imagerel $LN4+158
	DD	imagerel $unwind$antlr3StringStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fopen DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$antlr3Fopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fclose DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$antlr3Fclose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fsize DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$antlr3Fsize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3read8Bit DD imagerel $LN5
	DD	imagerel $LN5+171
	DD	imagerel $unwind$antlr3read8Bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fread DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$antlr3Fread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupInputStream DD imagerel setupInputStream
	DD	imagerel setupInputStream+861
	DD	imagerel $unwind$setupInputStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CreateFileStream DD imagerel antlr3CreateFileStream
	DD	imagerel antlr3CreateFileStream+119
	DD	imagerel $unwind$antlr3CreateFileStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CreateStringStream DD imagerel antlr3CreateStringStream
	DD	imagerel antlr3CreateStringStream+102
	DD	imagerel $unwind$antlr3CreateStringStream
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CreateStringStream DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CreateFileStream DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupInputStream DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fread DD 021301H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3read8Bit DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	05fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fsize DD 023519H
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3Fsize$rtcName$0 DB 073H
	DB	074H
	DB	061H
	DB	074H
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+8
antlr3Fsize$rtcVarDesc DD 028H
	DD	030H
	DQ	FLAT:antlr3Fsize$rtcName$0
	ORG $+48
antlr3Fsize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:antlr3Fsize$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fclose DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fopen DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StringStreamNew DD 021801H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3FileStreamNew DD 020e01H
	DD	0700a520eH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3CreateStringStream
_TEXT	SEGMENT
input$ = 32
data$ = 64
antlr3CreateStringStream PROC				; COMDAT

; 443  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 444  : 	// Pointer to the input stream we are going to create
; 445  : 	//
; 446  : 	pANTLR3_INPUT_STREAM    input;
; 447  : 
; 448  : 	if	(data == NULL)

  0000a	48 83 7c 24 40
	00		 cmp	 QWORD PTR data$[rsp], 0
  00010	75 04		 jne	 SHORT $LN2@antlr3Crea

; 449  : 	{
; 450  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 4a		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 451  : 	}
; 452  : 
; 453  : 	// Allocate memory for the input stream structure
; 454  : 	//
; 455  : 	input   = (pANTLR3_INPUT_STREAM)

  00016	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00026	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 456  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 457  : 
; 458  : 	if	(input == NULL)

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00031	75 04		 jne	 SHORT $LN3@antlr3Crea

; 459  : 	{
; 460  : 		return	NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 29		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 461  : 	}
; 462  : 
; 463  : 	// Structure was allocated correctly, now we can install the pointer
; 464  : 	//
; 465  :         input->data             = data;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00041	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 466  :         input->isAllocated	= ANTLR3_FALSE;

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0004a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 467  : 
; 468  : 	// Call the common 8 bit input stream handler
; 469  : 	// initialization.
; 470  : 	//
; 471  : 	antlr3GenericSetupStream(input);

  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00056	e8 00 00 00 00	 call	 antlr3GenericSetupStream

; 472  : 
; 473  :         return  input;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Crea:

; 474  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
antlr3CreateStringStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3CreateFileStream
_TEXT	SEGMENT
input$ = 32
status$ = 40
fileName$ = 64
antlr3CreateFileStream PROC				; COMDAT

; 309  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 310  : 	// Pointer to the input stream we are going to create
; 311  : 	//
; 312  : 	pANTLR3_INPUT_STREAM    input;
; 313  : 	ANTLR3_UINT32	    status;
; 314  : 
; 315  : 	if	(fileName == NULL)

  0000a	48 83 7c 24 40
	00		 cmp	 QWORD PTR fileName$[rsp], 0
  00010	75 04		 jne	 SHORT $LN2@antlr3Crea

; 316  : 	{
; 317  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 5b		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 318  : 	}
; 319  : 
; 320  : 	// Allocate memory for the input stream structure
; 321  : 	//
; 322  : 	input   = (pANTLR3_INPUT_STREAM)

  00016	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00026	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 323  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 324  : 
; 325  : 	if	(input == NULL)

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00031	75 04		 jne	 SHORT $LN3@antlr3Crea

; 326  : 	{
; 327  : 		return	NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 3a		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 328  : 	}
; 329  : 
; 330  : 	// Structure was allocated correctly, now we can read the file.
; 331  : 	//
; 332  : 	status  = antlr3read8Bit(input, fileName);

  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00041	e8 00 00 00 00	 call	 antlr3read8Bit
  00046	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 333  : 
; 334  : 	// Call the common 8 bit input stream handler
; 335  : 	// initialization.
; 336  : 	//
; 337  : 	antlr3GenericSetupStream(input);

  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0004f	e8 00 00 00 00	 call	 antlr3GenericSetupStream

; 338  : 
; 339  :         // However if the file was not there or something then we
; 340  :         // need to close. Have to wait until here as we cannot call
; 341  :         // close until the API is installed of course.
; 342  :         // 
; 343  : 	if	(status != ANTLR3_SUCCESS)

  00054	83 7c 24 28 00	 cmp	 DWORD PTR status$[rsp], 0
  00059	74 11		 je	 SHORT $LN4@antlr3Crea

; 344  : 	{
; 345  : 		input->close(input);

  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00065	ff 50 60	 call	 QWORD PTR [rax+96]

; 346  : 		return	NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	eb 05		 jmp	 SHORT $LN1@antlr3Crea
$LN4@antlr3Crea:

; 347  : 	}
; 348  : 
; 349  : 	return  input;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Crea:

; 350  : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
antlr3CreateFileStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT setupInputStream
_TEXT	SEGMENT
isBigEndian$ = 32
bomTest$ = 36
tv67 = 40
input$ = 64
setupInputStream PROC					; COMDAT

; 131  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 132  :     ANTLR3_BOOLEAN  isBigEndian;
; 133  : 
; 134  :     // Used to determine the endianness of the machine we are currently
; 135  :     // running on.
; 136  :     //
; 137  :     ANTLR3_UINT16 bomTest = 0xFEFF;

  0000a	b8 ff fe 00 00	 mov	 eax, 65279		; 0000feffH
  0000f	66 89 44 24 24	 mov	 WORD PTR bomTest$[rsp], ax

; 138  :     
; 139  :     // What endianess is the machine we are running on? If the incoming
; 140  :     // encoding endianess is the same as this machine's natural byte order
; 141  :     // then we can use more efficient API calls.
; 142  :     //
; 143  :     if  (*((pANTLR3_UINT8)(&bomTest)) == 0xFE)

  00014	0f b6 44 24 24	 movzx	 eax, BYTE PTR bomTest$[rsp]
  00019	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0001e	75 07		 jne	 SHORT $LN4@setupInput

; 144  :     {
; 145  :         isBigEndian = ANTLR3_TRUE;

  00020	c6 44 24 20 01	 mov	 BYTE PTR isBigEndian$[rsp], 1

; 146  :     }

  00025	eb 05		 jmp	 SHORT $LN5@setupInput
$LN4@setupInput:

; 147  :     else
; 148  :     {
; 149  :         isBigEndian = ANTLR3_FALSE;

  00027	c6 44 24 20 00	 mov	 BYTE PTR isBigEndian$[rsp], 0
$LN5@setupInput:

; 150  :     }
; 151  : 
; 152  :     // What encoding did the user tell us {s}he thought it was? I am going
; 153  :     // to get sick of the questions on antlr-interest, I know I am.
; 154  :     //
; 155  :     switch  (input->encoding)

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00031	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  00037	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  0003f	83 e8 04	 sub	 eax, 4
  00042	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  00046	83 7c 24 28 3c	 cmp	 DWORD PTR tv67[rsp], 60	; 0000003cH
  0004b	0f 87 97 02 00
	00		 ja	 $LN24@setupInput
  00051	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005c	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN26@setupInput[rcx+rax]
  00064	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@setupInput[rcx+rax*4]
  0006b	48 03 c1	 add	 rax, rcx
  0006e	ff e0		 jmp	 rax
$LN6@setupInput:

; 156  :     {
; 157  :         case    ANTLR3_ENC_UTF8:
; 158  : 
; 159  :             // See if there is a BOM at the start of this UTF-8 sequence
; 160  :             // and just eat it if there is. Windows .TXT files have this for instance
; 161  :             // as it identifies UTF-8 even though it is of no consequence for byte order
; 162  :             // as UTF-8 does not have a byte order.
; 163  :             //
; 164  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xEF
; 165  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xBB
; 166  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xBF

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007c	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00081	75 3e		 jne	 SHORT $LN7@setupInput
  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00088	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00090	3d bb 00 00 00	 cmp	 eax, 187		; 000000bbH
  00095	75 2a		 jne	 SHORT $LN7@setupInput
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0009c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a0	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000a4	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000a9	75 16		 jne	 SHORT $LN7@setupInput

; 167  :                 )
; 168  :             {
; 169  :                 // The UTF8 BOM is present so skip it
; 170  :                 //
; 171  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 3);

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b0	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b4	48 83 c0 03	 add	 rax, 3
  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  000bd	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN7@setupInput:

; 172  :             }
; 173  : 
; 174  :             // Install the UTF8 input routines
; 175  :             //
; 176  :             antlr3UTF8SetupStream(input);

  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  000c6	e8 00 00 00 00	 call	 antlr3UTF8SetupStream

; 177  :             break;

  000cb	e9 22 02 00 00	 jmp	 $LN2@setupInput
$LN8@setupInput:

; 178  : 
; 179  :         case    ANTLR3_ENC_UTF16:
; 180  : 
; 181  :             // See if there is a BOM at the start of the input. If not then
; 182  :             // we assume that the byte order is the natural order of this
; 183  :             // machine (or it is really UCS2). If there is a BOM we determine if the encoding
; 184  :             // is the same as the natural order of this machine.
; 185  :             //
; 186  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFE
; 187  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFF

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000d5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000d9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000dc	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000e1	75 3e		 jne	 SHORT $LN9@setupInput
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000e8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ec	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000f0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f5	75 2a		 jne	 SHORT $LN9@setupInput

; 188  :                 )
; 189  :             {
; 190  :                 // BOM Present, indicates Big Endian
; 191  :                 //
; 192  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fc	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00100	48 83 c0 02	 add	 rax, 2
  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00109	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 193  : 
; 194  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  0010d	41 b0 01	 mov	 r8b, 1
  00110	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0011a	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 195  :             }

  0011f	eb 66		 jmp	 SHORT $LN10@setupInput
$LN9@setupInput:

; 196  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 197  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE

  00121	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00126	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0012a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00132	75 3e		 jne	 SHORT $LN11@setupInput
  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00139	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00141	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00146	75 2a		 jne	 SHORT $LN11@setupInput

; 198  :                 )
; 199  :             {
; 200  :                 // BOM present, indicates Little Endian
; 201  :                 //
; 202  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  00148	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0014d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00151	48 83 c0 02	 add	 rax, 2
  00155	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0015a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 203  : 
; 204  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  0015e	45 33 c0	 xor	 r8d, r8d
  00161	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00166	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0016b	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 205  :             }

  00170	eb 15		 jmp	 SHORT $LN12@setupInput
$LN11@setupInput:

; 206  :             else
; 207  :             {
; 208  :                 // No BOM present, assume local computer byte order
; 209  :                 //
; 210  :                 antlr3UTF16SetupStream(input, isBigEndian, isBigEndian);

  00172	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR isBigEndian$[rsp]
  00178	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  0017d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00182	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
$LN12@setupInput:
$LN10@setupInput:

; 211  :             }
; 212  :             break;

  00187	e9 66 01 00 00	 jmp	 $LN2@setupInput
$LN13@setupInput:

; 213  : 
; 214  :         case    ANTLR3_ENC_UTF32:
; 215  : 
; 216  :             // See if there is a BOM at the start of the input. If not then
; 217  :             // we assume that the byte order is the natural order of this
; 218  :             // machine. If there is we determine if the encoding
; 219  :             // is the same as the natural order of this machine.
; 220  :             //
; 221  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0x00
; 222  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 223  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xFE
; 224  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+3))    == 0xFF

  0018c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00191	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00195	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00198	85 c0		 test	 eax, eax
  0019a	75 66		 jne	 SHORT $LN14@setupInput
  0019c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001a1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001a5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001a9	85 c0		 test	 eax, eax
  001ab	75 55		 jne	 SHORT $LN14@setupInput
  001ad	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001b2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001b6	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001ba	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  001bf	75 41		 jne	 SHORT $LN14@setupInput
  001c1	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001c6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001ca	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001ce	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001d3	75 2d		 jne	 SHORT $LN14@setupInput

; 225  :                 )
; 226  :             {
; 227  :                 // BOM Present, indicates Big Endian
; 228  :                 //
; 229  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  001d5	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001da	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001de	48 83 c0 04	 add	 rax, 4
  001e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  001e7	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 230  : 
; 231  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  001eb	41 b0 01	 mov	 r8b, 1
  001ee	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  001f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  001f8	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 232  :             }

  001fd	e9 88 00 00 00	 jmp	 $LN15@setupInput
$LN14@setupInput:

; 233  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 234  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE
; 235  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 236  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00

  00202	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00207	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0020b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00213	75 60		 jne	 SHORT $LN16@setupInput
  00215	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0021a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0021e	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00222	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00227	75 4c		 jne	 SHORT $LN16@setupInput
  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0022e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00232	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00236	85 c0		 test	 eax, eax
  00238	75 3b		 jne	 SHORT $LN16@setupInput
  0023a	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0023f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00243	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00247	85 c0		 test	 eax, eax
  00249	75 2a		 jne	 SHORT $LN16@setupInput

; 237  :                 )
; 238  :             {
; 239  :                 // BOM present, indicates Little Endian
; 240  :                 //
; 241  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  0024b	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00250	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00254	48 83 c0 04	 add	 rax, 4
  00258	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0025d	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 242  : 
; 243  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00261	45 33 c0	 xor	 r8d, r8d
  00264	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00269	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0026e	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 244  :             }

  00273	eb 15		 jmp	 SHORT $LN17@setupInput
$LN16@setupInput:

; 245  :             else
; 246  :             {
; 247  :                 // No BOM present, assume local computer byte order
; 248  :                 //
; 249  :                 antlr3UTF32SetupStream(input, isBigEndian, isBigEndian);

  00275	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR isBigEndian$[rsp]
  0027b	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00280	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00285	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
$LN17@setupInput:
$LN15@setupInput:

; 250  :             }
; 251  :             break;

  0028a	eb 66		 jmp	 SHORT $LN2@setupInput
$LN18@setupInput:

; 252  : 
; 253  :         case    ANTLR3_ENC_UTF16BE:
; 254  : 
; 255  :             // Encoding is definately Big Endian with no BOM
; 256  :             //
; 257  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  0028c	41 b0 01	 mov	 r8b, 1
  0028f	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00294	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00299	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 258  :             break;

  0029e	eb 52		 jmp	 SHORT $LN2@setupInput
$LN19@setupInput:

; 259  : 
; 260  :         case    ANTLR3_ENC_UTF16LE:
; 261  : 
; 262  :             // Encoding is definately Little Endian with no BOM
; 263  :             //
; 264  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  002a0	45 33 c0	 xor	 r8d, r8d
  002a3	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002ad	e8 00 00 00 00	 call	 antlr3UTF16SetupStream

; 265  :             break;

  002b2	eb 3e		 jmp	 SHORT $LN2@setupInput
$LN20@setupInput:

; 266  : 
; 267  :         case    ANTLR3_ENC_UTF32BE:
; 268  : 
; 269  :             // Encoding is definately Big Endian with no BOM
; 270  :             //
; 271  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  002b4	41 b0 01	 mov	 r8b, 1
  002b7	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002c1	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 272  :             break;

  002c6	eb 2a		 jmp	 SHORT $LN2@setupInput
$LN21@setupInput:

; 273  : 
; 274  :         case    ANTLR3_ENC_UTF32LE:
; 275  : 
; 276  :             // Encoding is definately Little Endian with no BOM
; 277  :             //
; 278  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  002c8	45 33 c0	 xor	 r8d, r8d
  002cb	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002d5	e8 00 00 00 00	 call	 antlr3UTF32SetupStream

; 279  :             break;

  002da	eb 16		 jmp	 SHORT $LN2@setupInput
$LN22@setupInput:

; 280  : 
; 281  :         case    ANTLR3_ENC_EBCDIC:
; 282  : 
; 283  :             // EBCDIC is basically the same as ASCII but with an on the
; 284  :             // fly translation to ASCII
; 285  :             //
; 286  :             antlr3EBCDICSetupStream(input);

  002dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002e1	e8 00 00 00 00	 call	 antlr3EBCDICSetupStream

; 287  :             break;

  002e6	eb 0a		 jmp	 SHORT $LN2@setupInput
$LN23@setupInput:
$LN24@setupInput:

; 288  : 
; 289  :         case    ANTLR3_ENC_8BIT:
; 290  :         default:
; 291  : 
; 292  :             // Standard 8bit/ASCII
; 293  :             //
; 294  :             antlr38BitSetupStream(input);

  002e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002ed	e8 00 00 00 00	 call	 antlr38BitSetupStream
$LN2@setupInput:

; 295  :             break;
; 296  :     }    
; 297  : }

  002f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002f6	5f		 pop	 rdi
  002f7	c3		 ret	 0
$LN27@setupInput:
  002f8	00 00 00 00	 DD	 $LN23@setupInput
  002fc	00 00 00 00	 DD	 $LN6@setupInput
  00300	00 00 00 00	 DD	 $LN8@setupInput
  00304	00 00 00 00	 DD	 $LN18@setupInput
  00308	00 00 00 00	 DD	 $LN19@setupInput
  0030c	00 00 00 00	 DD	 $LN13@setupInput
  00310	00 00 00 00	 DD	 $LN20@setupInput
  00314	00 00 00 00	 DD	 $LN21@setupInput
  00318	00 00 00 00	 DD	 $LN22@setupInput
  0031c	00 00 00 00	 DD	 $LN24@setupInput
$LN26@setupInput:
  00320	00		 DB	 0
  00321	09		 DB	 9
  00322	09		 DB	 9
  00323	09		 DB	 9
  00324	01		 DB	 1
  00325	09		 DB	 9
  00326	09		 DB	 9
  00327	09		 DB	 9
  00328	09		 DB	 9
  00329	09		 DB	 9
  0032a	09		 DB	 9
  0032b	09		 DB	 9
  0032c	02		 DB	 2
  0032d	03		 DB	 3
  0032e	04		 DB	 4
  0032f	09		 DB	 9
  00330	09		 DB	 9
  00331	09		 DB	 9
  00332	09		 DB	 9
  00333	09		 DB	 9
  00334	09		 DB	 9
  00335	09		 DB	 9
  00336	09		 DB	 9
  00337	09		 DB	 9
  00338	09		 DB	 9
  00339	09		 DB	 9
  0033a	09		 DB	 9
  0033b	09		 DB	 9
  0033c	05		 DB	 5
  0033d	06		 DB	 6
  0033e	07		 DB	 7
  0033f	09		 DB	 9
  00340	09		 DB	 9
  00341	09		 DB	 9
  00342	09		 DB	 9
  00343	09		 DB	 9
  00344	09		 DB	 9
  00345	09		 DB	 9
  00346	09		 DB	 9
  00347	09		 DB	 9
  00348	09		 DB	 9
  00349	09		 DB	 9
  0034a	09		 DB	 9
  0034b	09		 DB	 9
  0034c	09		 DB	 9
  0034d	09		 DB	 9
  0034e	09		 DB	 9
  0034f	09		 DB	 9
  00350	09		 DB	 9
  00351	09		 DB	 9
  00352	09		 DB	 9
  00353	09		 DB	 9
  00354	09		 DB	 9
  00355	09		 DB	 9
  00356	09		 DB	 9
  00357	09		 DB	 9
  00358	09		 DB	 9
  00359	09		 DB	 9
  0035a	09		 DB	 9
  0035b	09		 DB	 9
  0035c	08		 DB	 8
setupInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fread
_TEXT	SEGMENT
fdsc$ = 48
count$ = 56
data$ = 64
antlr3Fread PROC					; COMDAT

; 429  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 430  :     return  (ANTLR3_UINT32)fread(data, (size_t)count, 1, fdsc);

  00013	8b 44 24 38	 mov	 eax, DWORD PTR count$[rsp]
  00017	4c 8b 4c 24 30	 mov	 r9, QWORD PTR fdsc$[rsp]
  0001c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00022	8b d0		 mov	 edx, eax
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 431  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
antlr3Fread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3read8Bit
_TEXT	SEGMENT
infile$ = 32
fSize$ = 40
input$ = 64
fileName$ = 72
antlr3read8Bit PROC					; COMDAT

; 354  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 355  : 	ANTLR3_FDSC	    infile;
; 356  : 	ANTLR3_UINT32	    fSize;
; 357  : 
; 358  : 	/* Open the OS file in read binary mode
; 359  : 	*/
; 360  : 	infile  = antlr3Fopen(fileName, "rb");

  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00016	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fileName$[rsp]
  0001b	e8 00 00 00 00	 call	 antlr3Fopen
  00020	48 89 44 24 20	 mov	 QWORD PTR infile$[rsp], rax

; 361  : 
; 362  : 	/* Check that it was there
; 363  : 	*/
; 364  : 	if	(infile == NULL)

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR infile$[rsp], 0
  0002b	75 07		 jne	 SHORT $LN2@antlr3read

; 365  : 	{
; 366  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOFILE;

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	eb 71		 jmp	 SHORT $LN1@antlr3read
$LN2@antlr3read:

; 367  : 	}
; 368  : 
; 369  : 	/* It was there, so we can read the bytes now
; 370  : 	*/
; 371  : 	fSize   = antlr3Fsize(fileName);	/* Size of input file	*/

  00034	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fileName$[rsp]
  00039	e8 00 00 00 00	 call	 antlr3Fsize
  0003e	89 44 24 28	 mov	 DWORD PTR fSize$[rsp], eax

; 372  : 
; 373  : 	/* Allocate buffer for this input set   
; 374  : 	*/
; 375  : 	input->data	    = ANTLR3_MALLOC((size_t)fSize);

  00042	8b 44 24 28	 mov	 eax, DWORD PTR fSize$[rsp]
  00046	8b c8		 mov	 ecx, eax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 376  : 	input->sizeBuf  = fSize;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0005c	8b 4c 24 28	 mov	 ecx, DWORD PTR fSize$[rsp]
  00060	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 377  : 
; 378  : 	if	(input->data == NULL)

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00068	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006d	75 07		 jne	 SHORT $LN3@antlr3read

; 379  : 	{
; 380  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOMEM;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	eb 2f		 jmp	 SHORT $LN1@antlr3read
$LN3@antlr3read:

; 381  : 	}
; 382  : 
; 383  : 	input->isAllocated	= ANTLR3_TRUE;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0007b	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 384  : 
; 385  : 	/* Now we read the file. Characters are not converted to
; 386  : 	* the internal ANTLR encoding until they are read from the buffer
; 387  : 	*/
; 388  : 	antlr3Fread(infile, fSize, input->data);

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00087	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0008b	8b 54 24 28	 mov	 edx, DWORD PTR fSize$[rsp]
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR infile$[rsp]
  00094	e8 00 00 00 00	 call	 antlr3Fread

; 389  : 
; 390  : 	/* And close the file handle
; 391  : 	*/
; 392  : 	antlr3Fclose(infile);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR infile$[rsp]
  0009e	e8 00 00 00 00	 call	 antlr3Fclose

; 393  : 
; 394  : 	return  ANTLR3_SUCCESS;

  000a3	33 c0		 xor	 eax, eax
$LN1@antlr3read:

; 395  : }

  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
antlr3read8Bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fsize
_TEXT	SEGMENT
statbuf$ = 40
__$ArrayPad$ = 112
fileName$ = 144
antlr3Fsize PROC					; COMDAT

; 419  : {   

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00012	b9 18 00 00 00	 mov	 ecx, 24
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 420  :     struct _stat	statbuf;
; 421  : 
; 422  :     _stat((const char *)fileName, &statbuf);

  00035	48 8d 54 24 28	 lea	 rdx, QWORD PTR statbuf$[rsp]
  0003a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fileName$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64i32

; 423  : 
; 424  :     return (ANTLR3_UINT32)statbuf.st_size;

  00048	8b 44 24 3c	 mov	 eax, DWORD PTR statbuf$[rsp+20]

; 425  : }

  0004c	8b f8		 mov	 edi, eax
  0004e	48 8b cc	 mov	 rcx, rsp
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3Fsize$rtcFrameData
  00058	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0005d	8b c7		 mov	 eax, edi
  0005f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00064	48 33 cc	 xor	 rcx, rsp
  00067	e8 00 00 00 00	 call	 __security_check_cookie
  0006c	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
antlr3Fsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fclose
_TEXT	SEGMENT
fd$ = 48
antlr3Fclose PROC					; COMDAT

; 414  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 415  :     fclose(fd);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fd$[rsp]
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 416  : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
antlr3Fclose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fopen
_TEXT	SEGMENT
filename$ = 48
mode$ = 56
antlr3Fopen PROC					; COMDAT

; 405  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 406  :     return  (ANTLR3_FDSC)fopen((const char *)filename, mode);

  0000f	48 8b 54 24 38	 mov	 rdx, QWORD PTR mode$[rsp]
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR filename$[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen

; 407  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
antlr3Fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3StringStreamNew
_TEXT	SEGMENT
input$ = 32
data$ = 64
encoding$ = 72
size$ = 80
name$ = 88
antlr3StringStreamNew PROC				; COMDAT

; 90   : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 91   :     pANTLR3_INPUT_STREAM    input;
; 92   : 
; 93   :     // First order of business is to set up the stream and install the data pointer.
; 94   :     // Then we will work out the encoding and byte order and adjust the API functions that are installed for the
; 95   :     // default 8Bit stream accordingly.
; 96   :     //
; 97   :     input   = antlr3CreateStringStream(data);

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001d	e8 00 00 00 00	 call	 antlr3CreateStringStream
  00022	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 98   :     if  (input == NULL)

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  0002d	75 04		 jne	 SHORT $LN2@antlr3Stri

; 99   :     {
; 100  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 65		 jmp	 SHORT $LN1@antlr3Stri
$LN2@antlr3Stri:

; 101  :     }
; 102  :     
; 103  :     // Size (in bytes) of the given 'string'
; 104  :     //
; 105  :     input->sizeBuf		= size;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00038	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  0003c	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 106  : 
; 107  :     // We have the data in memory now so we can deal with it according to 
; 108  :     // the encoding scheme we were given by the user.
; 109  :     //
; 110  :     input->encoding = encoding;

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00044	8b 4c 24 48	 mov	 ecx, DWORD PTR encoding$[rsp]
  00048	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx

; 111  : 
; 112  :     // Now we need to work out the endian type and install any 
; 113  :     // API functions that differ from 8Bit
; 114  :     //
; 115  :     setupInputStream(input);

  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00053	e8 00 00 00 00	 call	 setupInputStream

; 116  : 
; 117  :     // Now we can set up the file name
; 118  :     //	
; 119  :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, name);

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0005d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00061	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0006b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006f	ff 50 38	 call	 QWORD PTR [rax+56]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 120  :     input->fileName		= input->istream->streamName;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0008b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008f	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 121  : 
; 122  :     return input;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Stri:

; 123  : }

  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
antlr3StringStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3FileStreamNew
_TEXT	SEGMENT
input$ = 32
fileName$ = 64
encoding$ = 72
antlr3FileStreamNew PROC				; COMDAT

; 55   : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 56   :     pANTLR3_INPUT_STREAM input;
; 57   : 
; 58   :     // First order of business is to read the file into some buffer space
; 59   :     // as just straight 8 bit bytes. Then we will work out the encoding and
; 60   :     // byte order and adjust the API functions that are installed for the
; 61   :     // default 8Bit stream accordingly.
; 62   :     //
; 63   :     input   = antlr3CreateFileStream(fileName);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fileName$[rsp]
  00013	e8 00 00 00 00	 call	 antlr3CreateFileStream
  00018	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 64   :     if  (input == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@antlr3File

; 65   :     {
; 66   :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 59		 jmp	 SHORT $LN1@antlr3File
$LN2@antlr3File:

; 67   :     }
; 68   : 
; 69   :     // We have the data in memory now so we can deal with it according to 
; 70   :     // the encoding scheme we were given by the user.
; 71   :     //
; 72   :     input->encoding = encoding;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0002e	8b 4c 24 48	 mov	 ecx, DWORD PTR encoding$[rsp]
  00032	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx

; 73   : 
; 74   :     // Now we need to work out the endian type and install any 
; 75   :     // API functions that differ from 8Bit
; 76   :     //
; 77   :     setupInputStream(input);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0003d	e8 00 00 00 00	 call	 setupInputStream

; 78   : 
; 79   :     // Now we can set up the file name
; 80   :     //	
; 81   :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, fileName);

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00047	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004b	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00055	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00059	ff 50 38	 call	 QWORD PTR [rax+56]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00061	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00064	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 82   :     input->fileName		= input->istream->streamName;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0006d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00075	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00079	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 83   : 
; 84   :     return input;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3File:

; 85   : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
antlr3FileStreamNew ENDP
_TEXT	ENDS
END
