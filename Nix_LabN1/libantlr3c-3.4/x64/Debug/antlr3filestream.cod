; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34435.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3FileStreamNew
PUBLIC	antlr3StringStreamNew
PUBLIC	antlr3Fopen
PUBLIC	antlr3Fclose
PUBLIC	antlr3Fsize
PUBLIC	antlr3read8Bit
PUBLIC	antlr3Fread
PUBLIC	??_C@_02JDPG@rb@				; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__stat64i32:PROC
EXTRN	antlr38BitSetupStream:PROC
EXTRN	antlr3UTF16SetupStream:PROC
EXTRN	antlr3UTF32SetupStream:PROC
EXTRN	antlr3UTF8SetupStream:PROC
EXTRN	antlr3EBCDICSetupStream:PROC
EXTRN	antlr3GenericSetupStream:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3FileStreamNew DD imagerel $LN4
	DD	imagerel $LN4+136
	DD	imagerel $unwind$antlr3FileStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StringStreamNew DD imagerel $LN4
	DD	imagerel $LN4+158
	DD	imagerel $unwind$antlr3StringStreamNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fopen DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$antlr3Fopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fclose DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$antlr3Fclose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fsize DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$antlr3Fsize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3read8Bit DD imagerel $LN5
	DD	imagerel $LN5+171
	DD	imagerel $unwind$antlr3read8Bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Fread DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$antlr3Fread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupInputStream DD imagerel setupInputStream
	DD	imagerel setupInputStream+877
	DD	imagerel $unwind$setupInputStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CreateFileStream DD imagerel antlr3CreateFileStream
	DD	imagerel antlr3CreateFileStream+119
	DD	imagerel $unwind$antlr3CreateFileStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CreateStringStream DD imagerel antlr3CreateStringStream
	DD	imagerel antlr3CreateStringStream+102
	DD	imagerel $unwind$antlr3CreateStringStream
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CreateStringStream DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CreateFileStream DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupInputStream DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fread DD 021301H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3read8Bit DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	05fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fsize DD 023519H
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3Fsize$rtcName$0 DB 073H
	DB	074H
	DB	061H
	DB	074H
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+8
antlr3Fsize$rtcVarDesc DD 028H
	DD	030H
	DQ	FLAT:antlr3Fsize$rtcName$0
	ORG $+48
antlr3Fsize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:antlr3Fsize$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fclose DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Fopen DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StringStreamNew DD 021801H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3FileStreamNew DD 020e01H
	DD	0700a520eH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3CreateStringStream
_TEXT	SEGMENT
input$ = 32
data$ = 64
antlr3CreateStringStream PROC				; COMDAT

; 443  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 444  : 	// Pointer to the input stream we are going to create
; 445  : 	//
; 446  : 	pANTLR3_INPUT_STREAM    input;
; 447  : 
; 448  : 	if	(data == NULL)

  0000a	48 83 7c 24 40
	00		 cmp	 QWORD PTR data$[rsp], 0
  00010	75 04		 jne	 SHORT $LN2@antlr3Crea

; 449  : 	{
; 450  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 4a		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 451  : 	}
; 452  : 
; 453  : 	// Allocate memory for the input stream structure
; 454  : 	//
; 455  : 	input   = (pANTLR3_INPUT_STREAM)

  00016	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00026	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 456  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 457  : 
; 458  : 	if	(input == NULL)

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00031	75 04		 jne	 SHORT $LN3@antlr3Crea

; 459  : 	{
; 460  : 		return	NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 29		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 461  : 	}
; 462  : 
; 463  : 	// Structure was allocated correctly, now we can install the pointer
; 464  : 	//
; 465  :         input->data             = data;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00041	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 466  :         input->isAllocated	= ANTLR3_FALSE;

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0004a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 467  : 
; 468  : 	// Call the common 8 bit input stream handler
; 469  : 	// initialization.
; 470  : 	//
; 471  : 	antlr3GenericSetupStream(input);

  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00056	e8 00 00 00 00	 call	 antlr3GenericSetupStream

; 472  : 
; 473  :         return  input;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Crea:

; 474  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
antlr3CreateStringStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3CreateFileStream
_TEXT	SEGMENT
input$ = 32
status$ = 40
fileName$ = 64
antlr3CreateFileStream PROC				; COMDAT

; 309  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 310  : 	// Pointer to the input stream we are going to create
; 311  : 	//
; 312  : 	pANTLR3_INPUT_STREAM    input;
; 313  : 	ANTLR3_UINT32	    status;
; 314  : 
; 315  : 	if	(fileName == NULL)

  0000a	48 83 7c 24 40
	00		 cmp	 QWORD PTR fileName$[rsp], 0
  00010	75 04		 jne	 SHORT $LN2@antlr3Crea

; 316  : 	{
; 317  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 5b		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 318  : 	}
; 319  : 
; 320  : 	// Allocate memory for the input stream structure
; 321  : 	//
; 322  : 	input   = (pANTLR3_INPUT_STREAM)

  00016	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00026	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 323  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 324  : 
; 325  : 	if	(input == NULL)

  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00031	75 04		 jne	 SHORT $LN3@antlr3Crea

; 326  : 	{
; 327  : 		return	NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 3a		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 328  : 	}
; 329  : 
; 330  : 	// Structure was allocated correctly, now we can read the file.
; 331  : 	//
; 332  : 	status  = antlr3read8Bit(input, fileName);

  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00041	e8 00 00 00 00	 call	 antlr3read8Bit
  00046	89 44 24 28	 mov	 DWORD PTR status$[rsp], eax

; 333  : 
; 334  : 	// Call the common 8 bit input stream handler
; 335  : 	// initialization.
; 336  : 	//
; 337  : 	antlr3GenericSetupStream(input);

  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0004f	e8 00 00 00 00	 call	 antlr3GenericSetupStream

; 338  : 
; 339  :         // However if the file was not there or something then we
; 340  :         // need to close. Have to wait until here as we cannot call
; 341  :         // close until the API is installed of course.
; 342  :         // 
; 343  : 	if	(status != ANTLR3_SUCCESS)

  00054	83 7c 24 28 00	 cmp	 DWORD PTR status$[rsp], 0
  00059	74 11		 je	 SHORT $LN4@antlr3Crea

; 344  : 	{
; 345  : 		input->close(input);

  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00065	ff 50 60	 call	 QWORD PTR [rax+96]

; 346  : 		return	NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	eb 05		 jmp	 SHORT $LN1@antlr3Crea
$LN4@antlr3Crea:

; 347  : 	}
; 348  : 
; 349  : 	return  input;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Crea:

; 350  : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
antlr3CreateFileStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT setupInputStream
_TEXT	SEGMENT
isBigEndian$ = 32
bomTest$ = 36
tv67 = 40
input$ = 64
setupInputStream PROC					; COMDAT

; 131  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 132  :     ANTLR3_BOOLEAN  isBigEndian;
; 133  : 
; 134  :     // Used to determine the endianness of the machine we are currently
; 135  :     // running on.
; 136  :     //
; 137  :     ANTLR3_UINT16 bomTest = 0xFEFF;

  0000a	b8 ff fe 00 00	 mov	 eax, 65279		; 0000feffH
  0000f	66 89 44 24 24	 mov	 WORD PTR bomTest$[rsp], ax

; 138  :     
; 139  :     // What endianess is the machine we are running on? If the incoming
; 140  :     // encoding endianess is the same as this machine's natural byte order
; 141  :     // then we can use more efficient API calls.
; 142  :     //
; 143  :     if  (*((pANTLR3_UINT8)(&bomTest)) == 0xFE)

  00014	0f b6 44 24 24	 movzx	 eax, BYTE PTR bomTest$[rsp]
  00019	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0001e	75 07		 jne	 SHORT $LN4@setupInput

; 144  :     {
; 145  :         isBigEndian = ANTLR3_TRUE;

  00020	c6 44 24 20 01	 mov	 BYTE PTR isBigEndian$[rsp], 1

; 146  :     }

  00025	eb 05		 jmp	 SHORT $LN5@setupInput
$LN4@setupInput:

; 147  :     else
; 148  :     {
; 149  :         isBigEndian = ANTLR3_FALSE;

  00027	c6 44 24 20 00	 mov	 BYTE PTR isBigEndian$[rsp], 0
$LN5@setupInput:

; 150  :     }
; 151  : 
; 152  :     // What encoding did the user tell us {s}he thought it was? I am going
; 153  :     // to get sick of the questions on antlr-interest, I know I am.
; 154  :     //
; 155  :     switch  (input->encoding)

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00031	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  00037	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  0003f	83 e8 04	 sub	 eax, 4
  00042	89 44 24 28	 mov	 DWORD PTR tv67[rsp], eax
  00046	83 7c 24 28 3c	 cmp	 DWORD PTR tv67[rsp], 60	; 0000003cH
  0004b	0f 87 a3 02 00
	00		 ja	 $LN24@setupInput
  00051	8b 44 24 28	 mov	 eax, DWORD PTR tv67[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005c	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN26@setupInput[rcx+rax]
  00064	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@setupInput[rcx+rax*4]
  0006b	48 03 c1	 add	 rax, rcx
  0006e	ff e0		 jmp	 rax
$LN6@setupInput:

; 156  :     {
; 157  :         case    ANTLR3_ENC_UTF8:
; 158  : 
; 159  :             // See if there is a BOM at the start of this UTF-8 sequence
; 160  :             // and just eat it if there is. Windows .TXT files have this for instance
; 161  :             // as it identifies UTF-8 even though it is of no consequence for byte order
; 162  :             // as UTF-8 does not have a byte order.
; 163  :             //
; 164  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xEF
; 165  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xBB
; 166  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xBF

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007c	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00081	75 3e		 jne	 SHORT $LN7@setupInput
  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00088	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008c	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00090	3d bb 00 00 00	 cmp	 eax, 187		; 000000bbH
  00095	75 2a		 jne	 SHORT $LN7@setupInput
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0009c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a0	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000a4	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  000a9	75 16		 jne	 SHORT $LN7@setupInput

; 167  :                 )
; 168  :             {
; 169  :                 // The UTF8 BOM is present so skip it
; 170  :                 //
; 171  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 3);

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b0	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b4	48 83 c0 03	 add	 rax, 3
  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  000bd	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN7@setupInput:

; 172  :             }
; 173  : 
; 174  :             // Install the UTF8 input routines
; 175  :             //
; 176  :             antlr3UTF8SetupStream(input);

  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  000c6	e8 00 00 00 00	 call	 antlr3UTF8SetupStream
  000cb	90		 npad	 1

; 177  :             break;

  000cc	e9 2e 02 00 00	 jmp	 $LN2@setupInput
$LN8@setupInput:

; 178  : 
; 179  :         case    ANTLR3_ENC_UTF16:
; 180  : 
; 181  :             // See if there is a BOM at the start of the input. If not then
; 182  :             // we assume that the byte order is the natural order of this
; 183  :             // machine (or it is really UCS2). If there is a BOM we determine if the encoding
; 184  :             // is the same as the natural order of this machine.
; 185  :             //
; 186  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFE
; 187  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFF

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000d6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000da	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000dd	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000e2	75 3f		 jne	 SHORT $LN9@setupInput
  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000e9	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ed	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000f1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f6	75 2b		 jne	 SHORT $LN9@setupInput

; 188  :                 )
; 189  :             {
; 190  :                 // BOM Present, indicates Big Endian
; 191  :                 //
; 192  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fd	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00101	48 83 c0 02	 add	 rax, 2
  00105	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0010a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 193  : 
; 194  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  0010e	41 b0 01	 mov	 r8b, 1
  00111	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00116	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0011b	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
  00120	90		 npad	 1

; 195  :             }

  00121	eb 68		 jmp	 SHORT $LN10@setupInput
$LN9@setupInput:

; 196  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 197  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE

  00123	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00128	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0012c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00134	75 3f		 jne	 SHORT $LN11@setupInput
  00136	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0013b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0013f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00143	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00148	75 2b		 jne	 SHORT $LN11@setupInput

; 198  :                 )
; 199  :             {
; 200  :                 // BOM present, indicates Little Endian
; 201  :                 //
; 202  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  0014a	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0014f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00153	48 83 c0 02	 add	 rax, 2
  00157	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0015c	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 203  : 
; 204  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00160	45 33 c0	 xor	 r8d, r8d
  00163	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00168	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0016d	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
  00172	90		 npad	 1

; 205  :             }

  00173	eb 16		 jmp	 SHORT $LN12@setupInput
$LN11@setupInput:

; 206  :             else
; 207  :             {
; 208  :                 // No BOM present, assume local computer byte order
; 209  :                 //
; 210  :                 antlr3UTF16SetupStream(input, isBigEndian, isBigEndian);

  00175	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR isBigEndian$[rsp]
  0017b	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00180	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00185	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
  0018a	90		 npad	 1
$LN12@setupInput:
$LN10@setupInput:

; 211  :             }
; 212  :             break;

  0018b	e9 6f 01 00 00	 jmp	 $LN2@setupInput
$LN13@setupInput:

; 213  : 
; 214  :         case    ANTLR3_ENC_UTF32:
; 215  : 
; 216  :             // See if there is a BOM at the start of the input. If not then
; 217  :             // we assume that the byte order is the natural order of this
; 218  :             // machine. If there is we determine if the encoding
; 219  :             // is the same as the natural order of this machine.
; 220  :             //
; 221  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0x00
; 222  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 223  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xFE
; 224  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+3))    == 0xFF

  00190	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00195	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00199	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019c	85 c0		 test	 eax, eax
  0019e	75 67		 jne	 SHORT $LN14@setupInput
  001a0	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001a5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001a9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001ad	85 c0		 test	 eax, eax
  001af	75 56		 jne	 SHORT $LN14@setupInput
  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001b6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001ba	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001be	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  001c3	75 42		 jne	 SHORT $LN14@setupInput
  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001ca	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001ce	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001d2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001d7	75 2e		 jne	 SHORT $LN14@setupInput

; 225  :                 )
; 226  :             {
; 227  :                 // BOM Present, indicates Big Endian
; 228  :                 //
; 229  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  001d9	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  001de	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001e2	48 83 c0 04	 add	 rax, 4
  001e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  001eb	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 230  : 
; 231  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  001ef	41 b0 01	 mov	 r8b, 1
  001f2	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  001f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  001fc	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
  00201	90		 npad	 1

; 232  :             }

  00202	e9 8a 00 00 00	 jmp	 $LN15@setupInput
$LN14@setupInput:

; 233  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 234  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE
; 235  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 236  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00

  00207	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0020c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00210	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00213	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00218	75 61		 jne	 SHORT $LN16@setupInput
  0021a	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0021f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00223	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00227	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0022c	75 4d		 jne	 SHORT $LN16@setupInput
  0022e	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00233	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00237	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0023b	85 c0		 test	 eax, eax
  0023d	75 3c		 jne	 SHORT $LN16@setupInput
  0023f	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00244	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00248	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0024c	85 c0		 test	 eax, eax
  0024e	75 2b		 jne	 SHORT $LN16@setupInput

; 237  :                 )
; 238  :             {
; 239  :                 // BOM present, indicates Little Endian
; 240  :                 //
; 241  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  00250	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00255	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00259	48 83 c0 04	 add	 rax, 4
  0025d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00262	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 242  : 
; 243  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00266	45 33 c0	 xor	 r8d, r8d
  00269	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  0026e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00273	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
  00278	90		 npad	 1

; 244  :             }

  00279	eb 16		 jmp	 SHORT $LN17@setupInput
$LN16@setupInput:

; 245  :             else
; 246  :             {
; 247  :                 // No BOM present, assume local computer byte order
; 248  :                 //
; 249  :                 antlr3UTF32SetupStream(input, isBigEndian, isBigEndian);

  0027b	44 0f b6 44 24
	20		 movzx	 r8d, BYTE PTR isBigEndian$[rsp]
  00281	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  00286	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0028b	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
  00290	90		 npad	 1
$LN17@setupInput:
$LN15@setupInput:

; 250  :             }
; 251  :             break;

  00291	eb 6c		 jmp	 SHORT $LN2@setupInput
$LN18@setupInput:

; 252  : 
; 253  :         case    ANTLR3_ENC_UTF16BE:
; 254  : 
; 255  :             // Encoding is definately Big Endian with no BOM
; 256  :             //
; 257  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  00293	41 b0 01	 mov	 r8b, 1
  00296	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  0029b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002a0	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
  002a5	90		 npad	 1

; 258  :             break;

  002a6	eb 57		 jmp	 SHORT $LN2@setupInput
$LN19@setupInput:

; 259  : 
; 260  :         case    ANTLR3_ENC_UTF16LE:
; 261  : 
; 262  :             // Encoding is definately Little Endian with no BOM
; 263  :             //
; 264  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  002a8	45 33 c0	 xor	 r8d, r8d
  002ab	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002b5	e8 00 00 00 00	 call	 antlr3UTF16SetupStream
  002ba	90		 npad	 1

; 265  :             break;

  002bb	eb 42		 jmp	 SHORT $LN2@setupInput
$LN20@setupInput:

; 266  : 
; 267  :         case    ANTLR3_ENC_UTF32BE:
; 268  : 
; 269  :             // Encoding is definately Big Endian with no BOM
; 270  :             //
; 271  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  002bd	41 b0 01	 mov	 r8b, 1
  002c0	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002ca	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
  002cf	90		 npad	 1

; 272  :             break;

  002d0	eb 2d		 jmp	 SHORT $LN2@setupInput
$LN21@setupInput:

; 273  : 
; 274  :         case    ANTLR3_ENC_UTF32LE:
; 275  : 
; 276  :             // Encoding is definately Little Endian with no BOM
; 277  :             //
; 278  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  002d2	45 33 c0	 xor	 r8d, r8d
  002d5	0f b6 54 24 20	 movzx	 edx, BYTE PTR isBigEndian$[rsp]
  002da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002df	e8 00 00 00 00	 call	 antlr3UTF32SetupStream
  002e4	90		 npad	 1

; 279  :             break;

  002e5	eb 18		 jmp	 SHORT $LN2@setupInput
$LN22@setupInput:

; 280  : 
; 281  :         case    ANTLR3_ENC_EBCDIC:
; 282  : 
; 283  :             // EBCDIC is basically the same as ASCII but with an on the
; 284  :             // fly translation to ASCII
; 285  :             //
; 286  :             antlr3EBCDICSetupStream(input);

  002e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002ec	e8 00 00 00 00	 call	 antlr3EBCDICSetupStream
  002f1	90		 npad	 1

; 287  :             break;

  002f2	eb 0b		 jmp	 SHORT $LN2@setupInput
$LN23@setupInput:
$LN24@setupInput:

; 288  : 
; 289  :         case    ANTLR3_ENC_8BIT:
; 290  :         default:
; 291  : 
; 292  :             // Standard 8bit/ASCII
; 293  :             //
; 294  :             antlr38BitSetupStream(input);

  002f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  002f9	e8 00 00 00 00	 call	 antlr38BitSetupStream
  002fe	90		 npad	 1
$LN2@setupInput:

; 295  :             break;
; 296  :     }    
; 297  : }

  002ff	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00303	5f		 pop	 rdi
  00304	c3		 ret	 0
  00305	0f 1f 00	 npad	 3
$LN27@setupInput:
  00308	00 00 00 00	 DD	 $LN23@setupInput
  0030c	00 00 00 00	 DD	 $LN6@setupInput
  00310	00 00 00 00	 DD	 $LN8@setupInput
  00314	00 00 00 00	 DD	 $LN18@setupInput
  00318	00 00 00 00	 DD	 $LN19@setupInput
  0031c	00 00 00 00	 DD	 $LN13@setupInput
  00320	00 00 00 00	 DD	 $LN20@setupInput
  00324	00 00 00 00	 DD	 $LN21@setupInput
  00328	00 00 00 00	 DD	 $LN22@setupInput
  0032c	00 00 00 00	 DD	 $LN24@setupInput
$LN26@setupInput:
  00330	00		 DB	 0
  00331	09		 DB	 9
  00332	09		 DB	 9
  00333	09		 DB	 9
  00334	01		 DB	 1
  00335	09		 DB	 9
  00336	09		 DB	 9
  00337	09		 DB	 9
  00338	09		 DB	 9
  00339	09		 DB	 9
  0033a	09		 DB	 9
  0033b	09		 DB	 9
  0033c	02		 DB	 2
  0033d	03		 DB	 3
  0033e	04		 DB	 4
  0033f	09		 DB	 9
  00340	09		 DB	 9
  00341	09		 DB	 9
  00342	09		 DB	 9
  00343	09		 DB	 9
  00344	09		 DB	 9
  00345	09		 DB	 9
  00346	09		 DB	 9
  00347	09		 DB	 9
  00348	09		 DB	 9
  00349	09		 DB	 9
  0034a	09		 DB	 9
  0034b	09		 DB	 9
  0034c	05		 DB	 5
  0034d	06		 DB	 6
  0034e	07		 DB	 7
  0034f	09		 DB	 9
  00350	09		 DB	 9
  00351	09		 DB	 9
  00352	09		 DB	 9
  00353	09		 DB	 9
  00354	09		 DB	 9
  00355	09		 DB	 9
  00356	09		 DB	 9
  00357	09		 DB	 9
  00358	09		 DB	 9
  00359	09		 DB	 9
  0035a	09		 DB	 9
  0035b	09		 DB	 9
  0035c	09		 DB	 9
  0035d	09		 DB	 9
  0035e	09		 DB	 9
  0035f	09		 DB	 9
  00360	09		 DB	 9
  00361	09		 DB	 9
  00362	09		 DB	 9
  00363	09		 DB	 9
  00364	09		 DB	 9
  00365	09		 DB	 9
  00366	09		 DB	 9
  00367	09		 DB	 9
  00368	09		 DB	 9
  00369	09		 DB	 9
  0036a	09		 DB	 9
  0036b	09		 DB	 9
  0036c	08		 DB	 8
setupInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fread
_TEXT	SEGMENT
fdsc$ = 48
count$ = 56
data$ = 64
antlr3Fread PROC					; COMDAT

; 429  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 430  :     return  (ANTLR3_UINT32)fread(data, (size_t)count, 1, fdsc);

  00013	8b 44 24 38	 mov	 eax, DWORD PTR count$[rsp]
  00017	4c 8b 4c 24 30	 mov	 r9, QWORD PTR fdsc$[rsp]
  0001c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00022	8b d0		 mov	 edx, eax
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 431  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
antlr3Fread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3read8Bit
_TEXT	SEGMENT
infile$ = 32
fSize$ = 40
input$ = 64
fileName$ = 72
antlr3read8Bit PROC					; COMDAT

; 354  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 355  : 	ANTLR3_FDSC	    infile;
; 356  : 	ANTLR3_UINT32	    fSize;
; 357  : 
; 358  : 	/* Open the OS file in read binary mode
; 359  : 	*/
; 360  : 	infile  = antlr3Fopen(fileName, "rb");

  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  00016	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fileName$[rsp]
  0001b	e8 00 00 00 00	 call	 antlr3Fopen
  00020	48 89 44 24 20	 mov	 QWORD PTR infile$[rsp], rax

; 361  : 
; 362  : 	/* Check that it was there
; 363  : 	*/
; 364  : 	if	(infile == NULL)

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR infile$[rsp], 0
  0002b	75 07		 jne	 SHORT $LN2@antlr3read

; 365  : 	{
; 366  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOFILE;

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	eb 71		 jmp	 SHORT $LN1@antlr3read
$LN2@antlr3read:

; 367  : 	}
; 368  : 
; 369  : 	/* It was there, so we can read the bytes now
; 370  : 	*/
; 371  : 	fSize   = antlr3Fsize(fileName);	/* Size of input file	*/

  00034	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fileName$[rsp]
  00039	e8 00 00 00 00	 call	 antlr3Fsize
  0003e	89 44 24 28	 mov	 DWORD PTR fSize$[rsp], eax

; 372  : 
; 373  : 	/* Allocate buffer for this input set   
; 374  : 	*/
; 375  : 	input->data	    = ANTLR3_MALLOC((size_t)fSize);

  00042	8b 44 24 28	 mov	 eax, DWORD PTR fSize$[rsp]
  00046	8b c8		 mov	 ecx, eax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 376  : 	input->sizeBuf  = fSize;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0005c	8b 4c 24 28	 mov	 ecx, DWORD PTR fSize$[rsp]
  00060	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 377  : 
; 378  : 	if	(input->data == NULL)

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00068	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006d	75 07		 jne	 SHORT $LN3@antlr3read

; 379  : 	{
; 380  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOMEM;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	eb 2f		 jmp	 SHORT $LN1@antlr3read
$LN3@antlr3read:

; 381  : 	}
; 382  : 
; 383  : 	input->isAllocated	= ANTLR3_TRUE;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0007b	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 384  : 
; 385  : 	/* Now we read the file. Characters are not converted to
; 386  : 	* the internal ANTLR encoding until they are read from the buffer
; 387  : 	*/
; 388  : 	antlr3Fread(infile, fSize, input->data);

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00087	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0008b	8b 54 24 28	 mov	 edx, DWORD PTR fSize$[rsp]
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR infile$[rsp]
  00094	e8 00 00 00 00	 call	 antlr3Fread

; 389  : 
; 390  : 	/* And close the file handle
; 391  : 	*/
; 392  : 	antlr3Fclose(infile);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR infile$[rsp]
  0009e	e8 00 00 00 00	 call	 antlr3Fclose

; 393  : 
; 394  : 	return  ANTLR3_SUCCESS;

  000a3	33 c0		 xor	 eax, eax
$LN1@antlr3read:

; 395  : }

  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
antlr3read8Bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fsize
_TEXT	SEGMENT
statbuf$ = 40
__$ArrayPad$ = 112
fileName$ = 144
antlr3Fsize PROC					; COMDAT

; 419  : {   

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00012	b9 18 00 00 00	 mov	 ecx, 24
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 420  :     struct _stat	statbuf;
; 421  : 
; 422  :     _stat((const char *)fileName, &statbuf);

  00035	48 8d 54 24 28	 lea	 rdx, QWORD PTR statbuf$[rsp]
  0003a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fileName$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64i32

; 423  : 
; 424  :     return (ANTLR3_UINT32)statbuf.st_size;

  00048	8b 44 24 3c	 mov	 eax, DWORD PTR statbuf$[rsp+20]

; 425  : }

  0004c	8b f8		 mov	 edi, eax
  0004e	48 8b cc	 mov	 rcx, rsp
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3Fsize$rtcFrameData
  00058	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0005d	8b c7		 mov	 eax, edi
  0005f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00064	48 33 cc	 xor	 rcx, rsp
  00067	e8 00 00 00 00	 call	 __security_check_cookie
  0006c	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
antlr3Fsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fclose
_TEXT	SEGMENT
fd$ = 48
antlr3Fclose PROC					; COMDAT

; 414  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 415  :     fclose(fd);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fd$[rsp]
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  00015	90		 npad	 1

; 416  : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5f		 pop	 rdi
  0001b	c3		 ret	 0
antlr3Fclose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3Fopen
_TEXT	SEGMENT
filename$ = 48
mode$ = 56
antlr3Fopen PROC					; COMDAT

; 405  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 406  :     return  (ANTLR3_FDSC)fopen((const char *)filename, mode);

  0000f	48 8b 54 24 38	 mov	 rdx, QWORD PTR mode$[rsp]
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR filename$[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen

; 407  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
antlr3Fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3StringStreamNew
_TEXT	SEGMENT
input$ = 32
data$ = 64
encoding$ = 72
size$ = 80
name$ = 88
antlr3StringStreamNew PROC				; COMDAT

; 90   : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 91   :     pANTLR3_INPUT_STREAM    input;
; 92   : 
; 93   :     // First order of business is to set up the stream and install the data pointer.
; 94   :     // Then we will work out the encoding and byte order and adjust the API functions that are installed for the
; 95   :     // default 8Bit stream accordingly.
; 96   :     //
; 97   :     input   = antlr3CreateStringStream(data);

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001d	e8 00 00 00 00	 call	 antlr3CreateStringStream
  00022	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 98   :     if  (input == NULL)

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  0002d	75 04		 jne	 SHORT $LN2@antlr3Stri

; 99   :     {
; 100  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 65		 jmp	 SHORT $LN1@antlr3Stri
$LN2@antlr3Stri:

; 101  :     }
; 102  :     
; 103  :     // Size (in bytes) of the given 'string'
; 104  :     //
; 105  :     input->sizeBuf		= size;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00038	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  0003c	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 106  : 
; 107  :     // We have the data in memory now so we can deal with it according to 
; 108  :     // the encoding scheme we were given by the user.
; 109  :     //
; 110  :     input->encoding = encoding;

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00044	8b 4c 24 48	 mov	 ecx, DWORD PTR encoding$[rsp]
  00048	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx

; 111  : 
; 112  :     // Now we need to work out the endian type and install any 
; 113  :     // API functions that differ from 8Bit
; 114  :     //
; 115  :     setupInputStream(input);

  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00053	e8 00 00 00 00	 call	 setupInputStream

; 116  : 
; 117  :     // Now we can set up the file name
; 118  :     //	
; 119  :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, name);

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0005d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00061	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0006b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0006f	ff 50 38	 call	 QWORD PTR [rax+56]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 120  :     input->fileName		= input->istream->streamName;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0008b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008f	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 121  : 
; 122  :     return input;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3Stri:

; 123  : }

  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
antlr3StringStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3filestream.c
;	COMDAT antlr3FileStreamNew
_TEXT	SEGMENT
input$ = 32
fileName$ = 64
encoding$ = 72
antlr3FileStreamNew PROC				; COMDAT

; 55   : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 56   :     pANTLR3_INPUT_STREAM input;
; 57   : 
; 58   :     // First order of business is to read the file into some buffer space
; 59   :     // as just straight 8 bit bytes. Then we will work out the encoding and
; 60   :     // byte order and adjust the API functions that are installed for the
; 61   :     // default 8Bit stream accordingly.
; 62   :     //
; 63   :     input   = antlr3CreateFileStream(fileName);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fileName$[rsp]
  00013	e8 00 00 00 00	 call	 antlr3CreateFileStream
  00018	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 64   :     if  (input == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR input$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@antlr3File

; 65   :     {
; 66   :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 59		 jmp	 SHORT $LN1@antlr3File
$LN2@antlr3File:

; 67   :     }
; 68   : 
; 69   :     // We have the data in memory now so we can deal with it according to 
; 70   :     // the encoding scheme we were given by the user.
; 71   :     //
; 72   :     input->encoding = encoding;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0002e	8b 4c 24 48	 mov	 ecx, DWORD PTR encoding$[rsp]
  00032	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx

; 73   : 
; 74   :     // Now we need to work out the endian type and install any 
; 75   :     // API functions that differ from 8Bit
; 76   :     //
; 77   :     setupInputStream(input);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  0003d	e8 00 00 00 00	 call	 setupInputStream

; 78   : 
; 79   :     // Now we can set up the file name
; 80   :     //	
; 81   :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, fileName);

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00047	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004b	48 8b 54 24 40	 mov	 rdx, QWORD PTR fileName$[rsp]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00055	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00059	ff 50 38	 call	 QWORD PTR [rax+56]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00061	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00064	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 82   :     input->fileName		= input->istream->streamName;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0006d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00075	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00079	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 83   : 
; 84   :     return input;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
$LN1@antlr3File:

; 85   : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
antlr3FileStreamNew ENDP
_TEXT	ENDS
END
