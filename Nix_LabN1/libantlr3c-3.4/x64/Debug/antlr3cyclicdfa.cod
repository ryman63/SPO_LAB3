; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34435.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3dfaspecialTransition
PUBLIC	antlr3dfaspecialStateTransition
PUBLIC	antlr3dfapredict
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3dfaspecialTransition DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$antlr3dfaspecialTransition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3dfaspecialStateTransition DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$antlr3dfaspecialStateTransition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3dfapredict DD imagerel $LN15
	DD	imagerel $LN15+734
	DD	imagerel $unwind$antlr3dfapredict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$noViableAlt DD imagerel noViableAlt
	DD	imagerel noViableAlt+160
	DD	imagerel $unwind$noViableAlt
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$noViableAlt DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3dfapredict DD 021901H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3dfaspecialStateTransition DD 011501H
	DD	07015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3dfaspecialTransition DD 011501H
	DD	07015H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT noViableAlt
_TEXT	SEGMENT
rec$ = 48
cdfa$ = 56
s$ = 64
noViableAlt PROC					; COMDAT

; 54   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 55   : 	// In backtracking mode, we just set the failed flag so that the
; 56   : 	// alt can just exit right now. If we are parsing though, then 
; 57   : 	// we want the exception to be raised.
; 58   : 	//
; 59   :     if	(rec->state->backtracking > 0)

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00019	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001d	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00021	7e 0f		 jle	 SHORT $LN2@noViableAl

; 60   :     {
; 61   : 		rec->state->failed = ANTLR3_TRUE;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00028	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002c	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 62   :     }

  00030	eb 68		 jmp	 SHORT $LN3@noViableAl
$LN2@noViableAl:

; 63   : 	else
; 64   : 	{
; 65   : 		rec->exConstruct(rec);

  00032	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$[rsp]
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0003c	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 66   : 		rec->state->exception->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00047	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004f	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 67   : 		rec->state->exception->message      = cdfa->description;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00067	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0006b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 68   : 		rec->state->exception->decisionNum  = cdfa->decisionNumber;

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00074	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00081	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00083	89 48 5c	 mov	 DWORD PTR [rax+92], ecx

; 69   : 		rec->state->exception->state        = s;

  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0008b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00093	8b 4c 24 40	 mov	 ecx, DWORD PTR s$[rsp]
  00097	89 48 60	 mov	 DWORD PTR [rax+96], ecx
$LN3@noViableAl:

; 70   : 	}
; 71   : }

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
noViableAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT antlr3dfapredict
_TEXT	SEGMENT
mark$ = 48
s$ = 56
specialState$ = 60
c$ = 64
snext$1 = 68
ctx$ = 96
rec$ = 104
is$ = 112
cdfa$ = 120
antlr3dfapredict PROC					; COMDAT

; 80   : {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 81   :     ANTLR3_MARKER	mark;
; 82   :     ANTLR3_INT32	s;
; 83   :     ANTLR3_INT32	specialState;
; 84   :     ANTLR3_INT32	c;
; 85   : 
; 86   :     mark	= is->mark(is);	    /* Store where we are right now	*/

  00019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  0001e	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00023	ff 50 38	 call	 QWORD PTR [rax+56]
  00026	48 89 44 24 30	 mov	 QWORD PTR mark$[rsp], rax

; 87   :     s		= 0;		    /* Always start with state 0	*/

  0002b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR s$[rsp], 0
$LN2@antlr3dfap:

; 88   :     
; 89   : 	for (;;)
; 90   : 	{
; 91   : 		/* Pick out any special state entry for this state
; 92   : 		 */
; 93   : 		specialState	= cdfa->special[s];

  00033	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00038	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0003d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00041	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00044	89 44 24 3c	 mov	 DWORD PTR specialState$[rsp], eax

; 94   : 
; 95   : 		/* Transition the special state and consume an input token
; 96   : 		 */
; 97   : 		if  (specialState >= 0)

  00048	83 7c 24 3c 00	 cmp	 DWORD PTR specialState$[rsp], 0
  0004d	0f 8c 81 00 00
	00		 jl	 $LN5@antlr3dfap

; 98   : 		{
; 99   : 			s = cdfa->specialStateTransition(ctx, rec, is, cdfa, specialState);

  00053	8b 44 24 3c	 mov	 eax, DWORD PTR specialState$[rsp]
  00057	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005b	4c 8b 4c 24 78	 mov	 r9, QWORD PTR cdfa$[rsp]
  00060	4c 8b 44 24 70	 mov	 r8, QWORD PTR is$[rsp]
  00065	48 8b 54 24 68	 mov	 rdx, QWORD PTR rec$[rsp]
  0006a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR cdfa$[rsp]
  00074	ff 50 10	 call	 QWORD PTR [rax+16]
  00077	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 100  : 
; 101  : 			// Error?
; 102  : 			//
; 103  : 			if	(s<0)

  0007b	83 7c 24 38 00	 cmp	 DWORD PTR s$[rsp], 0
  00080	7d 3f		 jge	 SHORT $LN6@antlr3dfap

; 104  : 			{
; 105  : 				// If the predicate/rule raised an exception then we leave it
; 106  : 				// in tact, else we have an NVA.
; 107  : 				//
; 108  : 				if	(rec->state->error != ANTLR3_TRUE)

  00082	48 8b 44 24 68	 mov	 rax, QWORD PTR rec$[rsp]
  00087	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008e	83 f8 01	 cmp	 eax, 1
  00091	74 15		 je	 SHORT $LN7@antlr3dfap

; 109  : 				{
; 110  : 					noViableAlt(rec,cdfa, s);

  00093	44 8b 44 24 38	 mov	 r8d, DWORD PTR s$[rsp]
  00098	48 8b 54 24 78	 mov	 rdx, QWORD PTR cdfa$[rsp]
  0009d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$[rsp]
  000a2	e8 00 00 00 00	 call	 noViableAlt
  000a7	90		 npad	 1
$LN7@antlr3dfap:

; 111  : 				}
; 112  : 				is->rewind(is, mark);

  000a8	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  000ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  000b7	ff 50 48	 call	 QWORD PTR [rax+72]

; 113  : 				return	0;

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 17 02 00 00	 jmp	 $LN1@antlr3dfap
$LN6@antlr3dfap:

; 114  : 			}
; 115  : 			is->consume(is);

  000c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  000c6	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  000cb	ff 50 28	 call	 QWORD PTR [rax+40]
  000ce	90		 npad	 1

; 116  : 			continue;

  000cf	e9 5f ff ff ff	 jmp	 $LN2@antlr3dfap
$LN5@antlr3dfap:

; 117  : 		}
; 118  : 
; 119  : 		/* Accept state?
; 120  : 		 */
; 121  : 		if  (cdfa->accept[s] >= 1)

  000d4	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  000d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  000de	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000e2	83 3c 81 01	 cmp	 DWORD PTR [rcx+rax*4], 1
  000e6	7c 28		 jl	 SHORT $LN8@antlr3dfap

; 122  : 		{
; 123  : 			is->rewind(is, mark);

  000e8	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  000ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  000f2	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  000f7	ff 50 48	 call	 QWORD PTR [rax+72]

; 124  : 			return  cdfa->accept[s];

  000fa	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  000ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00104	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00108	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0010b	e9 c8 01 00 00	 jmp	 $LN1@antlr3dfap
$LN8@antlr3dfap:

; 125  : 		}
; 126  : 
; 127  : 		/* Look for a normal transition state based upon the input token element
; 128  : 		 */
; 129  : 		c = is->_LA(is, 1);

  00110	ba 01 00 00 00	 mov	 edx, 1
  00115	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  0011a	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  0011f	ff 50 30	 call	 QWORD PTR [rax+48]
  00122	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax

; 130  : 
; 131  : 		/* Check against min and max for this state
; 132  : 		 */
; 133  : 		if  (c>= cdfa->min[s] && c <= cdfa->max[s])

  00126	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  0012b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00130	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00134	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00137	39 44 24 40	 cmp	 DWORD PTR c$[rsp], eax
  0013b	0f 8c df 00 00
	00		 jl	 $LN9@antlr3dfap
  00141	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00146	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0014b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0014f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00152	39 44 24 40	 cmp	 DWORD PTR c$[rsp], eax
  00156	0f 8f c4 00 00
	00		 jg	 $LN9@antlr3dfap

; 134  : 		{
; 135  : 			ANTLR3_INT32   snext;
; 136  : 
; 137  : 			/* What is the next state?
; 138  : 			 */
; 139  : 			snext = cdfa->transition[s][c - cdfa->min[s]];

  0015c	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00161	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00166	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0016a	48 63 54 24 38	 movsxd	 rdx, DWORD PTR s$[rsp]
  0016f	4c 8b 44 24 78	 mov	 r8, QWORD PTR cdfa$[rsp]
  00174	4d 8b 40 38	 mov	 r8, QWORD PTR [r8+56]
  00178	41 8b 14 90	 mov	 edx, DWORD PTR [r8+rdx*4]
  0017c	44 8b 44 24 40	 mov	 r8d, DWORD PTR c$[rsp]
  00181	44 2b c2	 sub	 r8d, edx
  00184	41 8b d0	 mov	 edx, r8d
  00187	48 63 d2	 movsxd	 rdx, edx
  0018a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0018e	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00191	89 44 24 44	 mov	 DWORD PTR snext$1[rsp], eax

; 140  : 
; 141  : 			if	(snext < 0)

  00195	83 7c 24 44 00	 cmp	 DWORD PTR snext$1[rsp], 0
  0019a	7d 69		 jge	 SHORT $LN10@antlr3dfap

; 142  : 			{
; 143  : 				/* Was in range but not a normal transition
; 144  : 				 * must check EOT, which is like the else clause.
; 145  : 				 * eot[s]>=0 indicates that an EOT edge goes to another
; 146  : 				 * state.
; 147  : 				 */
; 148  : 				if  (cdfa->eot[s] >= 0)

  0019c	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  001a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  001a6	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001aa	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  001ae	7c 28		 jl	 SHORT $LN11@antlr3dfap

; 149  : 				{
; 150  : 					s = cdfa->eot[s];

  001b0	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  001b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  001ba	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001be	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001c1	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 151  : 					is->consume(is);

  001c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  001cf	ff 50 28	 call	 QWORD PTR [rax+40]
  001d2	90		 npad	 1

; 152  : 					continue;

  001d3	e9 5b fe ff ff	 jmp	 $LN2@antlr3dfap
$LN11@antlr3dfap:

; 153  : 				}
; 154  : 				noViableAlt(rec,cdfa, s);

  001d8	44 8b 44 24 38	 mov	 r8d, DWORD PTR s$[rsp]
  001dd	48 8b 54 24 78	 mov	 rdx, QWORD PTR cdfa$[rsp]
  001e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$[rsp]
  001e7	e8 00 00 00 00	 call	 noViableAlt

; 155  : 				is->rewind(is, mark);

  001ec	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  001f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  001f6	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  001fb	ff 50 48	 call	 QWORD PTR [rax+72]

; 156  : 				return	0;

  001fe	33 c0		 xor	 eax, eax
  00200	e9 d3 00 00 00	 jmp	 $LN1@antlr3dfap
$LN10@antlr3dfap:

; 157  : 			}
; 158  : 
; 159  : 			/* New current state - move to it
; 160  : 			 */
; 161  : 			s	= snext;

  00205	8b 44 24 44	 mov	 eax, DWORD PTR snext$1[rsp]
  00209	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 162  : 			is->consume(is);

  0020d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  00212	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00217	ff 50 28	 call	 QWORD PTR [rax+40]
  0021a	90		 npad	 1

; 163  : 			continue;

  0021b	e9 13 fe ff ff	 jmp	 $LN2@antlr3dfap
$LN9@antlr3dfap:

; 164  : 		}
; 165  : 		/* EOT Transition?
; 166  : 		 */
; 167  : 		if  (cdfa->eot[s] >= 0)

  00220	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00225	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0022a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0022e	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00232	7c 28		 jl	 SHORT $LN12@antlr3dfap

; 168  : 		{
; 169  : 			s	= cdfa->eot[s];

  00234	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00239	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0023e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00242	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00245	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 170  : 			is->consume(is);

  00249	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  0024e	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00253	ff 50 28	 call	 QWORD PTR [rax+40]
  00256	90		 npad	 1

; 171  : 			continue;

  00257	e9 d7 fd ff ff	 jmp	 $LN2@antlr3dfap
$LN12@antlr3dfap:

; 172  : 		}
; 173  : 		/* EOF transition to accept state?
; 174  : 		 */
; 175  : 		if  ( c == ANTLR3_TOKEN_EOF && cdfa->eof[s] >= 0)

  0025c	83 7c 24 40 ff	 cmp	 DWORD PTR c$[rsp], -1	; ffffffffH
  00261	75 46		 jne	 SHORT $LN13@antlr3dfap
  00263	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  00268	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  0026d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00271	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00275	7c 32		 jl	 SHORT $LN13@antlr3dfap

; 176  : 		{
; 177  : 			is->rewind(is, mark);

  00277	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  0027c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  00281	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  00286	ff 50 48	 call	 QWORD PTR [rax+72]

; 178  : 			return  cdfa->accept[cdfa->eof[s]];

  00289	48 63 44 24 38	 movsxd	 rax, DWORD PTR s$[rsp]
  0028e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  00293	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00297	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  0029b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cdfa$[rsp]
  002a0	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002a4	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  002a7	eb 2f		 jmp	 SHORT $LN1@antlr3dfap
$LN13@antlr3dfap:

; 179  : 		}
; 180  : 
; 181  : 		/* No alt, so bomb
; 182  : 		 */
; 183  : 		noViableAlt(rec, cdfa, s);

  002a9	44 8b 44 24 38	 mov	 r8d, DWORD PTR s$[rsp]
  002ae	48 8b 54 24 78	 mov	 rdx, QWORD PTR cdfa$[rsp]
  002b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rec$[rsp]
  002b8	e8 00 00 00 00	 call	 noViableAlt

; 184  : 		is->rewind(is, mark);

  002bd	48 8b 54 24 30	 mov	 rdx, QWORD PTR mark$[rsp]
  002c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR is$[rsp]
  002c7	48 8b 44 24 70	 mov	 rax, QWORD PTR is$[rsp]
  002cc	ff 50 48	 call	 QWORD PTR [rax+72]

; 185  : 		return 0;

  002cf	33 c0		 xor	 eax, eax
  002d1	eb 05		 jmp	 SHORT $LN1@antlr3dfap

; 186  : 	}

  002d3	e9 5b fd ff ff	 jmp	 $LN2@antlr3dfap
$LN1@antlr3dfap:

; 187  : 
; 188  : }

  002d8	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002dc	5f		 pop	 rdi
  002dd	c3		 ret	 0
antlr3dfapredict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT antlr3dfaspecialStateTransition
_TEXT	SEGMENT
ctx$ = 16
recognizer$ = 24
is$ = 32
dfa$ = 40
s$ = 48
antlr3dfaspecialStateTransition PROC			; COMDAT

; 194  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi

; 195  :     return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1

; 196  : }

  0001a	5f		 pop	 rdi
  0001b	c3		 ret	 0
antlr3dfaspecialStateTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3cyclicdfa.c
;	COMDAT antlr3dfaspecialTransition
_TEXT	SEGMENT
ctx$ = 16
recognizer$ = 24
is$ = 32
dfa$ = 40
s$ = 48
antlr3dfaspecialTransition PROC				; COMDAT

; 202  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi

; 203  :     return 0;

  00015	33 c0		 xor	 eax, eax

; 204  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
antlr3dfaspecialTransition ENDP
_TEXT	ENDS
END
