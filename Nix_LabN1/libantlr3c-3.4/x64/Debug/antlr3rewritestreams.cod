; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3RewriteRuleTOKENStreamNewAE
PUBLIC	antlr3RewriteRuleTOKENStreamNewAEE
PUBLIC	antlr3RewriteRuleTOKENStreamNewAEV
PUBLIC	antlr3RewriteRuleNODEStreamNewAE
PUBLIC	antlr3RewriteRuleNODEStreamNewAEE
PUBLIC	antlr3RewriteRuleNODEStreamNewAEV
PUBLIC	antlr3RewriteRuleSubtreeStreamNewAE
PUBLIC	antlr3RewriteRuleSubtreeStreamNewAEE
PUBLIC	antlr3RewriteRuleSubtreeStreamNewAEV
PUBLIC	??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@ ; `string'
PUBLIC	??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@ ; `string'
PUBLIC	??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@	; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleTOKENStreamNewAE DD imagerel $LN4
	DD	imagerel $LN4+106
	DD	imagerel $unwind$antlr3RewriteRuleTOKENStreamNewAE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleTOKENStreamNewAEE DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$antlr3RewriteRuleTOKENStreamNewAEE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleTOKENStreamNewAEV DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$antlr3RewriteRuleTOKENStreamNewAEV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleNODEStreamNewAE DD imagerel $LN4
	DD	imagerel $LN4+141
	DD	imagerel $unwind$antlr3RewriteRuleNODEStreamNewAE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleNODEStreamNewAEE DD imagerel $LN3
	DD	imagerel $LN3+136
	DD	imagerel $unwind$antlr3RewriteRuleNODEStreamNewAEE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleNODEStreamNewAEV DD imagerel $LN3
	DD	imagerel $LN3+136
	DD	imagerel $unwind$antlr3RewriteRuleNODEStreamNewAEV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleSubtreeStreamNewAE DD imagerel $LN4
	DD	imagerel $LN4+125
	DD	imagerel $unwind$antlr3RewriteRuleSubtreeStreamNewAE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleSubtreeStreamNewAEE DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$antlr3RewriteRuleSubtreeStreamNewAEE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleSubtreeStreamNewAEV DD imagerel $LN4
	DD	imagerel $LN4+132
	DD	imagerel $unwind$antlr3RewriteRuleSubtreeStreamNewAEV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset DD	imagerel reset
	DD	imagerel reset+28
	DD	imagerel $unwind$reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add DD	imagerel add
	DD	imagerel add+298
	DD	imagerel $unwind$add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$next DD	imagerel next
	DD	imagerel next+107
	DD	imagerel $unwind$next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextTree DD imagerel nextTree
	DD	imagerel nextTree+130
	DD	imagerel $unwind$nextTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextToken DD imagerel nextToken
	DD	imagerel nextToken+29
	DD	imagerel $unwind$nextToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_next DD	imagerel _next
	DD	imagerel _next+226
	DD	imagerel $unwind$_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTok DD imagerel dupTok
	DD	imagerel dupTok+49
	DD	imagerel $unwind$dupTok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTree DD imagerel dupTree
	DD	imagerel dupTree+50
	DD	imagerel $unwind$dupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTreeNode DD imagerel dupTreeNode
	DD	imagerel dupTreeNode+49
	DD	imagerel $unwind$dupTreeNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toTree DD imagerel toTree
	DD	imagerel toTree+18
	DD	imagerel $unwind$toTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toTreeNode DD imagerel toTreeNode
	DD	imagerel toTreeNode+50
	DD	imagerel $unwind$toTreeNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$hasNext DD imagerel hasNext
	DD	imagerel hasNext+91
	DD	imagerel $unwind$hasNext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextNode DD imagerel nextNode
	DD	imagerel nextNode+124
	DD	imagerel $unwind$nextNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextNodeNode DD imagerel nextNodeNode
	DD	imagerel nextNodeNode+29
	DD	imagerel $unwind$nextNodeNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextNodeToken DD imagerel nextNodeToken
	DD	imagerel nextNodeToken+66
	DD	imagerel $unwind$nextNodeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$size DD	imagerel size
	DD	imagerel size+73
	DD	imagerel $unwind$size
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getDescription DD imagerel getDescription
	DD	imagerel getDescription+45
	DD	imagerel $unwind$getDescription
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeRS DD imagerel freeRS
	DD	imagerel freeRS+232
	DD	imagerel $unwind$freeRS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$expungeRS DD imagerel expungeRS
	DD	imagerel expungeRS+77
	DD	imagerel $unwind$expungeRS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeNodeRS DD imagerel freeNodeRS
	DD	imagerel freeNodeRS+394
	DD	imagerel $unwind$freeNodeRS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleElementStreamNewAE DD imagerel antlr3RewriteRuleElementStreamNewAE
	DD	imagerel antlr3RewriteRuleElementStreamNewAE+466
	DD	imagerel $unwind$antlr3RewriteRuleElementStreamNewAE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleElementStreamNewAEE DD imagerel antlr3RewriteRuleElementStreamNewAEE
	DD	imagerel antlr3RewriteRuleElementStreamNewAEE+102
	DD	imagerel $unwind$antlr3RewriteRuleElementStreamNewAEE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3RewriteRuleElementStreamNewAEV DD imagerel antlr3RewriteRuleElementStreamNewAEV
	DD	imagerel antlr3RewriteRuleElementStreamNewAEV+169
	DD	imagerel $unwind$antlr3RewriteRuleElementStreamNewAEV
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@
CONST	SEGMENT
??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@ DB '<unknown source>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@
CONST	SEGMENT
??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@ DB 'dup() '
	DB	'cannot be called on a node rewrite stream!!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@
CONST	SEGMENT
??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@ DB 'dup()'
	DB	' cannot be called on a token rewrite stream!!', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleElementStreamNewAEV DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleElementStreamNewAEE DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleElementStreamNewAE DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeNodeRS DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$expungeRS DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeRS DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getDescription DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$size DD	020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextNodeToken DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextNodeNode DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextNode DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hasNext DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toTreeNode DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toTree DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTreeNode DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTree DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTok DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_next DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextToken DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextTree DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$next DD	020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add DD	021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleSubtreeStreamNewAEV DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleSubtreeStreamNewAEE DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleSubtreeStreamNewAE DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleNODEStreamNewAEV DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleNODEStreamNewAEE DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleNODEStreamNewAE DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleTOKENStreamNewAEV DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleTOKENStreamNewAEE DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3RewriteRuleTOKENStreamNewAE DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleElementStreamNewAEV
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
vector$ = 88
antlr3RewriteRuleElementStreamNewAEV PROC		; COMDAT

; 281  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 282  : 	pANTLR3_REWRITE_RULE_ELEMENT_STREAM	stream;
; 283  : 
; 284  : 	// First job is to create the memory we need.
; 285  : 	//
; 286  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  00019	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  0001e	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00028	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAE
  0002d	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 287  : 
; 288  : 	if (stream == NULL)

  00032	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00038	75 07		 jne	 SHORT $LN2@antlr3Rewr

; 289  : 	{
; 290  : 		return stream;

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003f	eb 62		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 291  : 	}
; 292  : 
; 293  : 	// Stream seems good so we need to install the vector we were
; 294  : 	// given. We assume that someone else is going to free the
; 295  : 	// vector.
; 296  : 	//
; 297  : 	if	(stream->elements != NULL && stream->elements->factoryMade == ANTLR3_FALSE && stream->freeElements == ANTLR3_TRUE )

  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00046	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0004b	74 3a		 je	 SHORT $LN3@antlr3Rewr
  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00052	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00056	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  0005d	85 c0		 test	 eax, eax
  0005f	75 26		 jne	 SHORT $LN3@antlr3Rewr
  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00066	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0006a	83 f8 01	 cmp	 eax, 1
  0006d	75 18		 jne	 SHORT $LN3@antlr3Rewr

; 298  : 	{
; 299  : 		stream->elements->free(stream->elements);

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00074	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  0007d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00081	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]
$LN3@antlr3Rewr:

; 300  : 	}
; 301  : 	stream->elements		= vector;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vector$[rsp]
  00091	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 302  : 	stream->freeElements	= ANTLR3_FALSE;

  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0009a	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 303  : 	return stream;

  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 304  : }

  000a3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
antlr3RewriteRuleElementStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleElementStreamNewAEE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
oneElement$ = 88
antlr3RewriteRuleElementStreamNewAEE PROC		; COMDAT

; 258  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 259  : 	pANTLR3_REWRITE_RULE_ELEMENT_STREAM	stream;
; 260  : 
; 261  : 	// First job is to create the memory we need.
; 262  : 	//
; 263  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  00019	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  0001e	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00028	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAE
  0002d	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 264  : 
; 265  : 	if (stream == NULL)

  00032	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00038	75 04		 jne	 SHORT $LN2@antlr3Rewr

; 266  : 	{
; 267  : 		return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 22		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 268  : 	}
; 269  : 
; 270  : 	// Stream seems good so we need to add the supplied element
; 271  : 	//
; 272  : 	if	(oneElement != NULL)

  0003e	48 83 7c 24 58
	00		 cmp	 QWORD PTR oneElement$[rsp], 0
  00044	74 15		 je	 SHORT $LN3@antlr3Rewr

; 273  : 	{
; 274  : 		stream->add(stream, oneElement, NULL);

  00046	45 33 c0	 xor	 r8d, r8d
  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR oneElement$[rsp]
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stream$[rsp]
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00058	ff 50 48	 call	 QWORD PTR [rax+72]
$LN3@antlr3Rewr:

; 275  : 	}
; 276  : 	return stream;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 277  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
antlr3RewriteRuleElementStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleElementStreamNewAE
_TEXT	SEGMENT
stream$ = 32
tv138 = 40
adaptor$ = 64
rec$ = 72
description$ = 80
antlr3RewriteRuleElementStreamNewAE PROC		; COMDAT

; 188  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 189  : 	pANTLR3_REWRITE_RULE_ELEMENT_STREAM	stream;
; 190  : 
; 191  : 	// First - do we already have a rewrite stream that was returned
; 192  : 	// to the pool? If we do, then we will just reuse it by resetting
; 193  : 	// the generic interface.
; 194  : 	//
; 195  : 	if	(rec->state->rStreams->count > 0)

  00014	48 8b 44 24 48	 mov	 rax, QWORD PTR rec$[rsp]
  00019	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001d	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  00024	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00028	76 4e		 jbe	 SHORT $LN2@antlr3Rewr

; 196  : 	{
; 197  : 		// Remove the entry from the vector. We do not
; 198  : 		// cause it to be freed by using remove.
; 199  : 		//
; 200  : 		stream = rec->state->rStreams->remove(rec->state->rStreams, rec->state->rStreams->count - 1);

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR rec$[rsp]
  0002f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00033	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	ff c8		 dec	 eax
  0003f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rec$[rsp]
  00044	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00048	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  0004d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00051	48 8b 92 b0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+176]
  00058	48 89 54 24 28	 mov	 QWORD PTR tv138[rsp], rdx
  0005d	8b d0		 mov	 edx, eax
  0005f	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR tv138[rsp]
  0006b	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
  00071	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 201  : 
; 202  : 		// We found a stream we can reuse.
; 203  : 		// If the stream had a vector, then it will have been cleared
; 204  : 		// when the freeRS was called that put it in this stack
; 205  : 		//
; 206  : 	}

  00076	eb 35		 jmp	 SHORT $LN3@antlr3Rewr
$LN2@antlr3Rewr:

; 207  : 	else
; 208  : 	{
; 209  : 		// Ok, we need to allocate a new one as there were none on the stack.
; 210  : 		// First job is to create the memory we need.
; 211  : 		//
; 212  : 		stream	= (pANTLR3_REWRITE_RULE_ELEMENT_STREAM) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_REWRITE_RULE_ELEMENT_STREAM)));

  00078	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00083	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 213  : 
; 214  : 		if	(stream == NULL)

  00088	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  0008e	75 07		 jne	 SHORT $LN4@antlr3Rewr

; 215  : 		{
; 216  : 			return	NULL;

  00090	33 c0		 xor	 eax, eax
  00092	e9 35 01 00 00	 jmp	 $LN1@antlr3Rewr
$LN4@antlr3Rewr:

; 217  : 		}
; 218  : 		stream->elements		= NULL;

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0009c	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 219  : 		stream->freeElements	= ANTLR3_FALSE;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000a9	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0
$LN3@antlr3Rewr:

; 220  : 	}
; 221  : 
; 222  : 	// Populate the generic interface
; 223  : 	//
; 224  : 	stream->rec				= rec;

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rec$[rsp]
  000b7	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 225  : 	stream->reset			= reset;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reset
  000c7	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 226  : 	stream->add				= add;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:add
  000d7	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 227  : 	stream->next			= next;

  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:next
  000e7	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 228  : 	stream->nextTree		= nextTree;

  000eb	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextTree
  000f7	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 229  : 	stream->nextNode		= nextNode;

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNode
  00107	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 230  : 	stream->nextToken		= nextToken;

  0010e	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextToken
  0011a	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 231  : 	stream->_next			= _next;

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_next
  0012a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 232  : 	stream->hasNext			= hasNext;

  0012e	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hasNext
  0013a	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 233  : 	stream->size			= size;

  00141	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:size
  0014d	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 234  : 	stream->getDescription  = getDescription;

  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getDescription
  00160	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 235  : 	stream->toTree			= toTree;

  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toTree
  00173	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 236  : 	stream->free			= freeRS;

  00177	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeRS
  00183	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 237  : 	stream->singleElement	= NULL;

  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0018f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 238  : 
; 239  : 	// Reset the stream to empty.
; 240  : 	//
; 241  : 
; 242  : 	stream->cursor			= 0;

  00197	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0019c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 243  : 	stream->dirty			= ANTLR3_FALSE;

  001a2	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001a7	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 244  : 
; 245  : 	// Install the description
; 246  : 	//
; 247  : 	stream->elementDescription	= description;

  001ab	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR description$[rsp]
  001b5	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 248  : 
; 249  : 	// Install the adaptor
; 250  : 	//
; 251  : 	stream->adaptor		= adaptor;

  001b9	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  001be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  001c3	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 252  : 
; 253  : 	return stream;

  001c7	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 254  : }

  001cc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001d0	5f		 pop	 rdi
  001d1	c3		 ret	 0
antlr3RewriteRuleElementStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT freeNodeRS
_TEXT	SEGMENT
tree$ = 32
i$1 = 40
factory$2 = 48
tv147 = 56
stream$ = 80
freeNodeRS PROC						; COMDAT

; 109  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 110  :     pANTLR3_BASE_TREE tree;
; 111  : 
; 112  :     // Before placing the stream back in the pool, we
; 113  : 	// need to clear any vector it has. This is so any
; 114  : 	// free pointers that are associated with the
; 115  : 	// entires are called. However, if this particular function is called
; 116  :     // then we know that the entries in the stream are definately
; 117  :     // tree nodes. Hence we check to see if any of them were nilNodes as
; 118  :     // if they were, we can reuse them.
; 119  : 	//
; 120  : 	if	(stream->elements != NULL)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  0000f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00014	0f 84 e3 00 00
	00		 je	 $LN5@freeNodeRS

; 121  : 	{
; 122  :         // We have some elements to traverse
; 123  :         //
; 124  :         ANTLR3_UINT32 i;
; 125  : 
; 126  :         for (i = 1; i<= stream->elements->count; i++)

  0001a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00022	eb 0a		 jmp	 SHORT $LN4@freeNodeRS
$LN2@freeNodeRS:
  00024	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00028	ff c0		 inc	 eax
  0002a	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
$LN4@freeNodeRS:
  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 28	 cmp	 DWORD PTR i$1[rsp], eax
  0003e	77 3e		 ja	 SHORT $LN3@freeNodeRS

; 127  :         {
; 128  :             tree = (pANTLR3_BASE_TREE)(stream->elements->elements[i-1].element);

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  00045	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00049	8b 4c 24 28	 mov	 ecx, DWORD PTR i$1[rsp]
  0004d	ff c9		 dec	 ecx
  0004f	8b c9		 mov	 ecx, ecx
  00051	48 6b c9 10	 imul	 rcx, rcx, 16
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0005c	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 129  :             if  (tree != NULL && tree->isNilNode(tree))

  00061	48 83 7c 24 20
	00		 cmp	 QWORD PTR tree$[rsp], 0
  00067	74 13		 je	 SHORT $LN7@freeNodeRS
  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  00073	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00079	0f b6 c0	 movzx	 eax, al
$LN7@freeNodeRS:

; 130  :             {
; 131  :                 // Had to remove this for now, check is not comprehensive enough
; 132  :                 // tree->reuse(tree);
; 133  :             }
; 134  : 
; 135  :         }

  0007c	eb a6		 jmp	 SHORT $LN2@freeNodeRS
$LN3@freeNodeRS:

; 136  : 		// Factory generated vectors can be returned to the
; 137  : 		// vector factory for later reuse.
; 138  : 		//
; 139  : 		if	(stream->elements->factoryMade == ANTLR3_TRUE)

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  00083	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00087	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  0008e	83 f8 01	 cmp	 eax, 1
  00091	75 47		 jne	 SHORT $LN8@freeNodeRS

; 140  : 		{
; 141  : 			pANTLR3_VECTOR_FACTORY factory = ((pANTLR3_COMMON_TREE_ADAPTOR)(stream->adaptor->super))->arboretum->vFactory;

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  00098	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0009c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009f	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  000a6	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  000ad	48 89 44 24 30	 mov	 QWORD PTR factory$2[rsp], rax

; 142  : 			factory->returnVector(factory, stream->elements);

  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  000b7	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$2[rsp]
  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$2[rsp]
  000c5	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 143  : 
; 144  : 			stream->elements = NULL;

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  000d0	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 145  : 		} 

  000d8	eb 21		 jmp	 SHORT $LN9@freeNodeRS
$LN8@freeNodeRS:

; 146  : 		else
; 147  : 		{
; 148  : 			stream->elements->clear(stream->elements);

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  000df	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stream$[rsp]
  000e8	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ec	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 149  : 			stream->freeElements = ANTLR3_TRUE;

  000f2	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  000f7	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
$LN9@freeNodeRS:

; 150  : 		}
; 151  : 	}

  000fb	eb 43		 jmp	 SHORT $LN6@freeNodeRS
$LN5@freeNodeRS:

; 152  : 	else
; 153  : 	{
; 154  :         if  (stream->singleElement != NULL)

  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  00102	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00107	74 21		 je	 SHORT $LN10@freeNodeRS

; 155  :         {
; 156  :             tree = (pANTLR3_BASE_TREE)(stream->singleElement);

  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  0010e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00112	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 157  :             if  (tree->isNilNode(tree))

  00117	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  0011c	48 8b 44 24 20	 mov	 rax, QWORD PTR tree$[rsp]
  00121	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00127	0f b6 c0	 movzx	 eax, al
$LN10@freeNodeRS:

; 158  :             {
; 159  :                 // Had to remove this for now, check is not comprehensive enough
; 160  :               //   tree->reuse(tree);
; 161  :             }
; 162  :         }
; 163  :         stream->singleElement = NULL;

  0012a	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  0012f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 164  : 		stream->freeElements = ANTLR3_FALSE; // Just in case

  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  0013c	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0
$LN6@freeNodeRS:

; 165  : 	}
; 166  : 
; 167  : 	// Add the stream into the recognizer stream stack vector
; 168  : 	// adding the stream memory free routine so that
; 169  : 	// it is thrown away when the stack vector is destroyed
; 170  : 	//
; 171  : 	stream->rec->state->rStreams->add(stream->rec->state->rStreams, stream, (void(*)(void *))expungeRS);

  00140	48 8b 44 24 50	 mov	 rax, QWORD PTR stream$[rsp]
  00145	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00149	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0014d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stream$[rsp]
  00152	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00156	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0015a	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  00161	48 89 4c 24 38	 mov	 QWORD PTR tv147[rsp], rcx
  00166	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:expungeRS
  0016d	48 8b 54 24 50	 mov	 rdx, QWORD PTR stream$[rsp]
  00172	48 8b 88 b0 00
	00 00		 mov	 rcx, QWORD PTR [rax+176]
  00179	48 8b 44 24 38	 mov	 rax, QWORD PTR tv147[rsp]
  0017e	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 172  : }

  00184	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
freeNodeRS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT expungeRS
_TEXT	SEGMENT
stream$ = 48
expungeRS PROC						; COMDAT

; 175  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 176  : 
; 177  : 	if (stream->freeElements == ANTLR3_TRUE && stream->elements != NULL)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  0000f	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00013	83 f8 01	 cmp	 eax, 1
  00016	75 24		 jne	 SHORT $LN2@expungeRS
  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  0001d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00022	74 18		 je	 SHORT $LN2@expungeRS

; 178  : 	{
; 179  : 		stream->elements->free(stream->elements);

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00029	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  00032	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00036	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]
$LN2@expungeRS:

; 180  : 	}
; 181  : 	ANTLR3_FREE(stream);

  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 182  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
expungeRS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT freeRS
_TEXT	SEGMENT
factory$1 = 32
tv89 = 40
stream$ = 64
freeRS	PROC						; COMDAT

; 66   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 67   : 	// Before placing the stream back in the pool, we
; 68   : 	// need to clear any vector it has. This is so any
; 69   : 	// free pointers that are associated with the
; 70   : 	// entires are called.
; 71   : 	//
; 72   : 	if	(stream->elements != NULL)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0000f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00014	74 7f		 je	 SHORT $LN2@freeRS

; 73   : 	{
; 74   : 		// Factory generated vectors can be returned to the
; 75   : 		// vector factory for later reuse.
; 76   : 		//
; 77   : 		if	(stream->elements->factoryMade == ANTLR3_TRUE)

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0001b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001f	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  00026	83 f8 01	 cmp	 eax, 1
  00029	75 47		 jne	 SHORT $LN4@freeRS

; 78   : 		{
; 79   : 			pANTLR3_VECTOR_FACTORY factory = ((pANTLR3_COMMON_TREE_ADAPTOR)(stream->adaptor->super))->arboretum->vFactory;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00030	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  0003e	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  00045	48 89 44 24 20	 mov	 QWORD PTR factory$1[rsp], rax

; 80   : 			factory->returnVector(factory, stream->elements);

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0004f	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$1[rsp]
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$1[rsp]
  0005d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 81   : 
; 82   : 			stream->elements = NULL;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00068	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 83   : 		} 

  00070	eb 21		 jmp	 SHORT $LN5@freeRS
$LN4@freeRS:

; 84   : 		else
; 85   : 		{
; 86   : 			// Other vectors we clear and allow to be reused if they come off the
; 87   : 			// rewrite stream free stack and are reused.
; 88   : 			//
; 89   : 			stream->elements->clear(stream->elements);

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00077	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00080	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00084	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 90   : 			stream->freeElements = ANTLR3_TRUE;

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0008f	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
$LN5@freeRS:

; 91   : 		}
; 92   : 	}

  00093	eb 09		 jmp	 SHORT $LN3@freeRS
$LN2@freeRS:

; 93   : 	else
; 94   : 	{
; 95   : 		stream->freeElements = ANTLR3_FALSE; // Just in case

  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0009a	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0
$LN3@freeRS:

; 96   : 	}
; 97   : 
; 98   : 	// Add the stream into the recognizer stream stack vector
; 99   : 	// adding the stream memory free routine so that
; 100  : 	// it is thrown away when the stack vector is destroyed
; 101  : 	//
; 102  : 	stream->rec->state->rStreams->add(stream->rec->state->rStreams, stream, (void(*)(void *))expungeRS);

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000a3	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000a7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000b0	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000b4	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b8	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  000bf	48 89 4c 24 28	 mov	 QWORD PTR tv89[rsp], rcx
  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:expungeRS
  000cb	48 8b 54 24 40	 mov	 rdx, QWORD PTR stream$[rsp]
  000d0	48 8b 88 b0 00
	00 00		 mov	 rcx, QWORD PTR [rax+176]
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR tv89[rsp]
  000dc	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 103  : }

  000e2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
freeRS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT getDescription
_TEXT	SEGMENT
stream$ = 16
getDescription PROC					; COMDAT

; 837  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 838  : 	if (stream->elementDescription == NULL)

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR stream$[rsp]
  0000b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00010	75 10		 jne	 SHORT $LN2@getDescrip

; 839  : 	{
; 840  : 		stream->elementDescription = "<unknown source>";

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR stream$[rsp]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@
  0001e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
$LN2@getDescrip:

; 841  : 	}
; 842  : 
; 843  : 	return  stream->elementDescription;

  00022	48 8b 44 24 10	 mov	 rax, QWORD PTR stream$[rsp]
  00027	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]

; 844  : }

  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
getDescription ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT size
_TEXT	SEGMENT
n$ = 0
stream$ = 32
size	PROC						; COMDAT

; 812  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 813  : 	ANTLR3_UINT32   n = 0;

  0000a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR n$[rsp], 0

; 814  : 
; 815  : 	/// Should be a count of one if singleElement is set. I copied this
; 816  : 	/// logic from the java implementation, which I suspect is just guarding
; 817  : 	/// against someone setting singleElement and forgetting to NULL it out
; 818  : 	///
; 819  : 	if (stream->singleElement != NULL)

  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00016	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0001b	74 09		 je	 SHORT $LN2@size

; 820  : 	{
; 821  : 		n = 1;

  0001d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR n$[rsp], 1

; 822  : 	}

  00024	eb 1a		 jmp	 SHORT $LN3@size
$LN2@size:

; 823  : 	else
; 824  : 	{
; 825  : 		if (stream->elements != NULL)

  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0002b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00030	74 0e		 je	 SHORT $LN4@size

; 826  : 		{
; 827  : 			return (ANTLR3_UINT32)(stream->elements->count);

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00037	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003e	eb 03		 jmp	 SHORT $LN1@size
$LN4@size:
$LN3@size:

; 828  : 		}
; 829  : 	}
; 830  : 	return n;

  00040	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
$LN1@size:

; 831  : }

  00043	48 83 c4 10	 add	 rsp, 16
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
size	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT nextNodeToken
_TEXT	SEGMENT
tv73 = 32
stream$ = 64
nextNodeToken PROC					; COMDAT

; 768  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 769  : 	return stream->adaptor->create(stream->adaptor, stream->_next(stream));

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 50 68	 call	 QWORD PTR [rax+104]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0001c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00020	48 89 4c 24 20	 mov	 QWORD PTR tv73[rsp], rcx
  00025	48 8b d0	 mov	 rdx, rax
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0002d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR tv73[rsp]
  00036	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 770  : }

  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
nextNodeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT nextNodeNode
_TEXT	SEGMENT
stream$ = 48
nextNodeNode PROC					; COMDAT

; 774  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 775  : 	return stream->_next(stream);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 50 68	 call	 QWORD PTR [rax+104]

; 776  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
nextNodeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT nextNode
_TEXT	SEGMENT
n$ = 32
el$ = 40
stream$ = 64
nextNode PROC						; COMDAT

; 789  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 790  : 
; 791  : 	ANTLR3_UINT32	n;
; 792  : 	pANTLR3_BASE_TREE	el = stream->_next(stream);

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 50 68	 call	 QWORD PTR [rax+104]
  00017	48 89 44 24 28	 mov	 QWORD PTR el$[rsp], rax

; 793  : 
; 794  : 	n = stream->size(stream);

  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00026	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0002c	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 795  : 	if (stream->dirty == ANTLR3_TRUE || (stream->cursor > n && n == 1))

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00035	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  00039	83 f8 01	 cmp	 eax, 1
  0003c	74 14		 je	 SHORT $LN3@nextNode
  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00043	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00047	39 08		 cmp	 DWORD PTR [rax], ecx
  00049	76 26		 jbe	 SHORT $LN2@nextNode
  0004b	83 7c 24 20 01	 cmp	 DWORD PTR n$[rsp], 1
  00050	75 1f		 jne	 SHORT $LN2@nextNode
$LN3@nextNode:

; 796  : 	{
; 797  : 		// We are out of elements and the size is 1, which means we just 
; 798  : 		// dup the node that we have
; 799  : 		//
; 800  : 		return	stream->adaptor->dupNode(stream->adaptor, el);

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00057	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005b	48 8b 54 24 28	 mov	 rdx, QWORD PTR el$[rsp]
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00065	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00069	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  0006f	eb 05		 jmp	 SHORT $LN1@nextNode
$LN2@nextNode:

; 801  : 	}
; 802  : 
; 803  : 	// We were not out of nodes, so the one we received is the one to return
; 804  : 	//
; 805  : 	return  el;

  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR el$[rsp]
$LN1@nextNode:

; 806  : }

  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
nextNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT hasNext
_TEXT	SEGMENT
stream$ = 48
hasNext	PROC						; COMDAT

; 751  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 752  : 	if (	(stream->singleElement != NULL && stream->cursor < 1)
; 753  : 		||	(stream->elements != NULL && stream->cursor < stream->elements->size(stream->elements)))

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  0000f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00014	74 0a		 je	 SHORT $LN5@hasNext
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  0001b	83 38 01	 cmp	 DWORD PTR [rax], 1
  0001e	72 2d		 jb	 SHORT $LN4@hasNext
$LN5@hasNext:
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00025	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002a	74 27		 je	 SHORT $LN2@hasNext
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00031	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  0003a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003e	ff 90 58 01 00
	00		 call	 QWORD PTR [rax+344]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  00049	39 01		 cmp	 DWORD PTR [rcx], eax
  0004b	73 06		 jae	 SHORT $LN2@hasNext
$LN4@hasNext:

; 754  : 	{
; 755  : 		return ANTLR3_TRUE;

  0004d	b0 01		 mov	 al, 1
  0004f	eb 04		 jmp	 SHORT $LN1@hasNext

; 756  : 	}

  00051	eb 02		 jmp	 SHORT $LN3@hasNext
$LN2@hasNext:

; 757  : 	else
; 758  : 	{
; 759  : 		return ANTLR3_FALSE;

  00053	32 c0		 xor	 al, al
$LN3@hasNext:
$LN1@hasNext:

; 760  : 	}
; 761  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
hasNext	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT toTreeNode
_TEXT	SEGMENT
stream$ = 48
element$ = 56
toTreeNode PROC						; COMDAT

; 739  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 740  : 	return stream->adaptor->dupNode(stream->adaptor, (pANTLR3_BASE_TREE)element);

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00014	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR element$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  00022	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00026	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 741  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
toTreeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT toTree
_TEXT	SEGMENT
stream$ = 16
element$ = 24
toTree	PROC						; COMDAT

; 722  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 723  : 	return (pANTLR3_BASE_TREE)element;

  0000b	48 8b 44 24 18	 mov	 rax, QWORD PTR element$[rsp]

; 724  : }

  00010	5f		 pop	 rdi
  00011	c3		 ret	 0
toTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT dupTreeNode
_TEXT	SEGMENT
stream$ = 48
element$ = 56
dupTreeNode PROC					; COMDAT

; 711  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 712  : 	ANTLR3_FPRINTF(stderr, "dup() cannot be called on a node rewrite stream!!!");

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fprintf

; 713  : 	return NULL;

  00029	33 c0		 xor	 eax, eax

; 714  : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
dupTreeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT dupTree
_TEXT	SEGMENT
stream$ = 48
element$ = 56
dupTree	PROC						; COMDAT

; 697  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 698  : 	return stream->adaptor->dupNode(stream->adaptor, (pANTLR3_BASE_TREE)element);

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00014	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR element$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  00022	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00026	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 699  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
dupTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT dupTok
_TEXT	SEGMENT
stream$ = 48
el$ = 56
dupTok	PROC						; COMDAT

; 683  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 684  : 	ANTLR3_FPRINTF(stderr, "dup() cannot be called on a token rewrite stream!!");

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fprintf

; 685  : 	return NULL;

  00029	33 c0		 xor	 eax, eax

; 686  : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
dupTok	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT _next
_TEXT	SEGMENT
n$ = 32
t$ = 40
stream$ = 64
_next	PROC						; COMDAT

; 626  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 627  : 	ANTLR3_UINT32		n;
; 628  : 	pANTLR3_BASE_TREE	t;
; 629  : 
; 630  : 	n = stream->size(stream);

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0001a	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 631  : 
; 632  : 	if (n == 0)

  0001e	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00023	75 07		 jne	 SHORT $LN2@next

; 633  : 	{
; 634  : 		// This means that the stream is empty
; 635  : 		//
; 636  : 		return NULL;	// Caller must cope with this

  00025	33 c0		 xor	 eax, eax
  00027	e9 b0 00 00 00	 jmp	 $LN1@next
$LN2@next:

; 637  : 	}
; 638  : 
; 639  : 	// Traversed all the available elements already?
; 640  : 	//
; 641  : 	if (stream->cursor >= n)

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00031	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00035	39 08		 cmp	 DWORD PTR [rax], ecx
  00037	72 26		 jb	 SHORT $LN3@next

; 642  : 	{
; 643  : 		if (n == 1)

  00039	83 7c 24 20 01	 cmp	 DWORD PTR n$[rsp], 1
  0003e	75 1b		 jne	 SHORT $LN4@next

; 644  : 		{
; 645  : 			// Special case when size is single element, it will just dup a lot
; 646  : 			//
; 647  : 			return stream->toTree(stream, stream->singleElement);

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00045	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00053	ff 50 78	 call	 QWORD PTR [rax+120]
  00056	e9 81 00 00 00	 jmp	 $LN1@next
$LN4@next:

; 648  : 		}
; 649  : 
; 650  : 		// Out of elements and the size is not 1, so we cannot assume
; 651  : 		// that we just duplicate the entry n times (such as ID ent+ -> ^(ID ent)+)
; 652  : 		// This means we ran out of elements earlier than was expected.
; 653  : 		//
; 654  : 		return NULL;	// Caller must cope with this

  0005b	33 c0		 xor	 eax, eax
  0005d	eb 7d		 jmp	 SHORT $LN1@next
$LN3@next:

; 655  : 	}
; 656  : 
; 657  : 	// Elements available either for duping or just available
; 658  : 	//
; 659  : 	if (stream->singleElement != NULL)

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00064	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00069	74 28		 je	 SHORT $LN5@next

; 660  : 	{
; 661  : 		stream->cursor++;   // Cursor advances even for single element as this tells us to dup()

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00070	8b 00		 mov	 eax, DWORD PTR [rax]
  00072	ff c0		 inc	 eax
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00079	89 01		 mov	 DWORD PTR [rcx], eax

; 662  : 		return stream->toTree(stream, stream->singleElement);

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00080	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0008e	ff 50 78	 call	 QWORD PTR [rax+120]
  00091	eb 49		 jmp	 SHORT $LN1@next
$LN5@next:

; 663  : 	}
; 664  : 
; 665  : 	// More than just a single element so we extract it from the 
; 666  : 	// vector.
; 667  : 	//
; 668  : 	t = stream->toTree(stream, stream->elements->get(stream->elements, stream->cursor));

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00098	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000a1	8b 11		 mov	 edx, DWORD PTR [rcx]
  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000a8	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ac	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  000b2	48 8b d0	 mov	 rdx, rax
  000b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000bf	ff 50 78	 call	 QWORD PTR [rax+120]
  000c2	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 669  : 	stream->cursor++;

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000cc	8b 00		 mov	 eax, DWORD PTR [rax]
  000ce	ff c0		 inc	 eax
  000d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000d5	89 01		 mov	 DWORD PTR [rcx], eax

; 670  : 	return t;

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
$LN1@next:

; 671  : }

  000dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
_next	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT nextToken
_TEXT	SEGMENT
stream$ = 48
nextToken PROC						; COMDAT

; 593  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 594  : 	return stream->_next(stream);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 50 68	 call	 QWORD PTR [rax+104]

; 595  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
nextToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT nextTree
_TEXT	SEGMENT
n$ = 32
el$ = 40
stream$ = 64
nextTree PROC						; COMDAT

; 569  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 570  : 	ANTLR3_UINT32		n;
; 571  : 	void			*  el;
; 572  : 
; 573  : 	n = stream->size(stream);

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0001a	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 574  : 
; 575  : 	if ( stream->dirty || (stream->cursor >=n && n==1) ) 

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00023	0f b6 40 30	 movzx	 eax, BYTE PTR [rax+48]
  00027	85 c0		 test	 eax, eax
  00029	75 14		 jne	 SHORT $LN3@nextTree
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00030	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00034	39 08		 cmp	 DWORD PTR [rax], ecx
  00036	72 2d		 jb	 SHORT $LN2@nextTree
  00038	83 7c 24 20 01	 cmp	 DWORD PTR n$[rsp], 1
  0003d	75 26		 jne	 SHORT $LN2@nextTree
$LN3@nextTree:

; 576  : 	{
; 577  : 		// if out of elements and size is 1, dup
; 578  : 		//
; 579  : 		el = stream->_next(stream);

  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00049	ff 50 68	 call	 QWORD PTR [rax+104]
  0004c	48 89 44 24 28	 mov	 QWORD PTR el$[rsp], rax

; 580  : 		return stream->dup(stream, el);

  00051	48 8b 54 24 28	 mov	 rdx, QWORD PTR el$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00060	ff 50 70	 call	 QWORD PTR [rax+112]
  00063	eb 17		 jmp	 SHORT $LN1@nextTree
$LN2@nextTree:

; 581  : 	}
; 582  : 
; 583  : 	// test size above then fetch
; 584  : 	//
; 585  : 	el = stream->_next(stream);

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0006f	ff 50 68	 call	 QWORD PTR [rax+104]
  00072	48 89 44 24 28	 mov	 QWORD PTR el$[rsp], rax

; 586  : 	return el;

  00077	48 8b 44 24 28	 mov	 rax, QWORD PTR el$[rsp]
$LN1@nextTree:

; 587  : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
nextTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT next
_TEXT	SEGMENT
s$ = 32
el$1 = 40
stream$ = 64
next	PROC						; COMDAT

; 602  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 603  : 	ANTLR3_UINT32   s;
; 604  : 
; 605  : 	s = stream->size(stream);

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00014	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0001a	89 44 24 20	 mov	 DWORD PTR s$[rsp], eax

; 606  : 	if (stream->cursor >= s && s == 1)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00023	8b 4c 24 20	 mov	 ecx, DWORD PTR s$[rsp]
  00027	39 08		 cmp	 DWORD PTR [rax], ecx
  00029	72 2d		 jb	 SHORT $LN2@next
  0002b	83 7c 24 20 01	 cmp	 DWORD PTR s$[rsp], 1
  00030	75 26		 jne	 SHORT $LN2@next

; 607  : 	{
; 608  : 		pANTLR3_BASE_TREE el;
; 609  : 
; 610  : 		el = stream->_next(stream);

  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0003c	ff 50 68	 call	 QWORD PTR [rax+104]
  0003f	48 89 44 24 28	 mov	 QWORD PTR el$1[rsp], rax

; 611  : 
; 612  : 		return	stream->dup(stream, el);

  00044	48 8b 54 24 28	 mov	 rdx, QWORD PTR el$1[rsp]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00053	ff 50 70	 call	 QWORD PTR [rax+112]
  00056	eb 0d		 jmp	 SHORT $LN1@next
$LN2@next:

; 613  : 	}
; 614  : 
; 615  : 	return stream->_next(stream);

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00062	ff 50 68	 call	 QWORD PTR [rax+104]
$LN1@next:

; 616  : }

  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
next	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT add
_TEXT	SEGMENT
factory$1 = 32
stream$ = 64
el$ = 72
freePtr$ = 80
add	PROC						; COMDAT

; 520  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 521  : 	if (el== NULL)

  00014	48 83 7c 24 48
	00		 cmp	 QWORD PTR el$[rsp], 0
  0001a	75 05		 jne	 SHORT $LN2@add

; 522  : 	{
; 523  : 		return;

  0001c	e9 03 01 00 00	 jmp	 $LN1@add
$LN2@add:

; 524  : 	}
; 525  : 	// As we may be reusing a stream, we may already have allocated
; 526  : 	// a rewrite stream vector. If we have then is will be empty if
; 527  : 	// we have either zero or just one element in the rewrite stream
; 528  : 	//
; 529  : 	if (stream->elements != NULL && stream->elements->count > 0)

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00026	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002b	74 36		 je	 SHORT $LN3@add
  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00032	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00036	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0003a	76 27		 jbe	 SHORT $LN3@add

; 530  : 	{
; 531  : 		// We already have >1 entries in the stream. So we can just add this new element to the existing
; 532  : 		// collection. 
; 533  : 		//
; 534  : 		stream->elements->add(stream->elements, el, freePtr);

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	4c 8b 44 24 50	 mov	 r8, QWORD PTR freePtr$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR el$[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  00054	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00058	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 535  : 		return;

  0005e	e9 c1 00 00 00	 jmp	 $LN1@add
$LN3@add:

; 536  : 	}
; 537  : 	if (stream->singleElement == NULL)

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00068	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006d	75 13		 jne	 SHORT $LN4@add

; 538  : 	{
; 539  : 		stream->singleElement = el;

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00074	48 8b 4c 24 48	 mov	 rcx, QWORD PTR el$[rsp]
  00079	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 540  : 		return;

  0007d	e9 a2 00 00 00	 jmp	 $LN1@add
$LN4@add:

; 541  : 	}
; 542  : 
; 543  : 	// If we got here then we had only the one element so far
; 544  : 	// and we must now create a vector to hold a collection of them
; 545  : 	//
; 546  : 	if	(stream->elements == NULL)

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00087	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0008c	75 41		 jne	 SHORT $LN5@add

; 547  : 	{
; 548  :         pANTLR3_VECTOR_FACTORY factory = ((pANTLR3_COMMON_TREE_ADAPTOR)(stream->adaptor->super))->arboretum->vFactory;

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  00093	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00097	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009a	48 8b 80 60 01
	00 00		 mov	 rax, QWORD PTR [rax+352]
  000a1	48 8b 80 48 01
	00 00		 mov	 rax, QWORD PTR [rax+328]
  000a8	48 89 44 24 20	 mov	 QWORD PTR factory$1[rsp], rax

; 549  : 
; 550  :         
; 551  : 		stream->elements		= factory->newVector(factory);

  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$1[rsp]
  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$1[rsp]
  000b7	ff 90 80 01 00
	00		 call	 QWORD PTR [rax+384]
  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000c2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 552  : 		stream->freeElements	= ANTLR3_TRUE;			// We 'ummed it, so we play it son.

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000cb	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
$LN5@add:

; 553  : 	}
; 554  :     
; 555  : 	stream->elements->add	(stream->elements, stream->singleElement, freePtr);

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000d4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d8	4c 8b 44 24 50	 mov	 r8, QWORD PTR freePtr$[rsp]
  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000e2	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  000eb	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000ef	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 556  : 	stream->elements->add	(stream->elements, el, freePtr);

  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  000fa	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fe	4c 8b 44 24 50	 mov	 r8, QWORD PTR freePtr$[rsp]
  00103	48 8b 54 24 48	 mov	 rdx, QWORD PTR el$[rsp]
  00108	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stream$[rsp]
  0010d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00111	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 557  : 	stream->singleElement	= NULL;

  00117	48 8b 44 24 40	 mov	 rax, QWORD PTR stream$[rsp]
  0011c	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN1@add:

; 558  : 
; 559  : 	return;
; 560  : }

  00124	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00128	5f		 pop	 rdi
  00129	c3		 ret	 0
add	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT reset
_TEXT	SEGMENT
stream$ = 16
reset	PROC						; COMDAT

; 511  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 512  : 	stream->dirty	= ANTLR3_TRUE;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR stream$[rsp]
  0000b	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 513  : 	stream->cursor	= 0;

  0000f	48 8b 44 24 10	 mov	 rax, QWORD PTR stream$[rsp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 514  : }

  0001a	5f		 pop	 rdi
  0001b	c3		 ret	 0
reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleSubtreeStreamNewAEV
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
vector$ = 88
antlr3RewriteRuleSubtreeStreamNewAEV PROC		; COMDAT

; 419  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 420  : 	pANTLR3_REWRITE_RULE_SUBTREE_STREAM	stream;
; 421  : 
; 422  : 	// First job is to create the memory we need.
; 423  : 	//
; 424  : 	stream	= antlr3RewriteRuleElementStreamNewAEV(adaptor, rec, description, vector);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR vector$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAEV
  00032	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 425  : 
; 426  : 	if (stream == NULL)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  0003d	75 04		 jne	 SHORT $LN2@antlr3Rewr

; 427  : 	{
; 428  : 		return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 3b		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 429  : 	}
; 430  : 
; 431  : 	// Install the subtree based overrides
; 432  : 	//
; 433  : 	stream->dup			= dupTree;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  0004f	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 434  : 	stream->nextNode	= nextNode;

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNode
  0005f	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 435  :     stream->free        = freeNodeRS;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeNodeRS
  00072	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 436  : 
; 437  : 	return stream;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 438  : }

  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
antlr3RewriteRuleSubtreeStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleSubtreeStreamNewAEE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
oneElement$ = 88
antlr3RewriteRuleSubtreeStreamNewAEE PROC		; COMDAT

; 396  : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 397  : 	pANTLR3_REWRITE_RULE_SUBTREE_STREAM	stream;
; 398  : 
; 399  : 	// First job is to create the memory we need.
; 400  : 	//
; 401  : 	stream	= antlr3RewriteRuleElementStreamNewAEE(adaptor, rec, description, oneElement);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR oneElement$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAEE
  00032	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 402  : 
; 403  : 	if (stream == NULL)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  0003d	75 07		 jne	 SHORT $LN2@antlr3Rewr

; 404  : 	{
; 405  : 		return stream;

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00044	eb 3b		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 406  : 	}
; 407  : 
; 408  : 	// Install the subtree based overrides
; 409  : 	//
; 410  : 	stream->dup			= dupTree;

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  00052	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 411  : 	stream->nextNode	= nextNode;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNode
  00062	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 412  :     stream->free        = freeNodeRS;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeNodeRS
  00075	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 413  : 
; 414  : 	return stream;

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 415  : }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
antlr3RewriteRuleSubtreeStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleSubtreeStreamNewAE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
antlr3RewriteRuleSubtreeStreamNewAE PROC		; COMDAT

; 374  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 375  : 	pANTLR3_REWRITE_RULE_SUBTREE_STREAM	stream;
; 376  : 
; 377  : 	// First job is to create the memory we need.
; 378  : 	//
; 379  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  00014	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00023	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAE
  00028	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 380  : 
; 381  : 	if (stream == NULL)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00033	75 07		 jne	 SHORT $LN2@antlr3Rewr

; 382  : 	{
; 383  : 		return stream;

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003a	eb 3b		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 384  : 	}
; 385  : 
; 386  : 	// Install the subtree based overrides
; 387  : 	//
; 388  : 	stream->dup			= dupTree;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  00048	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 389  : 	stream->nextNode	= nextNode;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNode
  00058	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 390  :     stream->free        = freeNodeRS;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeNodeRS
  0006b	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 391  : 	return stream;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 392  : 
; 393  : }

  00077	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
antlr3RewriteRuleSubtreeStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleNODEStreamNewAEV
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
vector$ = 88
antlr3RewriteRuleNODEStreamNewAEV PROC			; COMDAT

; 486  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 487  : 	pANTLR3_REWRITE_RULE_NODE_STREAM	stream;
; 488  : 
; 489  : 	// First job is to create the memory we need.
; 490  : 	//
; 491  : 	stream	= antlr3RewriteRuleElementStreamNewAEV(adaptor, rec, description, vector);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR vector$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAEV
  00032	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 492  : 
; 493  : 	// Install the Node based overrides
; 494  : 	//
; 495  : 	stream->dup			= dupTreeNode;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTreeNode
  00043	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 496  : 	stream->toTree		= toTreeNode;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toTreeNode
  00053	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 497  : 	stream->nextNode	= nextNodeNode;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNodeNode
  00063	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 498  :     stream->free        = freeNodeRS;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeNodeRS
  00076	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 499  :     
; 500  : 	return stream;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]

; 501  : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
antlr3RewriteRuleNODEStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleNODEStreamNewAEE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
oneElement$ = 88
antlr3RewriteRuleNODEStreamNewAEE PROC			; COMDAT

; 467  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 468  : 	pANTLR3_REWRITE_RULE_NODE_STREAM	stream;
; 469  : 
; 470  : 	// First job is to create the memory we need.
; 471  : 	//
; 472  : 	stream	= antlr3RewriteRuleElementStreamNewAEE(adaptor, rec, description, oneElement);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR oneElement$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAEE
  00032	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 473  : 
; 474  : 	// Install the node based overrides
; 475  : 	//
; 476  : 	stream->dup			= dupTreeNode;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTreeNode
  00043	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 477  : 	stream->toTree		= toTreeNode;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toTreeNode
  00053	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 478  : 	stream->nextNode	= nextNodeNode;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNodeNode
  00063	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 479  :     stream->free        = freeNodeRS;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeNodeRS
  00076	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 480  : 
; 481  : 	return stream;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]

; 482  : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
antlr3RewriteRuleNODEStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleNODEStreamNewAE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
antlr3RewriteRuleNODEStreamNewAE PROC			; COMDAT

; 443  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 444  : 	pANTLR3_REWRITE_RULE_NODE_STREAM	stream;
; 445  : 
; 446  : 	// First job is to create the memory we need.
; 447  : 	//
; 448  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  00014	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00023	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAE
  00028	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 449  : 
; 450  : 	if (stream == NULL)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00033	75 07		 jne	 SHORT $LN2@antlr3Rewr

; 451  : 	{
; 452  : 		return stream;

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003a	eb 4b		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 453  : 	}
; 454  : 
; 455  : 	// Install the node based overrides
; 456  : 	//
; 457  : 	stream->dup			= dupTreeNode;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTreeNode
  00048	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 458  : 	stream->toTree		= toTreeNode;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toTreeNode
  00058	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 459  : 	stream->nextNode	= nextNodeNode;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNodeNode
  00068	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 460  :     stream->free        = freeNodeRS;

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeNodeRS
  0007b	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 461  : 
; 462  : 	return stream;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 463  : }

  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
antlr3RewriteRuleNODEStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleTOKENStreamNewAEV
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
vector$ = 88
antlr3RewriteRuleTOKENStreamNewAEV PROC			; COMDAT

; 353  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 354  : 	pANTLR3_REWRITE_RULE_TOKEN_STREAM	stream;
; 355  : 
; 356  : 	// First job is to create the memory we need.
; 357  : 	//
; 358  : 	stream	= antlr3RewriteRuleElementStreamNewAEV(adaptor, rec, description, vector);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR vector$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAEV
  00032	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 359  : 
; 360  : 	// Install the token based overrides
; 361  : 	//
; 362  : 	stream->dup			= dupTok;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTok
  00043	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 363  : 	stream->nextNode	= nextNodeToken;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNodeToken
  00053	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 364  : 
; 365  : 	// No nextNode implementation for a token rewrite stream
; 366  : 	//
; 367  : 	return stream;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]

; 368  : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
antlr3RewriteRuleTOKENStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleTOKENStreamNewAEE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
oneElement$ = 88
antlr3RewriteRuleTOKENStreamNewAEE PROC			; COMDAT

; 334  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 335  : 	pANTLR3_REWRITE_RULE_TOKEN_STREAM	stream;
; 336  : 
; 337  : 	// First job is to create the memory we need.
; 338  : 	//
; 339  : 	stream	= antlr3RewriteRuleElementStreamNewAEE(adaptor, rec, description, oneElement);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR oneElement$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAEE
  00032	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 340  : 
; 341  : 	// Install the token based overrides
; 342  : 	//
; 343  : 	stream->dup			= dupTok;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTok
  00043	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 344  : 	stream->nextNode	= nextNodeToken;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNodeToken
  00053	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 345  : 
; 346  : 	// No nextNode implementation for a token rewrite stream
; 347  : 	//
; 348  : 	return stream;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]

; 349  : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
antlr3RewriteRuleTOKENStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3rewritestreams.c
;	COMDAT antlr3RewriteRuleTOKENStreamNewAE
_TEXT	SEGMENT
stream$ = 32
adaptor$ = 64
rec$ = 72
description$ = 80
antlr3RewriteRuleTOKENStreamNewAE PROC			; COMDAT

; 310  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 311  : 	pANTLR3_REWRITE_RULE_TOKEN_STREAM	stream;
; 312  : 
; 313  : 	// First job is to create the memory we need.
; 314  : 	//
; 315  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  00014	4c 8b 44 24 50	 mov	 r8, QWORD PTR description$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR rec$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00023	e8 00 00 00 00	 call	 antlr3RewriteRuleElementStreamNewAE
  00028	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 316  : 
; 317  : 	if (stream == NULL)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00033	75 07		 jne	 SHORT $LN2@antlr3Rewr

; 318  : 	{
; 319  : 		return stream;

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  0003a	eb 28		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 320  : 	}
; 321  : 
; 322  : 	// Install the token based overrides
; 323  : 	//
; 324  : 	stream->dup			= dupTok;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTok
  00048	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 325  : 	stream->nextNode	= nextNodeToken;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextNodeToken
  00058	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 326  : 
; 327  : 	// No nextNode implementation for a token rewrite stream
; 328  : 	//
; 329  : 	return stream;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR stream$[rsp]
$LN1@antlr3Rewr:

; 330  : }

  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
antlr3RewriteRuleTOKENStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  0004b	e8 00 00 00 00	 call	 _vfprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 842  :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 843  :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 844  :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
