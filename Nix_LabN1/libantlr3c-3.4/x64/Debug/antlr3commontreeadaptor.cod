; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34435.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ANTLR3_TREE_ADAPTORNew
PUBLIC	ANTLR3_TREE_ADAPTORDebugNew
PUBLIC	??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@		; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3TokenFactoryNew:PROC
EXTRN	antlr3ArboretumNew:PROC
EXTRN	antlr3BaseTreeAdaptorInit:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ANTLR3_TREE_ADAPTORNew DD imagerel $LN4
	DD	imagerel $LN4+549
	DD	imagerel $unwind$ANTLR3_TREE_ADAPTORNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ANTLR3_TREE_ADAPTORDebugNew DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$ANTLR3_TREE_ADAPTORDebugNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupNode DD imagerel dupNode
	DD	imagerel dupNode+63
	DD	imagerel $unwind$dupNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$create DD imagerel create
	DD	imagerel create+82
	DD	imagerel $unwind$create
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreate DD imagerel dbgCreate
	DD	imagerel dbgCreate+75
	DD	imagerel $unwind$dbgCreate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createToken DD imagerel createToken
	DD	imagerel createToken+156
	DD	imagerel $unwind$createToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTokenFromToken DD imagerel createTokenFromToken
	DD	imagerel createTokenFromToken+384
	DD	imagerel $unwind$createTokenFromToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+37
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+37
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChild DD imagerel getChild
	DD	imagerel getChild+43
	DD	imagerel $unwind$getChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildCount DD imagerel getChildCount
	DD	imagerel getChildCount+37
	DD	imagerel $unwind$getChildCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replaceChildren DD imagerel replaceChildren
	DD	imagerel replaceChildren+67
	DD	imagerel $unwind$replaceChildren
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setDebugEventListener DD imagerel setDebugEventListener
	DD	imagerel setDebugEventListener+74
	DD	imagerel $unwind$setDebugEventListener
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChildIndex DD imagerel setChildIndex
	DD	imagerel setChildIndex+44
	DD	imagerel $unwind$setChildIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildIndex DD imagerel getChildIndex
	DD	imagerel getChildIndex+37
	DD	imagerel $unwind$getChildIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setParent DD imagerel setParent
	DD	imagerel setParent+48
	DD	imagerel $unwind$setParent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getParent DD imagerel getParent
	DD	imagerel getParent+37
	DD	imagerel $unwind$getParent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChild DD imagerel setChild
	DD	imagerel setChild+57
	DD	imagerel $unwind$setChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deleteChild DD imagerel deleteChild
	DD	imagerel deleteChild+44
	DD	imagerel $unwind$deleteChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$errorNode DD imagerel errorNode
	DD	imagerel errorNode+56
	DD	imagerel $unwind$errorNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenBoundaries DD imagerel setTokenBoundaries
	DD	imagerel setTokenBoundaries+162
	DD	imagerel $unwind$setTokenBoundaries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgSetTokenBoundaries DD imagerel dbgSetTokenBoundaries
	DD	imagerel dbgSetTokenBoundaries+168
	DD	imagerel $unwind$dbgSetTokenBoundaries
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenStartIndex DD imagerel getTokenStartIndex
	DD	imagerel getTokenStartIndex+25
	DD	imagerel $unwind$getTokenStartIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenStopIndex DD imagerel getTokenStopIndex
	DD	imagerel getTokenStopIndex+25
	DD	imagerel $unwind$getTokenStopIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ctaFree DD imagerel ctaFree
	DD	imagerel ctaFree+111
	DD	imagerel $unwind$ctaFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@
CONST	SEGMENT
??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@ DB 'Tree Error Node', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ctaFree DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenStopIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenStartIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgSetTokenBoundaries DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenBoundaries DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$errorNode DD 021901H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deleteChild DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChild DD 021901H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getParent DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setParent DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildIndex DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChildIndex DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setDebugEventListener DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replaceChildren DD 021901H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildCount DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChild DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTokenFromToken DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createToken DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreate DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupNode DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ANTLR3_TREE_ADAPTORDebugNew DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ANTLR3_TREE_ADAPTORNew DD 020a01H
	DD	07006520aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT ctaFree
_TEXT	SEGMENT
cta$ = 32
tv77 = 40
adaptor$ = 64
ctaFree	PROC						; COMDAT

; 217  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 218  :     pANTLR3_COMMON_TREE_ADAPTOR cta;
; 219  : 
; 220  :     cta	= (pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 89 44 24 20	 mov	 QWORD PTR cta$[rsp], rax

; 221  : 
; 222  :     /* Free the tree factory we created
; 223  :      */
; 224  :     cta->arboretum->close(((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum);

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0001c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  00024	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  0002b	48 89 4c 24 28	 mov	 QWORD PTR tv77[rsp], rcx
  00030	48 8b 88 60 01
	00 00		 mov	 rcx, QWORD PTR [rax+352]
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR tv77[rsp]
  0003c	ff 90 70 01 00
	00		 call	 QWORD PTR [rax+368]

; 225  : 
; 226  :     /* Free the token factory we created
; 227  :      */
; 228  :     adaptor->tokenFactory->close(adaptor->tokenFactory);

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00047	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00050	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00054	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]

; 229  : 
; 230  :     /* Free the super pointer, as it is this that was allocated
; 231  :      * and is the common tree structure.
; 232  :      */
; 233  :     ANTLR3_FREE(adaptor->super);

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00068	90		 npad	 1

; 234  : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
ctaFree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getTokenStopIndex
_TEXT	SEGMENT
adaptor$ = 16
t$ = 24
getTokenStopIndex PROC					; COMDAT

; 427  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 428  :     return  ((pANTLR3_COMMON_TREE)(t->super))->stopIndex;

  0000b	48 8b 44 24 18	 mov	 rax, QWORD PTR t$[rsp]
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 429  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
getTokenStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getTokenStartIndex
_TEXT	SEGMENT
adaptor$ = 16
t$ = 24
getTokenStartIndex PROC					; COMDAT

; 421  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 422  :     return  ((pANTLR3_COMMON_TREE)(t->super))->startIndex;

  0000b	48 8b 44 24 18	 mov	 rax, QWORD PTR t$[rsp]
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 423  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
getTokenStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT dbgSetTokenBoundaries
_TEXT	SEGMENT
tv74 = 32
tv84 = 40
adaptor$ = 64
t$ = 72
startToken$ = 80
stopToken$ = 88
dbgSetTokenBoundaries PROC				; COMDAT

; 410  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 411  : 	setTokenBoundaries(adaptor, t, startToken, stopToken);

  00019	4c 8b 4c 24 58	 mov	 r9, QWORD PTR stopToken$[rsp]
  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR startToken$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002d	e8 00 00 00 00	 call	 setTokenBoundaries

; 412  : 
; 413  : 	if	(t != NULL && startToken != NULL && stopToken != NULL)

  00032	48 83 7c 24 48
	00		 cmp	 QWORD PTR t$[rsp], 0
  00038	74 68		 je	 SHORT $LN2@dbgSetToke
  0003a	48 83 7c 24 50
	00		 cmp	 QWORD PTR startToken$[rsp], 0
  00040	74 60		 je	 SHORT $LN2@dbgSetToke
  00042	48 83 7c 24 58
	00		 cmp	 QWORD PTR stopToken$[rsp], 0
  00048	74 58		 je	 SHORT $LN2@dbgSetToke

; 414  : 	{
; 415  : 		adaptor->debugger->setTokenBoundaries(adaptor->debugger, t, startToken->getTokenIndex(startToken), stopToken->getTokenIndex(stopToken));

  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR stopToken$[rsp]
  0004f	48 8b 44 24 58	 mov	 rax, QWORD PTR stopToken$[rsp]
  00054	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0005a	48 89 44 24 20	 mov	 QWORD PTR tv74[rsp], rax
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR startToken$[rsp]
  00064	48 8b 54 24 50	 mov	 rdx, QWORD PTR startToken$[rsp]
  00069	ff 92 d0 00 00
	00		 call	 QWORD PTR [rdx+208]
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00074	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00078	48 89 4c 24 28	 mov	 QWORD PTR tv84[rsp], rcx
  0007d	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv74[rsp]
  00082	4c 8b ca	 mov	 r9, rdx
  00085	4c 8b c0	 mov	 r8, rax
  00088	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00092	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR tv84[rsp]
  0009b	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  000a1	90		 npad	 1
$LN2@dbgSetToke:

; 416  : 	}
; 417  : }

  000a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
dbgSetTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setTokenBoundaries
_TEXT	SEGMENT
start$ = 32
stop$ = 40
ct$ = 48
adaptor$ = 80
t$ = 88
startToken$ = 96
stopToken$ = 104
setTokenBoundaries PROC					; COMDAT

; 373  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 374  : 	ANTLR3_MARKER   start;
; 375  : 	ANTLR3_MARKER   stop;
; 376  : 
; 377  : 	pANTLR3_COMMON_TREE	    ct;
; 378  : 
; 379  : 	if	(t == NULL)

  00019	48 83 7c 24 58
	00		 cmp	 QWORD PTR t$[rsp], 0
  0001f	75 02		 jne	 SHORT $LN2@setTokenBo

; 380  : 	{
; 381  : 		return;

  00021	eb 79		 jmp	 SHORT $LN1@setTokenBo
$LN2@setTokenBo:

; 382  : 	}
; 383  : 
; 384  : 	if	( startToken != NULL)

  00023	48 83 7c 24 60
	00		 cmp	 QWORD PTR startToken$[rsp], 0
  00029	74 17		 je	 SHORT $LN3@setTokenBo

; 385  : 	{
; 386  : 		start = startToken->getTokenIndex(startToken);

  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR startToken$[rsp]
  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR startToken$[rsp]
  00035	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0003b	48 89 44 24 20	 mov	 QWORD PTR start$[rsp], rax

; 387  : 	}

  00040	eb 09		 jmp	 SHORT $LN4@setTokenBo
$LN3@setTokenBo:

; 388  : 	else
; 389  : 	{
; 390  : 		start = 0;

  00042	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
$LN4@setTokenBo:

; 391  : 	}
; 392  : 
; 393  : 	if	( stopToken != NULL)

  0004b	48 83 7c 24 68
	00		 cmp	 QWORD PTR stopToken$[rsp], 0
  00051	74 17		 je	 SHORT $LN5@setTokenBo

; 394  : 	{
; 395  : 		stop = stopToken->getTokenIndex(stopToken);

  00053	48 8b 4c 24 68	 mov	 rcx, QWORD PTR stopToken$[rsp]
  00058	48 8b 44 24 68	 mov	 rax, QWORD PTR stopToken$[rsp]
  0005d	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  00063	48 89 44 24 28	 mov	 QWORD PTR stop$[rsp], rax

; 396  : 	}

  00068	eb 09		 jmp	 SHORT $LN6@setTokenBo
$LN5@setTokenBo:

; 397  : 	else
; 398  : 	{
; 399  : 		stop = 0;

  0006a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR stop$[rsp], 0
$LN6@setTokenBo:

; 400  : 	}
; 401  : 
; 402  : 	ct	= (pANTLR3_COMMON_TREE)(t->super);

  00073	48 8b 44 24 58	 mov	 rax, QWORD PTR t$[rsp]
  00078	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007b	48 89 44 24 30	 mov	 QWORD PTR ct$[rsp], rax

; 403  : 
; 404  : 	ct->startIndex  = start;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR ct$[rsp]
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR start$[rsp]
  0008a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 405  : 	ct->stopIndex   = stop;

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR ct$[rsp]
  00093	48 8b 4c 24 28	 mov	 rcx, QWORD PTR stop$[rsp]
  00098	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN1@setTokenBo:

; 406  : 
; 407  : }

  0009c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
setTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT errorNode
_TEXT	SEGMENT
adaptor$ = 48
ctnstream$ = 56
startToken$ = 64
stopToken$ = 72
e$ = 80
errorNode PROC						; COMDAT

; 240  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 241  : 	// Use the supplied common tree node stream to get another tree from the factory
; 242  : 	// TODO: Look at creating the erronode as in Java, but this is complicated by the
; 243  : 	// need to track and free the memory allocated to it, so for now, we just
; 244  : 	// want something in the tree that isn't a NULL pointer.
; 245  : 	//
; 246  : 	return adaptor->createTypeText(adaptor, ANTLR3_TOKEN_INVALID, (pANTLR3_UINT8)"Tree Error Node");

  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@
  00020	33 d2		 xor	 edx, edx
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0002c	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 247  : 
; 248  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
errorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT deleteChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
deleteChild PROC					; COMDAT

; 466  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 467  : 	t->deleteChild(t, i);

  00014	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00022	ff 50 48	 call	 QWORD PTR [rax+72]
  00025	90		 npad	 1

; 468  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
deleteChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
child$ = 72
setChild PROC						; COMDAT

; 460  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 461  : 	t->setChild(t, i, child);

  00019	4c 8b 44 24 48	 mov	 r8, QWORD PTR child$[rsp]
  0001e	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00022	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00027	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  0002c	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]
  00032	90		 npad	 1

; 462  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
setChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getParent
_TEXT	SEGMENT
adaptor$ = 48
child$ = 56
getParent PROC						; COMDAT

; 494  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 495  : 	return child->getParent(child);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR child$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR child$[rsp]
  00019	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]

; 496  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
getParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setParent
_TEXT	SEGMENT
adaptor$ = 48
child$ = 56
parent$ = 64
setParent PROC						; COMDAT

; 489  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 490  : 	child->setParent(child, parent);

  00014	48 8b 54 24 40	 mov	 rdx, QWORD PTR parent$[rsp]
  00019	48 8b 4c 24 38	 mov	 rcx, QWORD PTR child$[rsp]
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR child$[rsp]
  00023	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00029	90		 npad	 1

; 491  : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
setParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getChildIndex
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getChildIndex PROC					; COMDAT

; 484  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 485  : 	return t->getChildIndex(t);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00019	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 486  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
getChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setChildIndex
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
setChildIndex PROC					; COMDAT

; 478  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 479  : 	t->setChildIndex(t, i);

  00014	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00022	ff 50 78	 call	 QWORD PTR [rax+120]
  00025	90		 npad	 1

; 480  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
setChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT setDebugEventListener
_TEXT	SEGMENT
adaptor$ = 48
debugger$ = 56
setDebugEventListener PROC				; COMDAT

; 203  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 204  : 	// Reinitialize as a debug version
; 205  : 	//
; 206  : 	antlr3BaseTreeAdaptorInit(adaptor, debugger);

  0000f	48 8b 54 24 38	 mov	 rdx, QWORD PTR debugger$[rsp]
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00019	e8 00 00 00 00	 call	 antlr3BaseTreeAdaptorInit

; 207  : 
; 208  : 	adaptor->create				= (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreate
  0002a	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 209  :                                     dbgCreate;
; 210  : 	adaptor->setTokenBoundaries	= (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgSetTokenBoundaries
  0003d	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 211  :                                     dbgSetTokenBoundaries;
; 212  : 
; 213  : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
setDebugEventListener ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT replaceChildren
_TEXT	SEGMENT
adaptor$ = 48
parent$ = 56
startChildIndex$ = 64
stopChildIndex$ = 72
t$ = 80
replaceChildren PROC					; COMDAT

; 446  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 447  : 	if	(parent != NULL)

  00019	48 83 7c 24 38
	00		 cmp	 QWORD PTR parent$[rsp], 0
  0001f	74 1c		 je	 SHORT $LN2@replaceChi

; 448  : 	{
; 449  : 		parent->replaceChildren(parent, startChildIndex, stopChildIndex, t);

  00021	4c 8b 4c 24 50	 mov	 r9, QWORD PTR t$[rsp]
  00026	44 8b 44 24 48	 mov	 r8d, DWORD PTR stopChildIndex$[rsp]
  0002b	8b 54 24 40	 mov	 edx, DWORD PTR startChildIndex$[rsp]
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR parent$[rsp]
  00034	48 8b 44 24 38	 mov	 rax, QWORD PTR parent$[rsp]
  00039	ff 50 50	 call	 QWORD PTR [rax+80]
  0003c	90		 npad	 1
$LN2@replaceChi:

; 450  : 	}
; 451  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getChildCount
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getChildCount PROC					; COMDAT

; 472  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 473  : 	return t->getChildCount(t);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00019	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 474  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
i$ = 64
getChild PROC						; COMDAT

; 455  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 456  : 	return t->getChild(t, i);

  00014	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00022	ff 50 70	 call	 QWORD PTR [rax+112]

; 457  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getType
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getType	PROC						; COMDAT

; 439  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 440  :     return  t->getType(t);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00019	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 441  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT getText
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getText	PROC						; COMDAT

; 433  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 434  :     return  t->getText(t);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00019	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 435  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT createTokenFromToken
_TEXT	SEGMENT
newToken$ = 32
text$1 = 40
adaptor$ = 64
fromToken$ = 72
createTokenFromToken PROC				; COMDAT

; 328  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 329  :     pANTLR3_COMMON_TOKEN    newToken;
; 330  : 
; 331  :     newToken	= adaptor->tokenFactory->newToken(adaptor->tokenFactory);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00021	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00027	48 89 44 24 20	 mov	 QWORD PTR newToken$[rsp], rax

; 332  :     
; 333  :     if	(newToken != NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR newToken$[rsp], 0
  00032	0f 84 3d 01 00
	00		 je	 $LN2@createToke

; 334  :     {
; 335  : 		// Create the text using our own string factory to avoid complicating
; 336  : 		// commontoken.
; 337  : 		//
; 338  : 		pANTLR3_STRING	text;
; 339  : 
; 340  : 		newToken->toString  = fromToken->toString;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0003d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00042	48 8b 89 00 01
	00 00		 mov	 rcx, QWORD PTR [rcx+256]
  00049	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 341  : 
; 342  : 		if	(fromToken->textState == ANTLR3_TEXT_CHARP)

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00055	83 78 48 01	 cmp	 DWORD PTR [rax+72], 1
  00059	75 20		 jne	 SHORT $LN3@createToke

; 343  : 		{
; 344  : 			newToken->textState		= ANTLR3_TEXT_CHARP;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00060	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 345  : 			newToken->tokText.chars	= fromToken->tokText.chars;

  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00071	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00075	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 346  : 		}

  00079	eb 4e		 jmp	 SHORT $LN4@createToke
$LN3@createToke:

; 347  : 		else
; 348  : 		{
; 349  : 			text						= fromToken->getText(fromToken);

  0007b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00085	ff 50 78	 call	 QWORD PTR [rax+120]
  00088	48 89 44 24 28	 mov	 QWORD PTR text$1[rsp], rax

; 350  : 			newToken->textState			= ANTLR3_TEXT_STRING;

  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00092	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 351  : 			newToken->tokText.text	    = adaptor->strFactory->newPtr(adaptor->strFactory, text->chars, text->len);

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0009e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR text$1[rsp]
  000a7	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR text$1[rsp]
  000b0	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000b9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000bd	ff 50 20	 call	 QWORD PTR [rax+32]
  000c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  000c5	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN4@createToke:

; 352  : 		}
; 353  : 
; 354  : 		newToken->setLine				(newToken, fromToken->getLine(fromToken));

  000c9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  000d3	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  000d9	8b d0		 mov	 edx, eax
  000db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  000e5	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]

; 355  : 		newToken->setTokenIndex			(newToken, fromToken->getTokenIndex(fromToken));

  000eb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  000f0	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  000f5	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000fb	48 8b d0	 mov	 rdx, rax
  000fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00103	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00108	ff 90 d8 00 00
	00		 call	 QWORD PTR [rax+216]

; 356  : 		newToken->setCharPositionInLine	(newToken, fromToken->getCharPositionInLine(fromToken));

  0010e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00113	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  00118	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  0011e	8b d0		 mov	 edx, eax
  00120	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00125	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0012a	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]

; 357  : 		newToken->setChannel			(newToken, fromToken->getChannel(fromToken));

  00130	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00135	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  0013a	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00140	8b d0		 mov	 edx, eax
  00142	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0014c	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 358  : 		newToken->setType				(newToken, fromToken->getType(fromToken));

  00152	48 8b 4c 24 48	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00157	48 8b 44 24 48	 mov	 rax, QWORD PTR fromToken$[rsp]
  0015c	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  00162	8b d0		 mov	 edx, eax
  00164	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00169	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0016e	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00174	90		 npad	 1
$LN2@createToke:

; 359  :     }
; 360  : 
; 361  :     return  newToken;

  00175	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]

; 362  : }

  0017a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017e	5f		 pop	 rdi
  0017f	c3		 ret	 0
createTokenFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT createToken
_TEXT	SEGMENT
newToken$ = 32
adaptor$ = 64
tokenType$ = 72
text$ = 80
createToken PROC					; COMDAT

; 292  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 293  :     pANTLR3_COMMON_TOKEN    newToken;
; 294  : 
; 295  :     newToken	= adaptor->tokenFactory->newToken(adaptor->tokenFactory);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00018	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00021	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00025	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0002b	48 89 44 24 20	 mov	 QWORD PTR newToken$[rsp], rax

; 296  : 
; 297  :     if	(newToken != NULL)

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR newToken$[rsp], 0
  00036	74 59		 je	 SHORT $LN2@createToke

; 298  :     {	
; 299  : 		newToken->textState		= ANTLR3_TEXT_CHARP;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  0003d	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 300  : 		newToken->tokText.chars = (pANTLR3_UCHAR)text;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  0004e	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 301  : 		newToken->setType(newToken, tokenType);

  00052	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00060	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 302  : 		newToken->input				= adaptor->tokenFactory->input;

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newToken$[rsp]
  00074	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  0007b	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 303  :         newToken->strFactory        = adaptor->strFactory;

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00089	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0008d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN2@createToke:

; 304  :     }
; 305  :     return  newToken;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR newToken$[rsp]

; 306  : }

  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
createToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT dbgCreate
_TEXT	SEGMENT
ct$ = 32
adaptor$ = 64
payload$ = 72
dbgCreate PROC						; COMDAT

; 273  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 274  : 	pANTLR3_BASE_TREE	ct;
; 275  : 
; 276  : 	ct = create(adaptor, payload);

  0000f	48 8b 54 24 48	 mov	 rdx, QWORD PTR payload$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00019	e8 00 00 00 00	 call	 create
  0001e	48 89 44 24 20	 mov	 QWORD PTR ct$[rsp], rax

; 277  : 	adaptor->debugger->createNode(adaptor->debugger, ct);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00028	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002c	48 8b 54 24 20	 mov	 rdx, QWORD PTR ct$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00036	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003a	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 278  : 
; 279  : 	return ct;

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR ct$[rsp]

; 280  : }

  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
dbgCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT create
_TEXT	SEGMENT
ct$ = 32
tv72 = 40
adaptor$ = 64
payload$ = 72
create	PROC						; COMDAT

; 260  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 261  :     pANTLR3_BASE_TREE	ct;
; 262  :     
; 263  :     /* Create a new common tree as this is what this adaptor deals with
; 264  :      */
; 265  :     ct = ((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum->newFromToken(((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum, payload);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 8b 89 60 01
	00 00		 mov	 rcx, QWORD PTR [rcx+352]
  00026	48 89 4c 24 28	 mov	 QWORD PTR tv72[rsp], rcx
  0002b	48 8b 54 24 48	 mov	 rdx, QWORD PTR payload$[rsp]
  00030	48 8b 88 60 01
	00 00		 mov	 rcx, QWORD PTR [rax+352]
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  0003c	ff 90 68 01 00
	00		 call	 QWORD PTR [rax+360]
  00042	48 89 44 24 20	 mov	 QWORD PTR ct$[rsp], rax

; 266  : 
; 267  :     /* But all adaptors return the pointer to the base interface.
; 268  :      */
; 269  :     return  ct;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR ct$[rsp]

; 270  : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
create	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT dupNode
_TEXT	SEGMENT
tv68 = 32
adaptor$ = 64
treeNode$ = 72
dupNode	PROC						; COMDAT

; 254  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 255  : 	return  treeNode == NULL ? NULL : treeNode->dupNode(treeNode);

  0000f	48 83 7c 24 48
	00		 cmp	 QWORD PTR treeNode$[rsp], 0
  00015	75 0b		 jne	 SHORT $LN3@dupNode
  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv68[rsp], 0
  00020	eb 12		 jmp	 SHORT $LN4@dupNode
$LN3@dupNode:
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR treeNode$[rsp]
  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR treeNode$[rsp]
  0002c	ff 50 58	 call	 QWORD PTR [rax+88]
  0002f	48 89 44 24 20	 mov	 QWORD PTR tv68[rsp], rax
$LN4@dupNode:
  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR tv68[rsp]

; 256  : }

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
dupNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT ANTLR3_TREE_ADAPTORDebugNew
_TEXT	SEGMENT
ta$ = 32
strFactory$ = 64
debugger$ = 72
ANTLR3_TREE_ADAPTORDebugNew PROC			; COMDAT

; 178  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 179  : 	pANTLR3_BASE_TREE_ADAPTOR	ta;
; 180  : 
; 181  : 	// Create a normal one first
; 182  : 	//
; 183  : 	ta	= ANTLR3_TREE_ADAPTORNew(strFactory);

  0000f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00014	e8 00 00 00 00	 call	 ANTLR3_TREE_ADAPTORNew
  00019	48 89 44 24 20	 mov	 QWORD PTR ta$[rsp], rax

; 184  : 	
; 185  : 	if	(ta != NULL)

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR ta$[rsp], 0
  00024	74 35		 je	 SHORT $LN2@ANTLR3_TRE

; 186  : 	{
; 187  : 		// Reinitialize as a debug version
; 188  : 		//
; 189  : 		antlr3BaseTreeAdaptorInit(ta, debugger);

  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR debugger$[rsp]
  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ta$[rsp]
  00030	e8 00 00 00 00	 call	 antlr3BaseTreeAdaptorInit

; 190  : 		ta->create				= (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR ta$[rsp]
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreate
  00041	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 191  : 									dbgCreate;
; 192  : 		ta->setTokenBoundaries	= (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR ta$[rsp]
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgSetTokenBoundaries
  00054	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx
$LN2@ANTLR3_TRE:

; 193  : 									dbgSetTokenBoundaries;
; 194  : 	}
; 195  : 
; 196  : 	return	ta;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR ta$[rsp]

; 197  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
ANTLR3_TREE_ADAPTORDebugNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3commontreeadaptor.c
;	COMDAT ANTLR3_TREE_ADAPTORNew
_TEXT	SEGMENT
cta$ = 32
strFactory$ = 64
ANTLR3_TREE_ADAPTORNew PROC				; COMDAT

; 85   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 86   : 	pANTLR3_COMMON_TREE_ADAPTOR	cta;
; 87   : 
; 88   : 	// First job is to create the memory we need for the tree adaptor interface.
; 89   : 	//
; 90   : 	cta	= (pANTLR3_COMMON_TREE_ADAPTOR) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_COMMON_TREE_ADAPTOR)));

  0000a	b9 68 01 00 00	 mov	 ecx, 360		; 00000168H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 20	 mov	 QWORD PTR cta$[rsp], rax

; 91   : 
; 92   : 	if	(cta == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR cta$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@ANTLR3_TRE

; 93   : 	{
; 94   : 		return	NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 f6 01 00 00	 jmp	 $LN1@ANTLR3_TRE
$LN2@ANTLR3_TRE:

; 95   : 	}
; 96   : 
; 97   : 	// Memory is initialized, so initialize the base tree adaptor
; 98   : 	//
; 99   : 	antlr3BaseTreeAdaptorInit(&(cta->baseAdaptor), NULL);

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0002e	48 83 c0 08	 add	 rax, 8
  00032	33 d2		 xor	 edx, edx
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 antlr3BaseTreeAdaptorInit

; 100  : 
; 101  : 	// Install our interface overrides. Strangeness is to allow generated code to treat them
; 102  :     // as returning void *
; 103  : 	//
; 104  : 	cta->baseAdaptor.dupNode				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupNode
  00048	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 105  : 													dupNode;
; 106  : 	cta->baseAdaptor.create					=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:create
  0005b	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 107  : 													create;
; 108  : 	cta->baseAdaptor.createToken			=  

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createToken
  0006e	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 109  : 													createToken;
; 110  : 	cta->baseAdaptor.createTokenFromToken   =  

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTokenFromToken
  00081	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 111  : 													createTokenFromToken;
; 112  : 	cta->baseAdaptor.setTokenBoundaries	    =  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenBoundaries
  00094	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 113  : 													setTokenBoundaries;
; 114  : 	cta->baseAdaptor.getTokenStartIndex	    =  (ANTLR3_MARKER  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenStartIndex
  000a7	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 115  :                                                     getTokenStartIndex;
; 116  : 	cta->baseAdaptor.getTokenStopIndex	    =  (ANTLR3_MARKER  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenStopIndex
  000ba	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 117  :                                                     getTokenStopIndex;
; 118  : 	cta->baseAdaptor.getText				=  (pANTLR3_STRING (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  000cd	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 119  :                                                     getText;
; 120  : 	cta->baseAdaptor.getType				=  (ANTLR3_UINT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  000e0	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 121  :                                                     getType;
; 122  : 	cta->baseAdaptor.getChild				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChild
  000f3	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 123  :                                                     getChild;
; 124  : 	cta->baseAdaptor.setChild				=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32, void *))

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChild
  00106	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 125  :                                                     setChild;
; 126  : 	cta->baseAdaptor.setParent				=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setParent
  00119	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 127  :                                                     setParent;
; 128  :     cta->baseAdaptor.getParent				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  0011d	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getParent
  00129	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 129  :                                                     getParent;
; 130  : 	cta->baseAdaptor.setChildIndex			=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  0012d	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChildIndex
  00139	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 131  :                                                     setChildIndex;
; 132  : 	cta->baseAdaptor.deleteChild			=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:deleteChild
  0014c	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 133  :                                                     deleteChild;
; 134  : 	cta->baseAdaptor.getChildCount			=  (ANTLR3_UINT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00153	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildCount
  0015f	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 135  :                                                     getChildCount;
; 136  : 	cta->baseAdaptor.getChildIndex			=  (ANTLR3_INT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildIndex
  00172	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 137  :                                                     getChildIndex;
; 138  : 	cta->baseAdaptor.free					=  (void  (*) (pANTLR3_BASE_TREE_ADAPTOR))

  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ctaFree
  00185	48 89 88 58 01
	00 00		 mov	 QWORD PTR [rax+344], rcx

; 139  :                                                     ctaFree;
; 140  : 	cta->baseAdaptor.setDebugEventListener	=  

  0018c	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setDebugEventListener
  00198	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 141  : 													setDebugEventListener;
; 142  : 	cta->baseAdaptor.replaceChildren		=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_INT32, ANTLR3_INT32, void *))

  0019f	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:replaceChildren
  001ab	48 89 88 50 01
	00 00		 mov	 QWORD PTR [rax+336], rcx

; 143  :                                                     replaceChildren;
; 144  : 	cta->baseAdaptor.errorNode				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_TOKEN_STREAM, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN, pANTLR3_EXCEPTION))

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:errorNode
  001be	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 145  :                                                     errorNode;
; 146  : 
; 147  : 	// Install the super class pointer
; 148  : 	//
; 149  : 	cta->baseAdaptor.super	    = cta;

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  001cc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 150  : 
; 151  : 	// Install a tree factory for creating new tree nodes
; 152  : 	//
; 153  : 	cta->arboretum  = antlr3ArboretumNew(strFactory);

  001d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  001d5	e8 00 00 00 00	 call	 antlr3ArboretumNew
  001da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  001df	48 89 81 60 01
	00 00		 mov	 QWORD PTR [rcx+352], rax

; 154  : 
; 155  : 	// Install a token factory for imaginary tokens, these imaginary
; 156  : 	// tokens do not require access to the input stream so we can
; 157  : 	// dummy the creation of it, but they will need a string factory.
; 158  : 	//
; 159  : 	cta->baseAdaptor.tokenFactory						= antlr3TokenFactoryNew(NULL);

  001e6	33 c9		 xor	 ecx, ecx
  001e8	e8 00 00 00 00	 call	 antlr3TokenFactoryNew
  001ed	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cta$[rsp]
  001f2	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 160  : 	cta->baseAdaptor.tokenFactory->unTruc.strFactory	= strFactory;

  001f6	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  001fb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00204	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 161  : 
; 162  : 	// Allow the base tree adaptor to share the tree factory's string factory.
; 163  : 	//
; 164  : 	cta->baseAdaptor.strFactory	= strFactory;

  00208	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0020d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strFactory$[rsp]
  00212	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 165  : 
; 166  : 	// Return the address of the base adaptor interface.
; 167  : 	//
; 168  : 	return  &(cta->baseAdaptor);

  00216	48 8b 44 24 20	 mov	 rax, QWORD PTR cta$[rsp]
  0021b	48 83 c0 08	 add	 rax, 8
$LN1@ANTLR3_TRE:

; 169  : }

  0021f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00223	5f		 pop	 rdi
  00224	c3		 ret	 0
ANTLR3_TREE_ADAPTORNew ENDP
_TEXT	ENDS
END
