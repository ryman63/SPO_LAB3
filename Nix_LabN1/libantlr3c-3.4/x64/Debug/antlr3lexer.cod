; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34435.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	antlr3LexerNewStream
PUBLIC	antlr3LexerNew
PUBLIC	??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@ ; `string'
PUBLIC	??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@	; `string'
PUBLIC	??_C@_03ECLNAHEM@?$CFs?$CI@			; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5@			; `string'
PUBLIC	??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@ ; `string'
PUBLIC	??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@	; `string'
PUBLIC	??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@ ; `string'
PUBLIC	??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@		; `string'
PUBLIC	??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@ ; `string'
PUBLIC	??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@ ; `string'
PUBLIC	??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@ ; `string'
PUBLIC	??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@ ; `string'
EXTRN	__imp_isprint:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	antlr3BaseRecognizerNew:PROC
EXTRN	antlr3RecognitionExceptionNew:PROC
EXTRN	antlr3StackNew:PROC
EXTRN	antlr3TokenFactoryNew:PROC
EXTRN	antlr3SetTokenAPI:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3LexerNewStream DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$antlr3LexerNewStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3LexerNew DD imagerel $LN7
	DD	imagerel $LN7+1022
	DD	imagerel $unwind$antlr3LexerNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mTokens DD imagerel mTokens
	DD	imagerel mTokens+51
	DD	imagerel $unwind$mTokens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setCharStream DD imagerel setCharStream
	DD	imagerel setCharStream+373
	DD	imagerel $unwind$setCharStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pushCharStream DD imagerel pushCharStream
	DD	imagerel pushCharStream+217
	DD	imagerel $unwind$pushCharStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$popCharStream DD imagerel popCharStream
	DD	imagerel popCharStream+242
	DD	imagerel $unwind$popCharStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$emitNew DD imagerel emitNew
	DD	imagerel emitNew+35
	DD	imagerel $unwind$emitNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$emit DD	imagerel emit
	DD	imagerel emit+460
	DD	imagerel $unwind$emit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchs DD imagerel matchs
	DD	imagerel matchs+262
	DD	imagerel $unwind$matchs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchc DD imagerel matchc
	DD	imagerel matchc+205
	DD	imagerel $unwind$matchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchRange DD imagerel matchRange
	DD	imagerel matchRange+228
	DD	imagerel $unwind$matchRange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$matchAny DD imagerel matchAny
	DD	imagerel matchAny+54
	DD	imagerel $unwind$matchAny
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recover DD imagerel recover
	DD	imagerel recover+54
	DD	imagerel $unwind$recover
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+40
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharIndex DD imagerel getCharIndex
	DD	imagerel getCharIndex+53
	DD	imagerel $unwind$getCharIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+20
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+153
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextToken DD imagerel nextToken
	DD	imagerel nextToken+184
	DD	imagerel $unwind$nextToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$displayRecognitionError DD imagerel displayRecognitionError
	DD	imagerel displayRecognitionError+907
	DD	imagerel $unwind$displayRecognitionError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reportError DD imagerel reportError
	DD	imagerel reportError+69
	DD	imagerel $unwind$reportError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCurrentInputSymbol DD imagerel getCurrentInputSymbol
	DD	imagerel getCurrentInputSymbol+15
	DD	imagerel $unwind$getCurrentInputSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getMissingSymbol DD imagerel getMissingSymbol
	DD	imagerel getMissingSymbol+25
	DD	imagerel $unwind$getMissingSymbol
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset DD	imagerel reset
	DD	imagerel reset+249
	DD	imagerel $unwind$reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeLexer DD imagerel freeLexer
	DD	imagerel freeLexer+329
	DD	imagerel $unwind$freeLexer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nextTokenStr DD imagerel nextTokenStr
	DD	imagerel nextTokenStr+590
	DD	imagerel $unwind$nextTokenStr
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@
CONST	SEGMENT
??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@ DB 'is also t'
	DB	'he end of the line, so you must check your lexer rules', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@
CONST	SEGMENT
??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@ DB 'looks like'
	DB	' this:', 0aH, 09H, 09H, '%.*s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@
CONST	SEGMENT
??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@ DB 09H, ' The '
	DB	'lexer was matching from line %d, offset %d, which', 0aH, 09H, ' '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@
CONST	SEGMENT
??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@ DB '(end'
	DB	' of input).', 0aH, 09H, ' This indicates a poorly specified l'
	DB	'exer RULE', 0aH, 09H, ' or unterminated input element such as'
	DB	': "STRING["]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@
CONST	SEGMENT
??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@ DB 09H, '%.*s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@
CONST	SEGMENT
??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@ DB 'near char(%#02X'
	DB	') :', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@
CONST	SEGMENT
??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@ DB 'near ''%c'' :', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@
CONST	SEGMENT
??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@ DB ':'
	DB	' lexer error %d :', 0aH, 09H, '%s at offset %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5@ DB '%d) ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECLNAHEM@?$CFs?$CI@
CONST	SEGMENT
??_C@_03ECLNAHEM@?$CFs?$CI@ DB '%s(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
CONST	SEGMENT
??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@ DB '-unknown source-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@
CONST	SEGMENT
??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@ DB 'le'
	DB	'xer->mTokens(): Error: No lexer rules were added to the lexer'
	DB	' yet!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextTokenStr DD 020a01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeLexer DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getMissingSymbol DD 011501H
	DD	07015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCurrentInputSymbol DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reportError DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$displayRecognitionError DD 031201H
	DD	0160112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nextToken DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharIndex DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recover DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchAny DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchRange DD 021301H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchc DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$matchs DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$emit DD	020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$emitNew DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$popCharStream DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pushCharStream DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setCharStream DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mTokens DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3LexerNew DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3LexerNewStream DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT nextTokenStr
_TEXT	SEGMENT
lexer$ = 32
state$ = 40
input$ = 48
istream$ = 56
teof$1 = 64
toksource$ = 96
nextTokenStr PROC					; COMDAT

; 218  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 219  :     pANTLR3_LEXER                   lexer;
; 220  :     pANTLR3_RECOGNIZER_SHARED_STATE state;
; 221  :     pANTLR3_INPUT_STREAM            input;
; 222  :     pANTLR3_INT_STREAM              istream;
; 223  : 
; 224  :     lexer   = (pANTLR3_LEXER)(toksource->super);

  0000a	48 8b 44 24 60	 mov	 rax, QWORD PTR toksource$[rsp]
  0000f	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  00016	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 225  :     state   = lexer->rec->state;

  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00020	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00024	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00028	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 226  :     input   = lexer->input;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00032	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00036	48 89 44 24 30	 mov	 QWORD PTR input$[rsp], rax

; 227  :     istream = input->istream;

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00040	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00043	48 89 44 24 38	 mov	 QWORD PTR istream$[rsp], rax
$LN2@nextTokenS:

; 228  : 
; 229  :     /// Loop until we get a non skipped token or EOF
; 230  :     ///
; 231  :     for	(;;)
; 232  :     {
; 233  :         // Get rid of any previous token (token factory takes care of
; 234  :         // any de-allocation when this token is finally used up.
; 235  :         //
; 236  :         state->token		    = NULL;

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004d	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 237  :         state->error		    = ANTLR3_FALSE;	    // Start out without an exception

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0005a	c6 00 00	 mov	 BYTE PTR [rax], 0

; 238  :         state->failed		    = ANTLR3_FALSE;

  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00062	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0
$LN5@nextTokenS:

; 239  : 
; 240  :         // Now call the matching rules and see if we can generate a new token
; 241  :         //
; 242  :         for	(;;)
; 243  :         {
; 244  :             // Record the start of the token in our input stream.
; 245  :             //
; 246  :             state->channel			    = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0006b	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 247  :             state->tokenStartCharIndex	            = (ANTLR3_MARKER)(((pANTLR3_UINT8)input->nextChar));

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00077	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0007c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00080	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 248  :             state->tokenStartCharPositionInLine     = input->charPositionInLine;

  00087	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00091	8b 49 40	 mov	 ecx, DWORD PTR [rcx+64]
  00094	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 249  :             state->tokenStartLine		    = input->line;

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  000a1	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  000a4	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 250  :             state->text			            = NULL;

  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ac	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 251  :             state->custom                           = NULL;

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000bc	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 252  :             state->user1                            = 0;

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000cc	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 253  :             state->user2                            = 0;

  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000db	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 254  :             state->user3                            = 0;

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ea	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 255  : 
; 256  :             if  (istream->_LA(istream, 1) == ANTLR3_CHARSTREAM_EOF)

  000f4	ba 01 00 00 00	 mov	 edx, 1
  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR istream$[rsp]
  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR istream$[rsp]
  00103	ff 50 30	 call	 QWORD PTR [rax+48]
  00106	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00109	0f 85 86 00 00
	00		 jne	 $LN8@nextTokenS

; 257  :             {
; 258  :                 // Reached the end of the current stream, nothing more to do if this is
; 259  :                 // the last in the stack.
; 260  :                 //
; 261  :                 pANTLR3_COMMON_TOKEN    teof = &(toksource->eofToken);

  0010f	48 8b 44 24 60	 mov	 rax, QWORD PTR toksource$[rsp]
  00114	48 83 c0 10	 add	 rax, 16
  00118	48 89 44 24 40	 mov	 QWORD PTR teof$1[rsp], rax

; 262  : 
; 263  :                 teof->setStartIndex (teof, lexer->getCharIndex(lexer));

  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00122	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00127	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0012d	48 8b d0	 mov	 rdx, rax
  00130	48 8b 4c 24 40	 mov	 rcx, QWORD PTR teof$1[rsp]
  00135	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  0013a	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 264  :                 teof->setStopIndex  (teof, lexer->getCharIndex(lexer));

  00140	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0014a	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00150	48 8b d0	 mov	 rdx, rax
  00153	48 8b 4c 24 40	 mov	 rcx, QWORD PTR teof$1[rsp]
  00158	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  0015d	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]

; 265  :                 teof->setLine	    (teof, lexer->getLine(lexer));

  00163	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00168	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0016d	ff 50 78	 call	 QWORD PTR [rax+120]
  00170	8b d0		 mov	 edx, eax
  00172	48 8b 4c 24 40	 mov	 rcx, QWORD PTR teof$1[rsp]
  00177	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  0017c	ff 90 a8 00 00
	00		 call	 QWORD PTR [rax+168]

; 266  :                 teof->factoryMade = ANTLR3_TRUE;	// This isn't really manufactured but it stops things from trying to free it

  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  00187	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 267  :                 return  teof;

  0018b	48 8b 44 24 40	 mov	 rax, QWORD PTR teof$1[rsp]
  00190	e9 b3 00 00 00	 jmp	 $LN1@nextTokenS
$LN8@nextTokenS:

; 268  :             }
; 269  : 
; 270  :             state->token		= NULL;

  00195	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0019a	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 271  :             state->error		= ANTLR3_FALSE;	    // Start out without an exception

  001a2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001a7	c6 00 00	 mov	 BYTE PTR [rax], 0

; 272  :             state->failed		= ANTLR3_FALSE;

  001aa	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001af	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 273  : 
; 274  :             // Call the generated lexer, see if it can get a new token together.
; 275  :             //
; 276  :             lexer->mTokens(lexer->ctx);

  001b3	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001b8	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001bc	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001c1	ff 50 48	 call	 QWORD PTR [rax+72]

; 277  : 
; 278  :             if  (state->error  == ANTLR3_TRUE)

  001c4	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001c9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001cc	83 f8 01	 cmp	 eax, 1
  001cf	75 2e		 jne	 SHORT $LN9@nextTokenS

; 279  :             {
; 280  :                 // Recognition exception, report it and try to recover.
; 281  :                 //
; 282  :                 state->failed	    = ANTLR3_TRUE;

  001d1	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001d6	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 283  :                 lexer->rec->reportError(lexer->rec);

  001da	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001df	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  001e8	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001ec	ff 50 48	 call	 QWORD PTR [rax+72]

; 284  :                 lexer->recover(lexer); 

  001ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  001f4	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001f9	ff 50 70	 call	 QWORD PTR [rax+112]
  001fc	90		 npad	 1

; 285  :             }

  001fd	eb 3f		 jmp	 SHORT $LN10@nextTokenS
$LN9@nextTokenS:

; 286  :             else
; 287  :             {
; 288  :                 if (state->token == NULL)

  001ff	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00204	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00209	75 0d		 jne	 SHORT $LN11@nextTokenS

; 289  :                 {
; 290  :                     // Emit the real token, which adds it in to the token stream basically
; 291  :                     //
; 292  :                     emit(lexer);

  0020b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00210	e8 00 00 00 00	 call	 emit
  00215	90		 npad	 1

; 293  :                 }

  00216	eb 1b		 jmp	 SHORT $LN12@nextTokenS
$LN11@nextTokenS:

; 294  :                 else if	(state->token ==  &(toksource->skipToken))

  00218	48 8b 44 24 60	 mov	 rax, QWORD PTR toksource$[rsp]
  0021d	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  00223	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00228	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0022c	75 05		 jne	 SHORT $LN13@nextTokenS

; 295  :                 {
; 296  :                     // A real token could have been generated, but "Computer say's naaaaah" and it
; 297  :                     // it is just something we need to skip altogether.
; 298  :                     //
; 299  :                     continue;

  0022e	e9 33 fe ff ff	 jmp	 $LN5@nextTokenS
$LN13@nextTokenS:
$LN12@nextTokenS:

; 300  :                 }
; 301  : 
; 302  :                 // Good token, not skipped, not EOF token
; 303  :                 //
; 304  :                 return  state->token;

  00233	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00238	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0023c	eb 0a		 jmp	 SHORT $LN1@nextTokenS
$LN10@nextTokenS:

; 305  :             }
; 306  :         }

  0023e	e9 23 fe ff ff	 jmp	 $LN5@nextTokenS

; 307  :     }

  00243	e9 00 fe ff ff	 jmp	 $LN2@nextTokenS
$LN1@nextTokenS:

; 308  : }

  00248	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0024c	5f		 pop	 rdi
  0024d	c3		 ret	 0
nextTokenStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT freeLexer
_TEXT	SEGMENT
tv161 = 32
tv154 = 40
lexer$ = 64
freeLexer PROC						; COMDAT

; 689  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 690  : 	// This may have ben a delegate or delegator lexer, in which case the
; 691  : 	// state may already have been freed (and set to NULL therefore)
; 692  : 	// so we ignore the state if we don't have it.
; 693  : 	//
; 694  : 	if	(lexer->rec->state != NULL)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00013	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00018	0f 84 e8 00 00
	00		 je	 $LN2@freeLexer

; 695  : 	{
; 696  : 		if	(lexer->rec->state->streams != NULL)

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00023	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00027	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002b	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00033	74 36		 je	 SHORT $LN3@freeLexer

; 697  : 		{
; 698  : 			lexer->rec->state->streams->free(lexer->rec->state->streams);

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0003a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00047	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004f	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  00056	48 89 4c 24 20	 mov	 QWORD PTR tv161[rsp], rcx
  0005b	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR tv161[rsp]
  00067	ff 50 10	 call	 QWORD PTR [rax+16]
  0006a	90		 npad	 1
$LN3@freeLexer:

; 699  : 		}
; 700  : 		if	(lexer->rec->state->tokFactory != NULL)

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00070	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00074	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00078	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0007d	74 47		 je	 SHORT $LN4@freeLexer

; 701  : 		{
; 702  : 			lexer->rec->state->tokFactory->close(lexer->rec->state->tokFactory);

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00084	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00091	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00095	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00099	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0009d	48 89 4c 24 28	 mov	 QWORD PTR tv154[rsp], rcx
  000a2	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000a6	48 8b 44 24 28	 mov	 rax, QWORD PTR tv154[rsp]
  000ab	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]

; 703  : 			lexer->rec->state->tokFactory = NULL;

  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000b6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ba	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000be	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN4@freeLexer:

; 704  : 		}
; 705  : 		if	(lexer->rec->state->tokSource != NULL)

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000cb	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000cf	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000d3	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000d8	74 2c		 je	 SHORT $LN5@freeLexer

; 706  : 		{
; 707  : 			ANTLR3_FREE(lexer->rec->state->tokSource);

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000df	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000e3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e7	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 708  : 			lexer->rec->state->tokSource = NULL;

  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000f6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000fa	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000fe	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN5@freeLexer:
$LN2@freeLexer:

; 709  : 		}
; 710  : 	}
; 711  : 	if	(lexer->rec != NULL)

  00106	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0010b	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00110	74 25		 je	 SHORT $LN6@freeLexer

; 712  : 	{
; 713  : 		lexer->rec->free(lexer->rec);

  00112	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00117	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00120	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00124	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 714  : 		lexer->rec = NULL;

  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0012f	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN6@freeLexer:

; 715  : 	}
; 716  : 	ANTLR3_FREE(lexer);

  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00142	90		 npad	 1

; 717  : }

  00143	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00147	5f		 pop	 rdi
  00148	c3		 ret	 0
freeLexer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT reset
_TEXT	SEGMENT
lexer$ = 32
tv130 = 40
rec$ = 64
reset	PROC						; COMDAT

; 176  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 177  :     pANTLR3_LEXER   lexer;
; 178  : 
; 179  :     lexer   = rec->super;

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR rec$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 180  : 
; 181  :     lexer->rec->state->token			    = NULL;

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0001c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00020	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00024	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 182  :     lexer->rec->state->type			    = ANTLR3_TOKEN_INVALID;

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00031	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [rax+116], 0

; 183  :     lexer->rec->state->channel			    = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00045	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 184  :     lexer->rec->state->tokenStartCharIndex	    = -1;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00059	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00061	48 c7 80 80 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+128], -1

; 185  :     lexer->rec->state->tokenStartCharPositionInLine = -1;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00071	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00079	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1

; 186  :     lexer->rec->state->tokenStartLine		    = -1;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00085	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00089	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008d	c7 40 78 ff ff
	ff ff		 mov	 DWORD PTR [rax+120], -1

; 187  : 
; 188  :     lexer->rec->state->text	                    = NULL;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00099	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a1	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 189  : 
; 190  :     // OK - that's all hunky dory, but we may well have had
; 191  :     // a token factory that needs a reset. Do that here
; 192  :     //
; 193  :     if  (lexer->rec->state->tokFactory != NULL)

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000b1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b9	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000be	74 33		 je	 SHORT $LN2@reset

; 194  :     {
; 195  :         lexer->rec->state->tokFactory->reset(lexer->rec->state->tokFactory);

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000c5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d2	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000d6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000da	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000de	48 89 4c 24 28	 mov	 QWORD PTR tv130[rsp], rcx
  000e3	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR tv130[rsp]
  000ec	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
  000f2	90		 npad	 1
$LN2@reset:

; 196  :     }
; 197  : }

  000f3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f7	5f		 pop	 rdi
  000f8	c3		 ret	 0
reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getMissingSymbol
_TEXT	SEGMENT
recognizer$ = 16
istream$ = 24
e$ = 32
expectedTokenType$ = 40
follow$ = 48
getMissingSymbol PROC					; COMDAT

; 902  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi

; 903  : 	return NULL;

  00015	33 c0		 xor	 eax, eax

; 904  : }

  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
getMissingSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getCurrentInputSymbol
_TEXT	SEGMENT
recognizer$ = 16
istream$ = 24
getCurrentInputSymbol PROC				; COMDAT

; 895  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 896  : 	return NULL;

  0000b	33 c0		 xor	 eax, eax

; 897  : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getCurrentInputSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT reportError
_TEXT	SEGMENT
rec$ = 48
reportError PROC					; COMDAT

; 412  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 413  :     // Indicate this recognizer had an error while processing.
; 414  : 	//
; 415  : 	rec->state->errorCount++;

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00016	ff c0		 inc	 eax
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$[rsp]
  0001d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00021	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 416  : 
; 417  :     rec->displayRecognitionError(rec, rec->state->tokenNames);

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  00029	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002d	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rec$[rsp]
  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR rec$[rsp]
  0003b	ff 50 50	 call	 QWORD PTR [rax+80]
  0003e	90		 npad	 1

; 418  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
reportError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT displayRecognitionError
_TEXT	SEGMENT
lexer$ = 48
ex$ = 56
ftext$ = 64
width$1 = 72
tv236 = 80
tv95 = 88
tv233 = 96
tv234 = 104
tv161 = 112
tv170 = 116
tv230 = 120
tv228 = 128
tv226 = 136
tv227 = 144
tv212 = 152
tv206 = 160
recognizer$ = 192
tokenNames$ = 200
displayRecognitionError PROC				; COMDAT

; 428  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 429  :     pANTLR3_LEXER			lexer;
; 430  : 	pANTLR3_EXCEPTION	    ex;
; 431  : 	pANTLR3_STRING			ftext;
; 432  : 
; 433  :     lexer   = (pANTLR3_LEXER)(recognizer->super);

  00012	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	48 89 44 24 30	 mov	 QWORD PTR lexer$[rsp], rax

; 434  : 	ex		= lexer->rec->state->exception;

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00027	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00033	48 89 44 24 38	 mov	 QWORD PTR ex$[rsp], rax

; 435  : 
; 436  : 	// See if there is a 'filename' we can use
; 437  :     //
; 438  :     if	(ex->name == NULL)

  00038	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  0003d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00042	75 1d		 jne	 SHORT $LN2@displayRec

; 439  :     {
; 440  : 		ANTLR3_FPRINTF(stderr, "-unknown source-(");

  00044	b9 02 00 00 00	 mov	 ecx, 2
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 fprintf
  0005e	90		 npad	 1

; 441  :     }

  0005f	eb 41		 jmp	 SHORT $LN3@displayRec
$LN2@displayRec:

; 442  :     else
; 443  :     {
; 444  : 		ftext = ex->streamName->to8(ex->streamName);

  00061	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  00066	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  0006f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00073	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00079	48 89 44 24 40	 mov	 QWORD PTR ftext$[rsp], rax

; 445  : 		ANTLR3_FPRINTF(stderr, "%s(", ftext->chars);

  0007e	b9 02 00 00 00	 mov	 ecx, 2
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ftext$[rsp]
  0008e	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ECLNAHEM@?$CFs?$CI@
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 fprintf
  000a1	90		 npad	 1
$LN3@displayRec:

; 446  :     }
; 447  : 
; 448  :     ANTLR3_FPRINTF(stderr, "%d) ", recognizer->state->exception->line);

  000a2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR recognizer$[rsp]
  000aa	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ae	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b2	48 89 44 24 50	 mov	 QWORD PTR tv236[rsp], rax
  000b7	b9 02 00 00 00	 mov	 ecx, 2
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv236[rsp]
  000c7	44 8b 41 54	 mov	 r8d, DWORD PTR [rcx+84]
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CGKAJBAP@?$CFd?$CJ?5@
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 fprintf

; 449  :     ANTLR3_FPRINTF(stderr, ": lexer error %d :\n\t%s at offset %d, ", 

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  000df	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  000e2	ff c0		 inc	 eax
  000e4	89 44 24 58	 mov	 DWORD PTR tv95[rsp], eax
  000e8	b9 02 00 00 00	 mov	 ecx, 2
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f3	8b 4c 24 58	 mov	 ecx, DWORD PTR tv95[rsp]
  000f7	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00100	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00104	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00109	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@
  00113	48 8b c8	 mov	 rcx, rax
  00116	e8 00 00 00 00	 call	 fprintf
  0011b	90		 npad	 1

; 450  : 						ex->type,
; 451  : 						(pANTLR3_UINT8)	   (ex->message),
; 452  : 					    ex->charPositionInLine+1
; 453  : 		    );
; 454  : 	{
; 455  : 		ANTLR3_INT32	width;
; 456  : 
; 457  : 		width	= ANTLR3_UINT32_CAST(( (pANTLR3_UINT8)(lexer->input->data) + (lexer->input->size(lexer->input) )) - (pANTLR3_UINT8)(ex->index));

  0011c	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00121	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00125	48 89 44 24 60	 mov	 QWORD PTR tv233[rsp], rax
  0012a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  0012f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00133	48 89 4c 24 68	 mov	 QWORD PTR tv234[rsp], rcx
  00138	48 8b 54 24 30	 mov	 rdx, QWORD PTR lexer$[rsp]
  0013d	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  00141	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv234[rsp]
  00146	ff 92 90 00 00
	00		 call	 QWORD PTR [rdx+144]
  0014c	8b c0		 mov	 eax, eax
  0014e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv233[rsp]
  00153	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00157	48 03 c8	 add	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00162	48 2b 41 28	 sub	 rax, QWORD PTR [rcx+40]
  00166	89 44 24 48	 mov	 DWORD PTR width$1[rsp], eax

; 458  : 
; 459  : 		if	(width >= 1)

  0016a	83 7c 24 48 01	 cmp	 DWORD PTR width$1[rsp], 1
  0016f	0f 8c ae 00 00
	00		 jl	 $LN4@displayRec

; 460  : 		{			
; 461  : 			if	(isprint(ex->c))

  00175	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  0017a	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00183	85 c0		 test	 eax, eax
  00185	74 26		 je	 SHORT $LN6@displayRec

; 462  : 			{
; 463  : 				ANTLR3_FPRINTF(stderr, "near '%c' :\n", ex->c);

  00187	b9 02 00 00 00	 mov	 ecx, 2
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00192	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00197	44 8b 41 50	 mov	 r8d, DWORD PTR [rcx+80]
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@
  001a2	48 8b c8	 mov	 rcx, rax
  001a5	e8 00 00 00 00	 call	 fprintf
  001aa	90		 npad	 1

; 464  : 			}

  001ab	eb 2f		 jmp	 SHORT $LN7@displayRec
$LN6@displayRec:

; 465  : 			else
; 466  : 			{
; 467  : 				ANTLR3_FPRINTF(stderr, "near char(%#02X) :\n", (ANTLR3_UINT8)(ex->c));

  001ad	48 8b 44 24 38	 mov	 rax, QWORD PTR ex$[rsp]
  001b2	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  001b6	89 44 24 70	 mov	 DWORD PTR tv161[rsp], eax
  001ba	b9 02 00 00 00	 mov	 ecx, 2
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c5	8b 4c 24 70	 mov	 ecx, DWORD PTR tv161[rsp]
  001c9	44 8b c1	 mov	 r8d, ecx
  001cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@
  001d3	48 8b c8	 mov	 rcx, rax
  001d6	e8 00 00 00 00	 call	 fprintf
  001db	90		 npad	 1
$LN7@displayRec:

; 468  : 			}
; 469  : 			ANTLR3_FPRINTF(stderr, "\t%.*s\n", width > 20 ? 20 : width ,((pANTLR3_UINT8)ex->index));

  001dc	83 7c 24 48 14	 cmp	 DWORD PTR width$1[rsp], 20
  001e1	7e 0a		 jle	 SHORT $LN11@displayRec
  001e3	c7 44 24 74 14
	00 00 00	 mov	 DWORD PTR tv170[rsp], 20
  001eb	eb 08		 jmp	 SHORT $LN12@displayRec
$LN11@displayRec:
  001ed	8b 44 24 48	 mov	 eax, DWORD PTR width$1[rsp]
  001f1	89 44 24 74	 mov	 DWORD PTR tv170[rsp], eax
$LN12@displayRec:
  001f5	b9 02 00 00 00	 mov	 ecx, 2
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00200	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ex$[rsp]
  00205	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  00209	44 8b 44 24 74	 mov	 r8d, DWORD PTR tv170[rsp]
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@
  00215	48 8b c8	 mov	 rcx, rax
  00218	e8 00 00 00 00	 call	 fprintf
  0021d	90		 npad	 1

; 470  : 		}

  0021e	e9 5f 01 00 00	 jmp	 $LN5@displayRec
$LN4@displayRec:

; 471  : 		else
; 472  : 		{
; 473  : 			ANTLR3_FPRINTF(stderr, "(end of input).\n\t This indicates a poorly specified lexer RULE\n\t or unterminated input element such as: \"STRING[\"]\n");

  00223	b9 02 00 00 00	 mov	 ecx, 2
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@
  00235	48 8b c8	 mov	 rcx, rax
  00238	e8 00 00 00 00	 call	 fprintf

; 474  : 			ANTLR3_FPRINTF(stderr, "\t The lexer was matching from line %d, offset %d, which\n\t ", 

  0023d	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00242	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00246	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0024a	48 89 44 24 78	 mov	 QWORD PTR tv230[rsp], rax
  0024f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  00254	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00258	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0025c	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv228[rsp], rcx
  00264	b9 02 00 00 00	 mov	 ecx, 2
  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv230[rsp]
  00274	44 8b 49 7c	 mov	 r9d, DWORD PTR [rcx+124]
  00278	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  00280	44 8b 41 78	 mov	 r8d, DWORD PTR [rcx+120]
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@
  0028b	48 8b c8	 mov	 rcx, rax
  0028e	e8 00 00 00 00	 call	 fprintf

; 475  : 								(ANTLR3_UINT32)(lexer->rec->state->tokenStartLine),
; 476  : 								(ANTLR3_UINT32)(lexer->rec->state->tokenStartCharPositionInLine)
; 477  : 								);
; 478  : 			width = ANTLR3_UINT32_CAST(((pANTLR3_UINT8)(lexer->input->data)+(lexer->input->size(lexer->input))) - (pANTLR3_UINT8)(lexer->rec->state->tokenStartCharIndex));

  00293	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00298	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0029c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  002a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  002a9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002ad	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv227[rsp], rcx
  002b5	48 8b 54 24 30	 mov	 rdx, QWORD PTR lexer$[rsp]
  002ba	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  002be	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv227[rsp]
  002c6	ff 92 90 00 00
	00		 call	 QWORD PTR [rdx+144]
  002cc	8b c0		 mov	 eax, eax
  002ce	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv226[rsp]
  002d6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002da	48 03 c8	 add	 rcx, rax
  002dd	48 8b c1	 mov	 rax, rcx
  002e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  002e5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002e9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002ed	48 2b 81 80 00
	00 00		 sub	 rax, QWORD PTR [rcx+128]
  002f4	89 44 24 48	 mov	 DWORD PTR width$1[rsp], eax

; 479  : 
; 480  : 			if	(width >= 1)

  002f8	83 7c 24 48 01	 cmp	 DWORD PTR width$1[rsp], 1
  002fd	7c 68		 jl	 SHORT $LN8@displayRec

; 481  : 			{
; 482  : 				ANTLR3_FPRINTF(stderr, "looks like this:\n\t\t%.*s\n", width > 20 ? 20 : width ,(pANTLR3_UINT8)(lexer->rec->state->tokenStartCharIndex));

  002ff	83 7c 24 48 14	 cmp	 DWORD PTR width$1[rsp], 20
  00304	7e 0d		 jle	 SHORT $LN13@displayRec
  00306	c7 84 24 98 00
	00 00 14 00 00
	00		 mov	 DWORD PTR tv212[rsp], 20
  00311	eb 0b		 jmp	 SHORT $LN14@displayRec
$LN13@displayRec:
  00313	8b 44 24 48	 mov	 eax, DWORD PTR width$1[rsp]
  00317	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
$LN14@displayRec:
  0031e	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  00323	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00327	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0032b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  00333	b9 02 00 00 00	 mov	 ecx, 2
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0033e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv206[rsp]
  00346	4c 8b 89 80 00
	00 00		 mov	 r9, QWORD PTR [rcx+128]
  0034d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR tv212[rsp]
  00355	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@
  0035c	48 8b c8	 mov	 rcx, rax
  0035f	e8 00 00 00 00	 call	 fprintf
  00364	90		 npad	 1

; 483  : 			}

  00365	eb 1b		 jmp	 SHORT $LN9@displayRec
$LN8@displayRec:

; 484  : 			else
; 485  : 			{
; 486  : 				ANTLR3_FPRINTF(stderr, "is also the end of the line, so you must check your lexer rules\n");

  00367	b9 02 00 00 00	 mov	 ecx, 2
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00372	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@
  00379	48 8b c8	 mov	 rcx, rax
  0037c	e8 00 00 00 00	 call	 fprintf
  00381	90		 npad	 1
$LN9@displayRec:
$LN5@displayRec:

; 487  : 			}
; 488  : 		}
; 489  : 	}
; 490  : }

  00382	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00389	5f		 pop	 rdi
  0038a	c3		 ret	 0
displayRecognitionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT nextToken
_TEXT	SEGMENT
tok$ = 32
lexer$1 = 40
tv87 = 48
toksource$ = 80
nextToken PROC						; COMDAT

; 331  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 332  : 	pANTLR3_COMMON_TOKEN tok;
; 333  : 
; 334  : 	// Find the next token in the current stream
; 335  : 	//
; 336  : 	tok = nextTokenStr(toksource);

  0000a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR toksource$[rsp]
  0000f	e8 00 00 00 00	 call	 nextTokenStr
  00014	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax
$LN2@nextToken:

; 337  : 
; 338  : 	// If we got to the EOF token then switch to the previous
; 339  : 	// input stream if there were any and just return the
; 340  : 	// EOF if there are none. We must check the next token
; 341  : 	// in any outstanding input stream we pop into the active
; 342  : 	// role to see if it was sitting at EOF after PUSHing the
; 343  : 	// stream we just consumed, otherwise we will return EOF
; 344  : 	// on the reinstalled input stream, when in actual fact
; 345  : 	// there might be more input streams to POP before the
; 346  : 	// real EOF of the whole logical inptu stream. Hence we
; 347  : 	// use a while loop here until we find somethign in the stream
; 348  : 	// that isn't EOF or we reach the actual end of the last input
; 349  : 	// stream on the stack.
; 350  : 	//
; 351  : 	while	(tok->type == ANTLR3_TOKEN_EOF)

  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0001e	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  00021	0f 85 86 00 00
	00		 jne	 $LN3@nextToken

; 352  : 	{
; 353  : 		pANTLR3_LEXER   lexer;
; 354  : 
; 355  : 		lexer   = (pANTLR3_LEXER)(toksource->super);

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR toksource$[rsp]
  0002c	48 8b 80 20 02
	00 00		 mov	 rax, QWORD PTR [rax+544]
  00033	48 89 44 24 28	 mov	 QWORD PTR lexer$1[rsp], rax

; 356  : 
; 357  : 		if  (lexer->rec->state->streams != NULL && lexer->rec->state->streams->size(lexer->rec->state->streams) > 0)

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$1[rsp]
  0003d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  0004d	74 57		 je	 SHORT $LN4@nextToken
  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$1[rsp]
  00054	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00058	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lexer$1[rsp]
  00061	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00065	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00069	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  00070	48 89 4c 24 30	 mov	 QWORD PTR tv87[rsp], rcx
  00075	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR tv87[rsp]
  00081	ff 50 30	 call	 QWORD PTR [rax+48]
  00084	85 c0		 test	 eax, eax
  00086	76 1e		 jbe	 SHORT $LN4@nextToken

; 358  : 		{
; 359  : 			// We have another input stream in the stack so we
; 360  : 			// need to revert to it, then resume the loop to check
; 361  : 			// it wasn't sitting at EOF itself.
; 362  : 			//
; 363  : 			lexer->popCharStream(lexer);

  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lexer$1[rsp]
  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR lexer$1[rsp]
  00092	ff 50 30	 call	 QWORD PTR [rax+48]

; 364  : 			tok = nextTokenStr(toksource);

  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR toksource$[rsp]
  0009a	e8 00 00 00 00	 call	 nextTokenStr
  0009f	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 365  : 		}

  000a4	eb 02		 jmp	 SHORT $LN5@nextToken
$LN4@nextToken:

; 366  : 		else
; 367  : 		{
; 368  : 			// There were no more streams on the input stack
; 369  : 			// so this EOF is the 'real' logical EOF for
; 370  : 			// the input stream. So we just exit the loop and 
; 371  : 			// return the EOF we have found.
; 372  : 			//
; 373  : 			break;

  000a6	eb 05		 jmp	 SHORT $LN3@nextToken
$LN5@nextToken:

; 374  : 		}
; 375  : 		
; 376  : 	}

  000a8	e9 6c ff ff ff	 jmp	 $LN2@nextToken
$LN3@nextToken:

; 377  : 
; 378  : 	// return whatever token we have, which may be EOF
; 379  : 	//
; 380  : 	return  tok;

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]

; 381  : }

  000b2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
nextToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getText
_TEXT	SEGMENT
tv88 = 32
lexer$ = 64
getText	PROC						; COMDAT

; 879  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 880  : 	if (lexer->rec->state->text)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001f	74 16		 je	 SHORT $LN2@getText

; 881  : 	{
; 882  : 		return	lexer->rec->state->text;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00026	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002e	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00035	eb 5c		 jmp	 SHORT $LN1@getText
$LN2@getText:

; 883  : 
; 884  : 	}
; 885  : 	return  lexer->input->substr(

  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00041	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0004c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00050	0f b6 89 d4 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+212]
  00057	48 2b c1	 sub	 rax, rcx
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0005f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00063	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00067	48 8b 54 24 40	 mov	 rdx, QWORD PTR lexer$[rsp]
  0006c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00070	48 89 54 24 20	 mov	 QWORD PTR tv88[rsp], rdx
  00075	4c 8b c0	 mov	 r8, rax
  00078	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00084	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR tv88[rsp]
  0008d	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN1@getText:

; 886  : 									lexer->input, 
; 887  : 									lexer->rec->state->tokenStartCharIndex,
; 888  : 									lexer->getCharIndex(lexer) - lexer->input->charByteSize
; 889  : 							);
; 890  : 
; 891  : }

  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
lexer$ = 16
getCharPositionInLine PROC				; COMDAT

; 868  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 869  :     return  lexer->input->charPositionInLine;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR lexer$[rsp]
  0000b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0000f	8b 40 40	 mov	 eax, DWORD PTR [rax+64]

; 870  : }

  00012	5f		 pop	 rdi
  00013	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getCharIndex
_TEXT	SEGMENT
tv71 = 32
lexer$ = 64
getCharIndex PROC					; COMDAT

; 873  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 874  :     return lexer->input->istream->index(lexer->input->istream);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00018	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 89 4c 24 20	 mov	 QWORD PTR tv71[rsp], rcx
  00024	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR tv71[rsp]
  0002c	ff 50 40	 call	 QWORD PTR [rax+64]

; 875  : }

  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
getCharIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT getLine
_TEXT	SEGMENT
lexer$ = 48
getLine	PROC						; COMDAT

; 862  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 863  :     return  lexer->input->getLine(lexer->input);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lexer$[rsp]
  00018	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001c	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]

; 864  : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT recover
_TEXT	SEGMENT
tv70 = 32
lexer$ = 64
recover	PROC						; COMDAT

; 856  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 857  :     lexer->input->istream->consume(lexer->input->istream);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00018	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 89 4c 24 20	 mov	 QWORD PTR tv70[rsp], rcx
  00024	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR tv70[rsp]
  0002c	ff 50 28	 call	 QWORD PTR [rax+40]
  0002f	90		 npad	 1

; 858  : }

  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
recover	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchAny
_TEXT	SEGMENT
tv70 = 32
lexer$ = 64
matchAny PROC						; COMDAT

; 850  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 851  :     lexer->input->istream->consume(lexer->input->istream);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00018	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 89 4c 24 20	 mov	 QWORD PTR tv70[rsp], rcx
  00024	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR tv70[rsp]
  0002c	ff 50 28	 call	 QWORD PTR [rax+40]
  0002f	90		 npad	 1

; 852  : }

  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
matchAny ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchRange
_TEXT	SEGMENT
c$ = 32
tv138 = 40
tv135 = 48
lexer$ = 80
low$ = 88
high$ = 96
matchRange PROC						; COMDAT

; 811  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 812  :     ANTLR3_UCHAR    c;
; 813  : 
; 814  :     /* What is in the stream at the moment?
; 815  :      */
; 816  :     c	= lexer->input->istream->_LA(lexer->input->istream, 1);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00018	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  00021	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	48 89 4c 24 28	 mov	 QWORD PTR tv138[rsp], rcx
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR tv138[rsp]
  0003a	ff 50 30	 call	 QWORD PTR [rax+48]
  0003d	89 44 24 20	 mov	 DWORD PTR c$[rsp], eax

; 817  :     if	( c >= low && c <= high)

  00041	8b 44 24 58	 mov	 eax, DWORD PTR low$[rsp]
  00045	39 44 24 20	 cmp	 DWORD PTR c$[rsp], eax
  00049	72 44		 jb	 SHORT $LN2@matchRange
  0004b	8b 44 24 60	 mov	 eax, DWORD PTR high$[rsp]
  0004f	39 44 24 20	 cmp	 DWORD PTR c$[rsp], eax
  00053	77 3a		 ja	 SHORT $LN2@matchRange

; 818  :     {
; 819  : 	/* Matched correctly, consume it
; 820  : 	 */
; 821  : 	lexer->input->istream->consume(lexer->input->istream);

  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0005a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  00063	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00067	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006a	48 89 4c 24 30	 mov	 QWORD PTR tv135[rsp], rcx
  0006f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR tv135[rsp]
  00077	ff 50 28	 call	 QWORD PTR [rax+40]

; 822  : 
; 823  : 	/* Reset any failed indicator
; 824  : 	 */
; 825  : 	lexer->rec->state->failed = ANTLR3_FALSE;

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0007f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00083	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00087	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 826  : 
; 827  : 	return	ANTLR3_TRUE;

  0008b	b0 01		 mov	 al, 1
  0008d	eb 4f		 jmp	 SHORT $LN1@matchRange
$LN2@matchRange:

; 828  :     }
; 829  :     
; 830  :     /* Failed to match, execption and recovery time.
; 831  :      */
; 832  : 
; 833  :     if	(lexer->rec->state->backtracking > 0)

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00094	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00098	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009c	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000a0	7e 15		 jle	 SHORT $LN3@matchRange

; 834  :     {
; 835  : 	lexer->rec->state->failed  = ANTLR3_TRUE;

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000a7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ab	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000af	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 836  : 	return	ANTLR3_FALSE;

  000b3	32 c0		 xor	 al, al
  000b5	eb 27		 jmp	 SHORT $LN1@matchRange
$LN3@matchRange:

; 837  :     }
; 838  : 
; 839  :     lexer->rec->exConstruct(lexer->rec);

  000b7	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000bc	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000c5	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000c9	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 840  : 
; 841  :     /* TODO: Implement exception creation more fully
; 842  :      */
; 843  :     lexer->recover(lexer);

  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000d9	ff 50 70	 call	 QWORD PTR [rax+112]

; 844  : 
; 845  :     return  ANTLR3_FALSE;

  000dc	32 c0		 xor	 al, al
$LN1@matchRange:

; 846  : }

  000de	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
matchRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchc
_TEXT	SEGMENT
tv137 = 32
tv134 = 40
lexer$ = 64
c$ = 72
matchc	PROC						; COMDAT

; 771  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 772  : 	if	(lexer->input->istream->_LA(lexer->input->istream, 1) == c)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0001c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00020	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00023	48 89 4c 24 20	 mov	 QWORD PTR tv137[rsp], rcx
  00028	ba 01 00 00 00	 mov	 edx, 1
  0002d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR tv137[rsp]
  00035	ff 50 30	 call	 QWORD PTR [rax+48]
  00038	3b 44 24 48	 cmp	 eax, DWORD PTR c$[rsp]
  0003c	75 3a		 jne	 SHORT $LN2@matchc

; 773  : 	{
; 774  : 		/* Matched correctly, do consume it
; 775  : 		 */
; 776  : 		lexer->input->istream->consume(lexer->input->istream);

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00043	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0004c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00050	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00053	48 89 4c 24 28	 mov	 QWORD PTR tv134[rsp], rcx
  00058	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv134[rsp]
  00060	ff 50 28	 call	 QWORD PTR [rax+40]

; 777  : 
; 778  : 		/* Reset any failed indicator
; 779  : 		 */
; 780  : 		lexer->rec->state->failed = ANTLR3_FALSE;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00068	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00070	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 781  : 
; 782  : 		return	ANTLR3_TRUE;

  00074	b0 01		 mov	 al, 1
  00076	eb 4f		 jmp	 SHORT $LN1@matchc
$LN2@matchc:

; 783  : 	}
; 784  : 
; 785  : 	/* Failed to match, exception and recovery time.
; 786  : 	 */
; 787  : 	if	(lexer->rec->state->backtracking > 0)

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0007d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00081	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00085	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00089	7e 15		 jle	 SHORT $LN3@matchc

; 788  : 	{
; 789  : 		lexer->rec->state->failed  = ANTLR3_TRUE;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00090	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00094	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00098	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 790  : 		return	ANTLR3_FALSE;

  0009c	32 c0		 xor	 al, al
  0009e	eb 27		 jmp	 SHORT $LN1@matchc
$LN3@matchc:

; 791  : 	}
; 792  : 
; 793  : 	lexer->rec->exConstruct(lexer->rec);

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000a5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000ae	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000b2	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 794  : 
; 795  : 	/* TODO: Implement exception creation more fully perhaps
; 796  : 	 */
; 797  : 	lexer->recover(lexer);

  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000bd	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000c2	ff 50 70	 call	 QWORD PTR [rax+112]

; 798  : 
; 799  : 	return  ANTLR3_FALSE;

  000c5	32 c0		 xor	 al, al
$LN1@matchc:

; 800  : }

  000c7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cb	5f		 pop	 rdi
  000cc	c3		 ret	 0
matchc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT matchs
_TEXT	SEGMENT
tv144 = 32
tv134 = 40
lexer$ = 64
string$ = 72
matchs	PROC						; COMDAT

; 728  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
$LN2@matchs:

; 729  : 	while   (*string != ANTLR3_STRING_TERMINATOR)

  0000f	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  00014	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  00017	0f 84 e1 00 00
	00		 je	 $LN3@matchs

; 730  : 	{
; 731  : 		if  (lexer->input->istream->_LA(lexer->input->istream, 1) != (*string))

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00022	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0002b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	48 89 4c 24 20	 mov	 QWORD PTR tv144[rsp], rcx
  00037	ba 01 00 00 00	 mov	 edx, 1
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR tv144[rsp]
  00044	ff 50 30	 call	 QWORD PTR [rax+48]
  00047	48 8b 4c 24 48	 mov	 rcx, QWORD PTR string$[rsp]
  0004c	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0004e	74 65		 je	 SHORT $LN4@matchs

; 732  : 		{
; 733  : 			if	(lexer->rec->state->backtracking > 0)

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00055	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00059	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005d	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00061	7e 18		 jle	 SHORT $LN5@matchs

; 734  : 			{
; 735  : 				lexer->rec->state->failed = ANTLR3_TRUE;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00068	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00070	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 736  : 				return ANTLR3_FALSE;

  00074	32 c0		 xor	 al, al
  00076	e9 85 00 00 00	 jmp	 $LN1@matchs
$LN5@matchs:

; 737  : 			}
; 738  : 
; 739  : 			lexer->rec->exConstruct(lexer->rec);

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00080	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00089	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0008d	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]

; 740  : 			lexer->rec->state->failed	 = ANTLR3_TRUE;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00098	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a0	c6 40 30 01	 mov	 BYTE PTR [rax+48], 1

; 741  : 
; 742  : 			/* TODO: Implement exception creation more fully perhaps
; 743  : 			 */
; 744  : 			lexer->recover(lexer);

  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ae	ff 50 70	 call	 QWORD PTR [rax+112]

; 745  : 			return  ANTLR3_FALSE;

  000b1	32 c0		 xor	 al, al
  000b3	eb 4b		 jmp	 SHORT $LN1@matchs
$LN4@matchs:

; 746  : 		}
; 747  : 
; 748  : 		/* Matched correctly, do consume it
; 749  : 		 */
; 750  : 		lexer->input->istream->consume(lexer->input->istream);

  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ba	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000c3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ca	48 89 4c 24 28	 mov	 QWORD PTR tv134[rsp], rcx
  000cf	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR tv134[rsp]
  000d7	ff 50 28	 call	 QWORD PTR [rax+40]

; 751  : 		string++;

  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  000df	48 83 c0 04	 add	 rax, 4
  000e3	48 89 44 24 48	 mov	 QWORD PTR string$[rsp], rax

; 752  : 
; 753  : 		/* Reset any failed indicator
; 754  : 		 */
; 755  : 		lexer->rec->state->failed = ANTLR3_FALSE;

  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ed	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f5	c6 40 30 00	 mov	 BYTE PTR [rax+48], 0

; 756  : 	}

  000f9	e9 11 ff ff ff	 jmp	 $LN2@matchs
$LN3@matchs:

; 757  : 
; 758  : 
; 759  : 	return  ANTLR3_TRUE;

  000fe	b0 01		 mov	 al, 1
$LN1@matchs:

; 760  : }

  00100	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
matchs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT emit
_TEXT	SEGMENT
token$ = 32
tv187 = 40
lexer$ = 64
emit	PROC						; COMDAT

; 643  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 644  :     pANTLR3_COMMON_TOKEN	token;
; 645  : 
; 646  :     /* We could check pointers to token factories and so on, but
; 647  :     * we are in code that we want to run as fast as possible
; 648  :     * so we are not checking any errors. So make sure you have installed an input stream before
; 649  :     * trying to emit a new token.
; 650  :     */
; 651  :     token   = lexer->rec->state->tokFactory->newToken(lexer->rec->state->tokFactory);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  0001c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00020	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00024	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00028	48 89 4c 24 28	 mov	 QWORD PTR tv187[rsp], rcx
  0002d	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR tv187[rsp]
  00036	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  0003c	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 652  : 
; 653  :     /* Install the supplied information, and some other bits we already know
; 654  :     * get added automatically, such as the input stream it is associated with
; 655  :     * (though it can all be overridden of course)
; 656  :     */
; 657  :     token->type		    = lexer->rec->state->type;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00046	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00053	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00056	89 01		 mov	 DWORD PTR [rcx], eax

; 658  :     token->channel	    = lexer->rec->state->channel;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0005d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00061	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0006a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0006d	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 659  :     token->start	    = lexer->rec->state->tokenStartCharIndex;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00075	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00079	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00082	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00089	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 660  :     token->stop		    = lexer->getCharIndex(lexer) - 1;

  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00097	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0009d	48 ff c8	 dec	 rax
  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000a5	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 661  :     token->line		    = lexer->rec->state->tokenStartLine;

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000ae	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000b2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000bb	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  000be	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 662  :     token->charPosition	= lexer->rec->state->tokenStartCharPositionInLine;

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000c6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ca	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000d3	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  000d6	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 663  : 
; 664  :     if	(lexer->rec->state->text != NULL)

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000de	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000e2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e6	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  000ee	74 2b		 je	 SHORT $LN2@emit

; 665  :     {
; 666  :         token->textState	    = ANTLR3_TEXT_STRING;

  000f0	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  000f5	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 667  :         token->tokText.text	    = lexer->rec->state->text;

  000fc	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00101	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00105	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0010e	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00115	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 668  :     }

  00119	eb 0c		 jmp	 SHORT $LN3@emit
$LN2@emit:

; 669  :     else
; 670  :     {
; 671  :         token->textState	= ANTLR3_TEXT_NONE;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00120	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0
$LN3@emit:

; 672  :     }
; 673  :     token->lineStart	= lexer->input->currentLine;

  00127	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0012c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00130	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00135	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00139	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 674  :     token->user1	= lexer->rec->state->user1;

  0013d	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00142	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00146	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0014a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0014f	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00155	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 675  :     token->user2	= lexer->rec->state->user2;

  00158	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0015d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00161	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00165	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0016a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00170	89 41 5c	 mov	 DWORD PTR [rcx+92], eax

; 676  :     token->user3	= lexer->rec->state->user3;

  00173	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00178	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0017c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00180	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00185	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [rax+152]
  0018b	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 677  :     token->custom	= lexer->rec->state->custom;

  0018e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00193	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00197	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0019b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001a0	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001a7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 678  : 
; 679  :     lexer->rec->state->token	    = token;

  001ab	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  001b0	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001b4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001bd	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 680  : 
; 681  :     return  token;

  001c1	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]

; 682  : }

  001c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ca	5f		 pop	 rdi
  001cb	c3		 ret	 0
emit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT emitNew
_TEXT	SEGMENT
lexer$ = 16
token$ = 24
emitNew	PROC						; COMDAT

; 637  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 638  :     lexer->rec->state->token    = token;	/* Voila!   */

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR lexer$[rsp]
  00010	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 8b 4c 24 18	 mov	 rcx, QWORD PTR token$[rsp]
  0001d	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 639  : }

  00021	5f		 pop	 rdi
  00022	c3		 ret	 0
emitNew	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT popCharStream
_TEXT	SEGMENT
input$ = 32
tv142 = 40
tv134 = 48
tv131 = 56
lexer$ = 80
popCharStream PROC					; COMDAT

; 611  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 612  :     pANTLR3_INPUT_STREAM input;
; 613  : 
; 614  :     // If we do not have a stream stack or we are already at the
; 615  :     // stack bottom, then do nothing.
; 616  :     //
; 617  :     if	(lexer->rec->state->streams != NULL && lexer->rec->state->streams->size(lexer->rec->state->streams) > 0)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0000f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  0001f	0f 84 c7 00 00
	00		 je	 $LN2@popCharStr
  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  0002a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  00037	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0003b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003f	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  00046	48 89 4c 24 28	 mov	 QWORD PTR tv142[rsp], rcx
  0004b	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR tv142[rsp]
  00057	ff 50 30	 call	 QWORD PTR [rax+48]
  0005a	85 c0		 test	 eax, eax
  0005c	0f 86 8a 00 00
	00		 jbe	 $LN2@popCharStr

; 618  :     {
; 619  : 	// We just leave the current stream to its fate, we do not close
; 620  : 	// it or anything as we do not know what the programmer intended
; 621  : 	// for it. This method can always be overridden of course.
; 622  : 	// So just find out what was currently saved on the stack and use
; 623  : 	// that now, then pop it from the stack.
; 624  : 	//
; 625  : 	input	= (pANTLR3_INPUT_STREAM)(lexer->rec->state->streams->top);

  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00067	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006f	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  00076	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007a	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 626  : 	lexer->rec->state->streams->pop(lexer->rec->state->streams);

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  00084	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  00091	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00095	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00099	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  000a0	48 89 4c 24 30	 mov	 QWORD PTR tv134[rsp], rcx
  000a5	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR tv134[rsp]
  000b1	ff 50 18	 call	 QWORD PTR [rax+24]

; 627  : 
; 628  : 	// Now install the stream as the current one.
; 629  : 	//
; 630  : 	lexer->setCharStream(lexer, input);

  000b4	48 8b 54 24 20	 mov	 rdx, QWORD PTR input$[rsp]
  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000c3	ff 50 20	 call	 QWORD PTR [rax+32]

; 631  : 	lexer->input->istream->rewindLast(lexer->input->istream);

  000c6	48 8b 44 24 50	 mov	 rax, QWORD PTR lexer$[rsp]
  000cb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lexer$[rsp]
  000d4	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000d8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000db	48 89 4c 24 38	 mov	 QWORD PTR tv131[rsp], rcx
  000e0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR tv131[rsp]
  000e8	ff 50 50	 call	 QWORD PTR [rax+80]
  000eb	90		 npad	 1
$LN2@popCharStr:

; 632  :     }
; 633  :     return;
; 634  : }

  000ec	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
popCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT pushCharStream
_TEXT	SEGMENT
tv134 = 32
tv129 = 40
lexer$ = 64
input$ = 72
pushCharStream PROC					; COMDAT

; 565  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 566  : 	// Do we need a new input stream stack?
; 567  : 	//
; 568  : 	if	(lexer->rec->state->streams == NULL)

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00014	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00018	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001c	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00024	75 34		 jne	 SHORT $LN2@pushCharSt

; 569  : 	{
; 570  : 		// This is the first call to stack a new
; 571  : 		// stream and so we must create the stack first.
; 572  : 		//
; 573  : 		lexer->rec->state->streams = antlr3StackNew(0);

  00026	33 c9		 xor	 ecx, ecx
  00028	e8 00 00 00 00	 call	 antlr3StackNew
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00032	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00036	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0003a	48 89 81 a8 00
	00 00		 mov	 QWORD PTR [rcx+168], rax

; 574  : 
; 575  : 		if  (lexer->rec->state->streams == NULL)

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00046	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  00056	75 02		 jne	 SHORT $LN3@pushCharSt

; 576  : 		{
; 577  : 			// Could not do this, we just fail to push it.
; 578  : 			// TODO: Consider if this is what we want to do, but then
; 579  : 			//       any programmer can override this method to do something else.
; 580  : 			return;

  00058	eb 79		 jmp	 SHORT $LN1@pushCharSt
$LN3@pushCharSt:
$LN2@pushCharSt:

; 581  : 		}
; 582  : 	}
; 583  : 
; 584  : 	// We have a stack, so we can save the current input stream
; 585  : 	// into it.
; 586  : 	//
; 587  : 	lexer->input->istream->mark(lexer->input->istream);

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0005f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00068	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0006c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006f	48 89 4c 24 20	 mov	 QWORD PTR tv134[rsp], rcx
  00074	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR tv134[rsp]
  0007c	ff 50 38	 call	 QWORD PTR [rax+56]

; 588  : 	lexer->rec->state->streams->push(lexer->rec->state->streams, lexer->input, NULL);

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00084	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00088	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00091	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00095	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00099	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  000a0	48 89 4c 24 28	 mov	 QWORD PTR tv129[rsp], rcx
  000a5	45 33 c0	 xor	 r8d, r8d
  000a8	48 8b 54 24 40	 mov	 rdx, QWORD PTR lexer$[rsp]
  000ad	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000b1	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR tv129[rsp]
  000bd	ff 50 28	 call	 QWORD PTR [rax+40]

; 589  : 
; 590  : 	// And now we can install this new one
; 591  : 	//
; 592  : 	lexer->setCharStream(lexer, input);

  000c0	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  000ca	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000cf	ff 50 20	 call	 QWORD PTR [rax+32]
  000d2	90		 npad	 1
$LN1@pushCharSt:

; 593  : }

  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
pushCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT setCharStream
_TEXT	SEGMENT
tv173 = 32
lexer$ = 64
input$ = 72
setCharStream PROC					; COMDAT

; 493  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 494  :     /* Install the input interface
; 495  :      */
; 496  :     lexer->input	= input;

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00014	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00019	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 497  : 
; 498  :     /* We may need a token factory for the lexer; we don't destroy any existing factory
; 499  :      * until the lexer is destroyed, as people may still be using the tokens it produced.
; 500  :      * TODO: Later I will provide a dup() method for a token so that it can extract itself
; 501  :      * out of the factory. 
; 502  :      */
; 503  :     if	(lexer->rec->state->tokFactory == NULL)

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00022	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00026	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0002f	75 1d		 jne	 SHORT $LN2@setCharStr

; 504  :     {
; 505  : 	lexer->rec->state->tokFactory	= antlr3TokenFactoryNew(input);

  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00036	e8 00 00 00 00	 call	 antlr3TokenFactoryNew
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00040	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00044	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00048	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 506  :     }

  0004c	eb 38		 jmp	 SHORT $LN3@setCharStr
$LN2@setCharStr:

; 507  :     else
; 508  :     {
; 509  : 	/* When the input stream is being changed on the fly, rather than
; 510  : 	 * at the start of a new lexer, then we must tell the tokenFactory
; 511  : 	 * which input stream to adorn the tokens with so that when they
; 512  : 	 * are asked to provide their original input strings they can
; 513  : 	 * do so from the correct text stream.
; 514  : 	 */
; 515  : 	lexer->rec->state->tokFactory->setInputStream(lexer->rec->state->tokFactory, input);

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00053	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00057	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lexer$[rsp]
  00060	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00064	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00068	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0006c	48 89 4c 24 20	 mov	 QWORD PTR tv173[rsp], rcx
  00071	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00076	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR tv173[rsp]
  0007f	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  00085	90		 npad	 1
$LN3@setCharStr:

; 516  :     }
; 517  : 
; 518  :     /* Propagate the string factory so that we preserve the encoding form from
; 519  :      * the input stream.
; 520  :      */
; 521  :     if	(lexer->rec->state->tokSource->strFactory == NULL)

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0008b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00093	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00097	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0009c	75 54		 jne	 SHORT $LN4@setCharStr

; 522  :     {
; 523  :         lexer->rec->state->tokSource->strFactory	= input->strFactory;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000a3	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ab	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000b4	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000b8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 524  : 
; 525  :         // Set the newly acquired string factory up for our pre-made tokens
; 526  :         // for EOF.
; 527  :         //
; 528  :         if (lexer->rec->state->tokSource->eofToken.strFactory == NULL)

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000c1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cd	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000d2	75 1e		 jne	 SHORT $LN5@setCharStr

; 529  :         {
; 530  :             lexer->rec->state->tokSource->eofToken.strFactory = input->strFactory;

  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000d9	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000dd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000ea	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ee	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN5@setCharStr:
$LN4@setCharStr:

; 531  :         }
; 532  :     }
; 533  : 
; 534  :     /* This is a lexer, install the appropriate exception creator
; 535  :      */
; 536  :     lexer->rec->exConstruct = antlr3RecognitionExceptionNew;

  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  000f7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3RecognitionExceptionNew
  00102	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 537  : 
; 538  :     /* Set the current token to nothing
; 539  :      */
; 540  :     lexer->rec->state->token		= NULL;

  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0010e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00112	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00116	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 541  :     lexer->rec->state->text			= NULL;

  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00123	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00127	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0012b	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 542  :     lexer->rec->state->tokenStartCharIndex	= -1;

  00136	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  0013b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0013f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00143	48 c7 80 80 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+128], -1

; 543  : 
; 544  :     /* Copy the name of the char stream to the token source
; 545  :      */
; 546  :     lexer->rec->state->tokSource->fileName = input->fileName;

  0014e	48 8b 44 24 40	 mov	 rax, QWORD PTR lexer$[rsp]
  00153	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00157	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0015b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00164	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00168	48 89 88 28 02
	00 00		 mov	 QWORD PTR [rax+552], rcx

; 547  : }

  0016f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00173	5f		 pop	 rdi
  00174	c3		 ret	 0
setCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT mTokens
_TEXT	SEGMENT
lexer$ = 48
mTokens	PROC						; COMDAT

; 403  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 404  :     if	(lexer)	    // Fool compiler, avoid pragmas

  0000a	48 83 7c 24 30
	00		 cmp	 QWORD PTR lexer$[rsp], 0
  00010	74 1b		 je	 SHORT $LN2@mTokens

; 405  :     {
; 406  : 		ANTLR3_FPRINTF(stderr, "lexer->mTokens(): Error: No lexer rules were added to the lexer yet!\n");

  00012	b9 02 00 00 00	 mov	 ecx, 2
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fprintf
  0002c	90		 npad	 1
$LN2@mTokens:

; 407  :     }
; 408  : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
mTokens	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT antlr3LexerNew
_TEXT	SEGMENT
lexer$ = 32
specialT$ = 40
sizeHint$ = 64
state$ = 72
antlr3LexerNew PROC					; COMDAT

; 73   : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 74   :     pANTLR3_LEXER   lexer;
; 75   :     pANTLR3_COMMON_TOKEN	specialT;
; 76   : 
; 77   : 	/* Allocate memory
; 78   : 	*/
; 79   : 	lexer   = (pANTLR3_LEXER) ANTLR3_MALLOC(sizeof(ANTLR3_LEXER));

  0000e	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00019	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 80   : 
; 81   : 	if	(lexer == NULL)

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR lexer$[rsp], 0
  00024	75 07		 jne	 SHORT $LN2@antlr3Lexe

; 82   : 	{
; 83   : 		return	NULL;

  00026	33 c0		 xor	 eax, eax
  00028	e9 cb 03 00 00	 jmp	 $LN1@antlr3Lexe
$LN2@antlr3Lexe:

; 84   : 	}
; 85   : 
; 86   : 	/* Now we need to create the base recognizer
; 87   : 	*/
; 88   : 	lexer->rec	    =  antlr3BaseRecognizerNew(ANTLR3_TYPE_LEXER, sizeHint, state);

  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR state$[rsp]
  00032	8b 54 24 40	 mov	 edx, DWORD PTR sizeHint$[rsp]
  00036	b9 01 00 00 00	 mov	 ecx, 1
  0003b	e8 00 00 00 00	 call	 antlr3BaseRecognizerNew
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00045	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 89   : 
; 90   : 	if	(lexer->rec == NULL)

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0004e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00053	75 17		 jne	 SHORT $LN3@antlr3Lexe

; 91   : 	{
; 92   : 		lexer->free(lexer);

  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0005f	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 93   : 		return	NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 8c 03 00 00	 jmp	 $LN1@antlr3Lexe
$LN3@antlr3Lexe:

; 94   : 	}
; 95   : 	lexer->rec->super  =  lexer;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00071	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0007a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 96   : 
; 97   : 	lexer->rec->displayRecognitionError	    = displayRecognitionError;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00082	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:displayRecognitionError
  0008d	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 98   : 	lexer->rec->reportError					= reportError;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00096	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reportError
  000a1	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 99   : 	lexer->rec->reset						= reset;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000aa	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:reset
  000b5	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 100  : 	lexer->rec->getCurrentInputSymbol		= getCurrentInputSymbol;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000c1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCurrentInputSymbol
  000cc	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 101  : 	lexer->rec->getMissingSymbol			= getMissingSymbol;

  000d3	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000d8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getMissingSymbol
  000e3	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 102  : 
; 103  : 	/* Now install the token source interface
; 104  : 	*/
; 105  : 	if	(lexer->rec->state->tokSource == NULL) 

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  000ef	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f7	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000fc	0f 85 ca 00 00
	00		 jne	 $LN4@antlr3Lexe

; 106  : 	{
; 107  : 		lexer->rec->state->tokSource	= (pANTLR3_TOKEN_SOURCE)ANTLR3_CALLOC(1, sizeof(ANTLR3_TOKEN_SOURCE));

  00102	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  00107	b9 01 00 00 00	 mov	 ecx, 1
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00112	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00117	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0011b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0011f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 108  : 
; 109  : 		if	(lexer->rec->state->tokSource == NULL) 

  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00128	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0012c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00130	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00135	75 2f		 jne	 SHORT $LN5@antlr3Lexe

; 110  : 		{
; 111  : 			lexer->rec->free(lexer->rec);

  00137	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0013c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00140	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00145	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00149	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 112  : 			lexer->free(lexer);

  0014f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00159	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 113  : 
; 114  : 			return	NULL;

  0015f	33 c0		 xor	 eax, eax
  00161	e9 92 02 00 00	 jmp	 $LN1@antlr3Lexe
$LN5@antlr3Lexe:

; 115  : 		}
; 116  : 		lexer->rec->state->tokSource->super    =  lexer;

  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  0016b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0016f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00173	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00177	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  0017c	48 89 88 20 02
	00 00		 mov	 QWORD PTR [rax+544], rcx

; 117  : 
; 118  : 		/* Install the default nextToken() method, which may be overridden
; 119  : 		 * by generated code, or by anything else in fact.
; 120  : 		 */
; 121  : 		lexer->rec->state->tokSource->nextToken	    =  nextToken;

  00183	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00188	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0018c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00190	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nextToken
  0019b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 122  : 		lexer->rec->state->tokSource->strFactory    = NULL;

  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001a3	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001a7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001ab	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001af	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 123  : 
; 124  : 		lexer->rec->state->tokFactory				= NULL;

  001b7	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001bc	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001c0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001c4	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN4@antlr3Lexe:

; 125  : 	}
; 126  : 
; 127  :     /* Install the lexer API
; 128  :      */
; 129  :     lexer->setCharStream			=  setCharStream;

  001cc	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setCharStream
  001d8	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 130  :     lexer->mTokens					= (void (*)(void *))(mTokens);

  001dc	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mTokens
  001e8	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 131  :     lexer->setCharStream			=  setCharStream;

  001ec	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setCharStream
  001f8	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 132  :     lexer->pushCharStream			=  pushCharStream;

  001fc	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pushCharStream
  00208	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 133  :     lexer->popCharStream			=  popCharStream;

  0020c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:popCharStream
  00218	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 134  :     lexer->emit						=  emit;

  0021c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:emit
  00228	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 135  :     lexer->emitNew					=  emitNew;

  0022c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:emitNew
  00238	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 136  :     lexer->matchs					=  matchs;

  0023c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchs
  00248	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 137  :     lexer->matchc					=  matchc;

  0024c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchc
  00258	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 138  :     lexer->matchRange				=  matchRange;

  0025c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchRange
  00268	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 139  :     lexer->matchAny					=  matchAny;

  0026c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:matchAny
  00278	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 140  :     lexer->recover					=  recover;

  0027c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recover
  00288	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 141  :     lexer->getLine					=  getLine;

  0028c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  00298	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 142  :     lexer->getCharIndex				=  getCharIndex;

  0029c	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharIndex
  002a8	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 143  :     lexer->getCharPositionInLine    =  getCharPositionInLine;

  002af	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  002bb	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 144  :     lexer->getText					=  getText;

  002c2	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  002ce	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 145  :     lexer->free						=  freeLexer;

  002d5	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeLexer
  002e1	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 146  :     
; 147  :     /* Initialise the eof token
; 148  :      */
; 149  :     specialT					= &(lexer->rec->state->tokSource->eofToken);

  002e8	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  002ed	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  002f1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002f5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002f9	48 83 c0 10	 add	 rax, 16
  002fd	48 89 44 24 28	 mov	 QWORD PTR specialT$[rsp], rax

; 150  :     antlr3SetTokenAPI	  (specialT);

  00302	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  00307	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 151  :     specialT->setType	  (specialT, ANTLR3_TOKEN_EOF);

  0030c	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00311	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  00316	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0031b	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 152  :     specialT->factoryMade		= ANTLR3_TRUE;					// Prevent things trying to free() it

  00321	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00326	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 153  :     specialT->strFactory        = NULL;

  0032a	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0032f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 154  : 	specialT->textState			= ANTLR3_TEXT_NONE;

  00337	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0033c	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 155  : 	specialT->custom			= NULL;

  00343	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00348	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 156  : 	specialT->user1				= 0;

  00350	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00355	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 157  : 	specialT->user2				= 0;

  0035c	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  00361	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 158  : 	specialT->user3				= 0;

  00368	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  0036d	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 159  : 
; 160  : 	// Initialize the skip token.
; 161  : 	//
; 162  :     specialT					= &(lexer->rec->state->tokSource->skipToken);

  00374	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
  00379	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0037d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00381	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00385	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  0038b	48 89 44 24 28	 mov	 QWORD PTR specialT$[rsp], rax

; 163  :     antlr3SetTokenAPI	  (specialT);

  00390	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  00395	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 164  :     specialT->setType	  (specialT, ANTLR3_TOKEN_INVALID);

  0039a	33 d2		 xor	 edx, edx
  0039c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR specialT$[rsp]
  003a1	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003a6	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 165  :     specialT->factoryMade		= ANTLR3_TRUE;					// Prevent things trying to free() it

  003ac	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003b1	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 166  :     specialT->strFactory        = NULL;

  003b5	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003ba	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 167  : 	specialT->custom			= NULL;

  003c2	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003c7	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 168  : 	specialT->user1				= 0;

  003cf	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003d4	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 169  : 	specialT->user2				= 0;

  003db	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003e0	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 170  : 	specialT->user3				= 0;

  003e7	48 8b 44 24 28	 mov	 rax, QWORD PTR specialT$[rsp]
  003ec	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [rax+96], 0

; 171  :     return  lexer;

  003f3	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]
$LN1@antlr3Lexe:

; 172  : }

  003f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003fc	5f		 pop	 rdi
  003fd	c3		 ret	 0
antlr3LexerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3lexer.c
;	COMDAT antlr3LexerNewStream
_TEXT	SEGMENT
lexer$ = 32
sizeHint$ = 64
input$ = 72
state$ = 80
antlr3LexerNewStream PROC				; COMDAT

; 385  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 386  :     pANTLR3_LEXER   lexer;
; 387  : 
; 388  :     // Create a basic lexer first
; 389  :     //
; 390  :     lexer   = antlr3LexerNew(sizeHint, state);

  00013	48 8b 54 24 50	 mov	 rdx, QWORD PTR state$[rsp]
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  0001c	e8 00 00 00 00	 call	 antlr3LexerNew
  00021	48 89 44 24 20	 mov	 QWORD PTR lexer$[rsp], rax

; 391  : 
; 392  :     if	(lexer != NULL) 

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR lexer$[rsp], 0
  0002c	74 10		 je	 SHORT $LN2@antlr3Lexe

; 393  :     {
; 394  : 		// Install the input stream and reset the lexer
; 395  : 		//
; 396  : 		setCharStream(lexer, input);

  0002e	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00033	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lexer$[rsp]
  00038	e8 00 00 00 00	 call	 setCharStream
  0003d	90		 npad	 1
$LN2@antlr3Lexe:

; 397  :     }
; 398  : 
; 399  :     return  lexer;

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR lexer$[rsp]

; 400  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
antlr3LexerNewStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  0004b	e8 00 00 00 00	 call	 _vfprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 842  :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 843  :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 844  :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
