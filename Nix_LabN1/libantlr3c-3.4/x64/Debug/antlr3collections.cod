; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33139.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3IntTrieNew
PUBLIC	antlr3HashTableNew
PUBLIC	antlr3Hash
PUBLIC	antlr3EnumNew
PUBLIC	antlr3ListNew
PUBLIC	antlr3VectorFactoryNew
PUBLIC	antlr3VectorNew
PUBLIC	antlr3StackNew
PUBLIC	antlr3SetVectorApi
PUBLIC	antlr3TopoNew
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	antlr3BitsetNew:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3IntTrieNew DD imagerel $LN5
	DD	imagerel $LN5+245
	DD	imagerel $unwind$antlr3IntTrieNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashTableNew DD imagerel $LN8
	DD	imagerel $LN8+364
	DD	imagerel $unwind$antlr3HashTableNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3Hash DD imagerel $LN6
	DD	imagerel $LN6+141
	DD	imagerel $unwind$antlr3Hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumNew DD imagerel $LN5
	DD	imagerel $LN5+155
	DD	imagerel $unwind$antlr3EnumNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListNew DD imagerel $LN5
	DD	imagerel $LN5+201
	DD	imagerel $unwind$antlr3ListNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorFactoryNew DD imagerel $LN4
	DD	imagerel $LN4+198
	DD	imagerel $unwind$antlr3VectorFactoryNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorNew DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$antlr3VectorNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackNew DD imagerel $LN5
	DD	imagerel $LN5+198
	DD	imagerel $unwind$antlr3StackNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3SetVectorApi DD imagerel $LN8
	DD	imagerel $LN8+333
	DD	imagerel $unwind$antlr3SetVectorApi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3TopoNew DD imagerel $LN4
	DD	imagerel $LN4+196
	DD	imagerel $unwind$antlr3TopoNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashDelete DD imagerel antlr3HashDelete
	DD	imagerel antlr3HashDelete+102
	DD	imagerel $unwind$antlr3HashDelete
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashGet DD imagerel antlr3HashGet
	DD	imagerel antlr3HashGet+156
	DD	imagerel $unwind$antlr3HashGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashRemove DD imagerel antlr3HashRemove
	DD	imagerel antlr3HashRemove+262
	DD	imagerel $unwind$antlr3HashRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashPut DD imagerel antlr3HashPut
	DD	imagerel antlr3HashPut+345
	DD	imagerel $unwind$antlr3HashPut
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashDeleteI DD imagerel antlr3HashDeleteI
	DD	imagerel antlr3HashDeleteI+102
	DD	imagerel $unwind$antlr3HashDeleteI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashGetI DD imagerel antlr3HashGetI
	DD	imagerel antlr3HashGetI+142
	DD	imagerel $unwind$antlr3HashGetI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashRemoveI DD imagerel antlr3HashRemoveI
	DD	imagerel antlr3HashRemoveI+199
	DD	imagerel $unwind$antlr3HashRemoveI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashPutI DD imagerel antlr3HashPutI
	DD	imagerel antlr3HashPutI+294
	DD	imagerel $unwind$antlr3HashPutI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashFree DD imagerel antlr3HashFree
	DD	imagerel antlr3HashFree+270
	DD	imagerel $unwind$antlr3HashFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3HashSize DD imagerel antlr3HashSize
	DD	imagerel antlr3HashSize+16
	DD	imagerel $unwind$antlr3HashSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumNext DD imagerel antlr3EnumNext
	DD	imagerel antlr3EnumNext+104
	DD	imagerel $unwind$antlr3EnumNext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumFree DD imagerel antlr3EnumFree
	DD	imagerel antlr3EnumFree+27
	DD	imagerel $unwind$antlr3EnumFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListFree DD imagerel antlr3ListFree
	DD	imagerel antlr3ListFree+46
	DD	imagerel $unwind$antlr3ListFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListDelete DD imagerel antlr3ListDelete
	DD	imagerel antlr3ListDelete+45
	DD	imagerel $unwind$antlr3ListDelete
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListGet DD imagerel antlr3ListGet
	DD	imagerel antlr3ListGet+45
	DD	imagerel $unwind$antlr3ListGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListPut DD imagerel antlr3ListPut
	DD	imagerel antlr3ListPut+65
	DD	imagerel $unwind$antlr3ListPut
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListAdd DD imagerel antlr3ListAdd
	DD	imagerel antlr3ListAdd+82
	DD	imagerel $unwind$antlr3ListAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListRemove DD imagerel antlr3ListRemove
	DD	imagerel antlr3ListRemove+73
	DD	imagerel $unwind$antlr3ListRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3ListSize DD imagerel antlr3ListSize
	DD	imagerel antlr3ListSize+35
	DD	imagerel $unwind$antlr3ListSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackFree DD imagerel antlr3StackFree
	DD	imagerel antlr3StackFree+74
	DD	imagerel $unwind$antlr3StackFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackPop DD imagerel antlr3StackPop
	DD	imagerel antlr3StackPop+128
	DD	imagerel $unwind$antlr3StackPop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackGet DD imagerel antlr3StackGet
	DD	imagerel antlr3StackGet+47
	DD	imagerel $unwind$antlr3StackGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackPush DD imagerel antlr3StackPush
	DD	imagerel antlr3StackPush+72
	DD	imagerel $unwind$antlr3StackPush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackSize DD imagerel antlr3StackSize
	DD	imagerel antlr3StackSize+19
	DD	imagerel $unwind$antlr3StackSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StackPeek DD imagerel antlr3StackPeek
	DD	imagerel antlr3StackPeek+17
	DD	imagerel $unwind$antlr3StackPeek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorFree DD imagerel antlr3VectorFree
	DD	imagerel antlr3VectorFree+236
	DD	imagerel $unwind$antlr3VectorFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorDel DD imagerel antlr3VectorDel
	DD	imagerel antlr3VectorDel+272
	DD	imagerel $unwind$antlr3VectorDel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorGet DD imagerel antlr3VectorGet
	DD	imagerel antlr3VectorGet+52
	DD	imagerel $unwind$antlr3VectorGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antrl3VectorRemove DD imagerel antrl3VectorRemove
	DD	imagerel antrl3VectorRemove+239
	DD	imagerel $unwind$antrl3VectorRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorClear DD imagerel antlr3VectorClear
	DD	imagerel antlr3VectorClear+181
	DD	imagerel $unwind$antlr3VectorClear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorAdd DD imagerel antlr3VectorAdd
	DD	imagerel antlr3VectorAdd+144
	DD	imagerel $unwind$antlr3VectorAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorSet DD imagerel antlr3VectorSet
	DD	imagerel antlr3VectorSet+232
	DD	imagerel $unwind$antlr3VectorSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorSize DD imagerel antlr3VectorSize
	DD	imagerel antlr3VectorSize+16
	DD	imagerel $unwind$antlr3VectorSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorSwap DD imagerel antlr3VectorSwap
	DD	imagerel antlr3VectorSwap+250
	DD	imagerel $unwind$antlr3VectorSwap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPool DD imagerel newPool
	DD	imagerel newPool+120
	DD	imagerel $unwind$newPool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closeVectorFactory DD imagerel closeVectorFactory
	DD	imagerel closeVectorFactory+550
	DD	imagerel $unwind$closeVectorFactory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newVector DD imagerel newVector
	DD	imagerel newVector+228
	DD	imagerel $unwind$newVector
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$returnVector DD imagerel returnVector
	DD	imagerel returnVector+72
	DD	imagerel $unwind$returnVector
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieGet DD imagerel intTrieGet
	DD	imagerel intTrieGet+185
	DD	imagerel $unwind$intTrieGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieDel DD imagerel intTrieDel
	DD	imagerel intTrieDel+45
	DD	imagerel $unwind$intTrieDel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieAdd DD imagerel intTrieAdd
	DD	imagerel intTrieAdd+1414
	DD	imagerel $unwind$intTrieAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$intTrieFree DD imagerel intTrieFree
	DD	imagerel intTrieFree+40
	DD	imagerel $unwind$intTrieFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addEdge DD imagerel addEdge
	DD	imagerel addEdge+371
	DD	imagerel $unwind$addEdge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortToArray DD imagerel sortToArray
	DD	imagerel sortToArray+249
	DD	imagerel $unwind$sortToArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortVector DD imagerel sortVector
	DD	imagerel sortVector+358
	DD	imagerel $unwind$sortVector
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeTopo DD imagerel freeTopo
	DD	imagerel freeTopo+255
	DD	imagerel $unwind$freeTopo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EnumNextEntry DD imagerel antlr3EnumNextEntry
	DD	imagerel antlr3EnumNextEntry+183
	DD	imagerel $unwind$antlr3EnumNextEntry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3VectorResize DD imagerel antlr3VectorResize
	DD	imagerel antlr3VectorResize+193
	DD	imagerel $unwind$antlr3VectorResize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$freeIntNode DD imagerel freeIntNode
	DD	imagerel freeIntNode+193
	DD	imagerel $unwind$freeIntNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DFS DD	imagerel DFS
	DD	imagerel DFS+548
	DD	imagerel $unwind$DFS
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
_DATA	SEGMENT
bitIndex DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
bitMask	DQ	0000000000000001H
	DQ	0000000000000002H
	DQ	0000000000000004H
	DQ	0000000000000008H
	DQ	0000000000000010H
	DQ	0000000000000020H
	DQ	0000000000000040H
	DQ	0000000000000080H
	DQ	0000000000000100H
	DQ	0000000000000200H
	DQ	0000000000000400H
	DQ	0000000000000800H
	DQ	0000000000001000H
	DQ	0000000000002000H
	DQ	0000000000004000H
	DQ	0000000000008000H
	DQ	0000000000010000H
	DQ	0000000000020000H
	DQ	0000000000040000H
	DQ	0000000000080000H
	DQ	0000000000100000H
	DQ	0000000000200000H
	DQ	0000000000400000H
	DQ	0000000000800000H
	DQ	0000000001000000H
	DQ	0000000002000000H
	DQ	0000000004000000H
	DQ	0000000008000000H
	DQ	0000000010000000H
	DQ	0000000020000000H
	DQ	0000000040000000H
	DQ	0000000080000000H
	DQ	0000000100000000H
	DQ	0000000200000000H
	DQ	0000000400000000H
	DQ	0000000800000000H
	DQ	0000001000000000H
	DQ	0000002000000000H
	DQ	0000004000000000H
	DQ	0000008000000000H
	DQ	0000010000000000H
	DQ	0000020000000000H
	DQ	0000040000000000H
	DQ	0000080000000000H
	DQ	0000100000000000H
	DQ	0000200000000000H
	DQ	0000400000000000H
	DQ	0000800000000000H
	DQ	0001000000000000H
	DQ	0002000000000000H
	DQ	0004000000000000H
	DQ	0008000000000000H
	DQ	0010000000000000H
	DQ	0020000000000000H
	DQ	0040000000000000H
	DQ	0080000000000000H
	DQ	0100000000000000H
	DQ	0200000000000000H
	DQ	0400000000000000H
	DQ	0800000000000000H
	DQ	1000000000000000H
	DQ	2000000000000000H
	DQ	4000000000000000H
	DQ	8000000000000000H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DFS DD	020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeIntNode DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorResize DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumNextEntry DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$freeTopo DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortVector DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortToArray DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addEdge DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieFree DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieAdd DD 021901H
	DD	07015b219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieDel DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$intTrieGet DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$returnVector DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newVector DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closeVectorFactory DD 020a01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPool DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorSwap DD 021301H
	DD	0700f1213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorSet DD 021801H
	DD	070143218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorAdd DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorClear DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antrl3VectorRemove DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorGet DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorDel DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorFree DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackPeek DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackPush DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackGet DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackPop DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackFree DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListSize DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListRemove DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListAdd DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListPut DD 021901H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListGet DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListDelete DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListFree DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumFree DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumNext DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashFree DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashPutI DD 021901H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashRemoveI DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashGetI DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashDeleteI DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashPut DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashRemove DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashGet DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashDelete DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3TopoNew DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3SetVectorApi DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StackNew DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorNew DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3VectorFactoryNew DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3ListNew DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EnumNew DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3Hash DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3HashTableNew DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3IntTrieNew DD 020901H
	DD	070055209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT DFS
_TEXT	SEGMENT
edges$ = 32
i$1 = 40
l$2 = 44
numBits$3 = 48
i$4 = 52
range$5 = 56
topo$ = 80
node$ = 88
DFS	PROC						; COMDAT

; 2416 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2417 :     pANTLR3_BITSET edges;
; 2418 : 
; 2419 :     // Guard against a revisit and check for cycles
; 2420 :     //
; 2421 :     if  (topo->hasCycle == ANTLR3_TRUE)

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00013	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00017	83 f8 01	 cmp	 eax, 1
  0001a	75 05		 jne	 SHORT $LN11@DFS

; 2422 :     {
; 2423 :         return; // We don't do anything else if we found a cycle

  0001c	e9 fd 01 00 00	 jmp	 $LN1@DFS
$LN11@DFS:

; 2424 :     }
; 2425 : 
; 2426 :     if  (topo->visited->isMember(topo->visited, node))

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00026	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002a	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00033	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00037	ff 50 48	 call	 QWORD PTR [rax+72]
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 b7 00 00
	00		 je	 $LN12@DFS

; 2427 :     {
; 2428 :         // Check to see if we found a cycle. To do this we search the
; 2429 :         // current cycle stack and see if we find this node already in the stack.
; 2430 :         //
; 2431 :         ANTLR3_UINT32   i;
; 2432 : 
; 2433 :         for (i=0; i<topo->cycleMark; i++)

  00045	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0004d	eb 0a		 jmp	 SHORT $LN4@DFS
$LN2@DFS:
  0004f	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00053	ff c0		 inc	 eax
  00055	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
$LN4@DFS:
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0005e	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00061	39 44 24 28	 cmp	 DWORD PTR i$1[rsp], eax
  00065	0f 83 8c 00 00
	00		 jae	 $LN3@DFS

; 2434 :         {
; 2435 :             if  (topo->cycle[i] == node)

  0006b	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00074	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00078	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  0007c	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  0007f	75 71		 jne	 SHORT $LN13@DFS

; 2436 :             {
; 2437 :                 // Stop! We found a cycle in the input, so rejig the cycle
; 2438 :                 // stack so that it only contains the cycle and set the cycle flag
; 2439 :                 // which will tell the caller what happened
; 2440 :                 //
; 2441 :                 ANTLR3_UINT32 l;
; 2442 : 
; 2443 :                 for (l = i; l < topo->cycleMark; l++)

  00081	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00085	89 44 24 2c	 mov	 DWORD PTR l$2[rsp], eax
  00089	eb 0a		 jmp	 SHORT $LN7@DFS
$LN5@DFS:
  0008b	8b 44 24 2c	 mov	 eax, DWORD PTR l$2[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 44 24 2c	 mov	 DWORD PTR l$2[rsp], eax
$LN7@DFS:
  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0009a	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0009d	39 44 24 2c	 cmp	 DWORD PTR l$2[rsp], eax
  000a1	73 30		 jae	 SHORT $LN6@DFS

; 2444 :                 {
; 2445 :                     topo->cycle[l - i] = topo->cycle[l];    // Move to zero base in the cycle list

  000a3	8b 44 24 2c	 mov	 eax, DWORD PTR l$2[rsp]
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000ac	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b0	8b 54 24 28	 mov	 edx, DWORD PTR i$1[rsp]
  000b4	44 8b 44 24 2c	 mov	 r8d, DWORD PTR l$2[rsp]
  000b9	44 2b c2	 sub	 r8d, edx
  000bc	41 8b d0	 mov	 edx, r8d
  000bf	8b d2		 mov	 edx, edx
  000c1	4c 8b 44 24 50	 mov	 r8, QWORD PTR topo$[rsp]
  000c6	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  000ca	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000cd	41 89 04 90	 mov	 DWORD PTR [r8+rdx*4], eax

; 2446 :                 }

  000d1	eb b8		 jmp	 SHORT $LN5@DFS
$LN6@DFS:

; 2447 : 
; 2448 :                 // Recalculate the limit
; 2449 :                 //
; 2450 :                 topo->cycleMark -= i;

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000d8	8b 4c 24 28	 mov	 ecx, DWORD PTR i$1[rsp]
  000dc	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000df	2b c1		 sub	 eax, ecx
  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000e6	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 2451 : 
; 2452 :                 // Signal disaster
; 2453 :                 //
; 2454 :                 topo->hasCycle = ANTLR3_TRUE;

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000ee	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
$LN13@DFS:

; 2455 :             }
; 2456 :         }

  000f2	e9 58 ff ff ff	 jmp	 $LN2@DFS
$LN3@DFS:

; 2457 :         return;

  000f7	e9 22 01 00 00	 jmp	 $LN1@DFS
$LN12@DFS:

; 2458 :     }
; 2459 : 
; 2460 :     // So far, no cycles have been found and we have not visited this node yet,
; 2461 :     // so this node needs to go into the cycle stack before we continue
; 2462 :     // then we will take it out of the stack once we have descended all its
; 2463 :     // dependencies.
; 2464 :     //
; 2465 :     topo->cycle[topo->cycleMark++] = node;

  000fc	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00101	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00104	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00109	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0010d	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  00111	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00114	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00119	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0011c	ff c0		 inc	 eax
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00123	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 2466 : 
; 2467 :     // First flag that we have visited this node
; 2468 :     //
; 2469 :     topo->visited->add(topo->visited, node);

  00126	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0012b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0012f	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  00133	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00138	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0013c	ff 50 30	 call	 QWORD PTR [rax+48]

; 2470 : 
; 2471 :     // Now, if this node has edges, then we want to ensure we visit
; 2472 :     // them all before we drop through and add this node into the sorted
; 2473 :     // list.
; 2474 :     //
; 2475 :     edges = *((topo->edges) + node);

  0013f	8b 44 24 58	 mov	 eax, DWORD PTR node$[rsp]
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00148	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0014f	48 89 44 24 20	 mov	 QWORD PTR edges$[rsp], rax

; 2476 :     if  (edges != NULL)

  00154	48 83 7c 24 20
	00		 cmp	 QWORD PTR edges$[rsp], 0
  0015a	74 79		 je	 SHORT $LN14@DFS

; 2477 :     {
; 2478 :         // We have some edges, so visit each of the edge nodes
; 2479 :         // that have not already been visited.
; 2480 :         //
; 2481 :         ANTLR3_UINT32   numBits;	    // How many bits are in the set
; 2482 :         ANTLR3_UINT32   i;
; 2483 :         ANTLR3_UINT32   range;
; 2484 : 
; 2485 :         numBits = edges->numBits(edges);

  0015c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR edges$[rsp]
  00161	48 8b 44 24 20	 mov	 rax, QWORD PTR edges$[rsp]
  00166	ff 50 50	 call	 QWORD PTR [rax+80]
  00169	89 44 24 30	 mov	 DWORD PTR numBits$3[rsp], eax

; 2486 :         range   = edges->size(edges);   // Number of set bits

  0016d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR edges$[rsp]
  00172	48 8b 44 24 20	 mov	 rax, QWORD PTR edges$[rsp]
  00177	ff 50 28	 call	 QWORD PTR [rax+40]
  0017a	89 44 24 38	 mov	 DWORD PTR range$5[rsp], eax

; 2487 : 
; 2488 :         // Stop if we exahust the bit list or have checked the
; 2489 :         // number of edges that this node refers to (so we don't
; 2490 :         // check bits at the end that cannot possibly be set).
; 2491 :         //
; 2492 :         for (i=0; i<= numBits && range > 0; i++)

  0017e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00186	eb 0a		 jmp	 SHORT $LN10@DFS
$LN8@DFS:
  00188	8b 44 24 34	 mov	 eax, DWORD PTR i$4[rsp]
  0018c	ff c0		 inc	 eax
  0018e	89 44 24 34	 mov	 DWORD PTR i$4[rsp], eax
$LN10@DFS:
  00192	8b 44 24 30	 mov	 eax, DWORD PTR numBits$3[rsp]
  00196	39 44 24 34	 cmp	 DWORD PTR i$4[rsp], eax
  0019a	77 39		 ja	 SHORT $LN9@DFS
  0019c	83 7c 24 38 00	 cmp	 DWORD PTR range$5[rsp], 0
  001a1	76 32		 jbe	 SHORT $LN9@DFS

; 2493 :         {
; 2494 :             if  (edges->isMember(edges, i))

  001a3	8b 54 24 34	 mov	 edx, DWORD PTR i$4[rsp]
  001a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR edges$[rsp]
  001ac	48 8b 44 24 20	 mov	 rax, QWORD PTR edges$[rsp]
  001b1	ff 50 48	 call	 QWORD PTR [rax+72]
  001b4	0f b6 c0	 movzx	 eax, al
  001b7	85 c0		 test	 eax, eax
  001b9	74 18		 je	 SHORT $LN15@DFS

; 2495 :             {
; 2496 :                 range--;        // About to check another one

  001bb	8b 44 24 38	 mov	 eax, DWORD PTR range$5[rsp]
  001bf	ff c8		 dec	 eax
  001c1	89 44 24 38	 mov	 DWORD PTR range$5[rsp], eax

; 2497 : 
; 2498 :                 // Found an edge, make sure we visit and descend it
; 2499 :                 //
; 2500 :                 DFS(topo, i);

  001c5	8b 54 24 34	 mov	 edx, DWORD PTR i$4[rsp]
  001c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  001ce	e8 00 00 00 00	 call	 DFS
$LN15@DFS:

; 2501 :             }
; 2502 :         }

  001d3	eb b3		 jmp	 SHORT $LN8@DFS
$LN9@DFS:
$LN14@DFS:

; 2503 :     }
; 2504 : 
; 2505 :     // At this point we will have visited all the dependencies
; 2506 :     // of this node and they will be ordered (even if there are cycles)
; 2507 :     // So we just add the node into the sorted list at the
; 2508 :     // current index position.
; 2509 :     //
; 2510 :     topo->sorted[topo->limit++] = node;

  001d5	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  001da	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  001e2	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001e6	8b 54 24 58	 mov	 edx, DWORD PTR node$[rsp]
  001ea	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  001ed	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  001f2	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001f5	ff c0		 inc	 eax
  001f7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  001fc	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 2511 : 
; 2512 :     // Remove this node from the cycle list if we have not detected a cycle
; 2513 :     //
; 2514 :     if  (topo->hasCycle == ANTLR3_FALSE)

  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00204	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00208	85 c0		 test	 eax, eax
  0020a	75 12		 jne	 SHORT $LN16@DFS

; 2515 :     {
; 2516 :         topo->cycleMark--;

  0020c	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00211	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00214	ff c8		 dec	 eax
  00216	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0021b	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN16@DFS:
$LN1@DFS:

; 2517 :     }
; 2518 : 
; 2519 :     return;
; 2520 : }

  0021e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00222	5f		 pop	 rdi
  00223	c3		 ret	 0
DFS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT freeIntNode
_TEXT	SEGMENT
thisEntry$ = 32
nextEntry$ = 40
node$ = 64
freeIntNode PROC					; COMDAT

; 2191 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2192 :     pANTLR3_TRIE_ENTRY	thisEntry;
; 2193 :     pANTLR3_TRIE_ENTRY	nextEntry;
; 2194 : 
; 2195 :     /* If this node has a left pointer that is not a back pointer
; 2196 :      * then recursively call to free this
; 2197 :      */
; 2198 :     if (node->bitNum > node->leftN->bitNum)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  0000f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR node$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	39 01		 cmp	 DWORD PTR [rcx], eax
  0001c	76 0e		 jbe	 SHORT $LN4@freeIntNod

; 2199 :     {
; 2200 : 	/* We have a left node that needs descending, so do it.
; 2201 : 	 */
; 2202 : 	freeIntNode(node->leftN);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00023	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00027	e8 00 00 00 00	 call	 freeIntNode
$LN4@freeIntNod:

; 2203 :     }
; 2204 : 
; 2205 :     /* The left nodes from here should now be dealt with, so 
; 2206 :      * we need to descend any right nodes that are not back pointers
; 2207 :      */
; 2208 :     if (node->bitNum > node->rightN->bitNum)

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00031	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR node$[rsp]
  0003a	8b 00		 mov	 eax, DWORD PTR [rax]
  0003c	39 01		 cmp	 DWORD PTR [rcx], eax
  0003e	76 0e		 jbe	 SHORT $LN5@freeIntNod

; 2209 :     {
; 2210 : 	/* There are some right nodes to descend and deal with.
; 2211 : 	 */
; 2212 : 	freeIntNode(node->rightN);

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00045	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00049	e8 00 00 00 00	 call	 freeIntNode
$LN5@freeIntNod:

; 2213 :     }
; 2214 : 
; 2215 :     /* Now all the children are dealt with, we can destroy
; 2216 :      * this node too
; 2217 :      */
; 2218 :     thisEntry	= node->buckets;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR node$[rsp]
  00053	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00057	48 89 44 24 20	 mov	 QWORD PTR thisEntry$[rsp], rax
$LN2@freeIntNod:

; 2219 : 
; 2220 :     while (thisEntry != NULL)

  0005c	48 83 7c 24 20
	00		 cmp	 QWORD PTR thisEntry$[rsp], 0
  00062	74 4c		 je	 SHORT $LN3@freeIntNod

; 2221 :     {
; 2222 : 	nextEntry   = thisEntry->next;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  00069	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006d	48 89 44 24 28	 mov	 QWORD PTR nextEntry$[rsp], rax

; 2223 : 
; 2224 : 	/* Do we need to call a custom free pointer for this string entry?
; 2225 : 	 */
; 2226 : 	if (thisEntry->type == ANTLR3_HASH_TYPE_STR && thisEntry->freeptr != NULL)

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  00077	83 38 01	 cmp	 DWORD PTR [rax], 1
  0007a	75 1d		 jne	 SHORT $LN6@freeIntNod
  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  00081	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00086	74 11		 je	 SHORT $LN6@freeIntNod

; 2227 : 	{
; 2228 : 	    thisEntry->freeptr(thisEntry->data.ptr);

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  0008d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR thisEntry$[rsp]
  00096	ff 50 08	 call	 QWORD PTR [rax+8]
$LN6@freeIntNod:

; 2229 : 	}
; 2230 : 
; 2231 : 	/* Now free the data for this bucket entry
; 2232 : 	 */
; 2233 : 	ANTLR3_FREE(thisEntry);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR thisEntry$[rsp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2234 : 	thisEntry = nextEntry;	    /* See if there are any more to free    */

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR nextEntry$[rsp]
  000a9	48 89 44 24 20	 mov	 QWORD PTR thisEntry$[rsp], rax

; 2235 :     }

  000ae	eb ac		 jmp	 SHORT $LN2@freeIntNod
$LN3@freeIntNod:

; 2236 : 
; 2237 :     /* The bucket entry is now gone, so we can free the memory for
; 2238 :      * the entry itself.
; 2239 :      */
; 2240 :     ANTLR3_FREE(node);

  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR node$[rsp]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2241 : 
; 2242 :     /* And that should be it for everything under this node and itself
; 2243 :      */
; 2244 : }

  000bb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
freeIntNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorResize
_TEXT	SEGMENT
newSize$ = 32
vector$ = 64
hint$ = 72
antlr3VectorResize PROC					; COMDAT

; 1290 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1291 : 	ANTLR3_UINT32	newSize;
; 1292 : 
; 1293 : 	// Need to resize the element pointers. We double the allocation
; 1294 : 	// we already have unless asked for a specific increase.
; 1295 :     //
; 1296 :     if (hint == 0 || hint < vector->elementsSize)

  0000e	83 7c 24 48 00	 cmp	 DWORD PTR hint$[rsp], 0
  00013	74 11		 je	 SHORT $LN4@antlr3Vect
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0001a	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00020	39 44 24 48	 cmp	 DWORD PTR hint$[rsp], eax
  00024	73 13		 jae	 SHORT $LN2@antlr3Vect
$LN4@antlr3Vect:

; 1297 :     {
; 1298 :         newSize = vector->elementsSize * 2;

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0002b	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00031	d1 e0		 shl	 eax, 1
  00033	89 44 24 20	 mov	 DWORD PTR newSize$[rsp], eax

; 1299 :     }

  00037	eb 0a		 jmp	 SHORT $LN3@antlr3Vect
$LN2@antlr3Vect:

; 1300 :     else
; 1301 :     {
; 1302 :         newSize = hint * 2;

  00039	8b 44 24 48	 mov	 eax, DWORD PTR hint$[rsp]
  0003d	d1 e0		 shl	 eax, 1
  0003f	89 44 24 20	 mov	 DWORD PTR newSize$[rsp], eax
$LN3@antlr3Vect:

; 1303 :     }
; 1304 : 
; 1305 :     // Now we know how many we need, so we see if we have just expanded
; 1306 :     // past the built in vector elements or were already past that
; 1307 :     //
; 1308 :     if  (vector->elementsSize > ANTLR3_VECTOR_INTERNAL_SIZE)

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00048	83 b8 14 01 00
	00 10		 cmp	 DWORD PTR [rax+276], 16
  0004f	76 23		 jbe	 SHORT $LN5@antlr3Vect

; 1309 :     {
; 1310 :         // We were already larger than the internal size, so we just
; 1311 :         // use realloc so that the pointers are copied for us
; 1312 :         //
; 1313 :         vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_REALLOC(vector->elements, (sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));

  00051	8b 44 24 20	 mov	 eax, DWORD PTR newSize$[rsp]
  00055	48 6b c0 10	 imul	 rax, rax, 16
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00061	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0006f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1314 :     }

  00072	eb 38		 jmp	 SHORT $LN6@antlr3Vect
$LN5@antlr3Vect:

; 1315 :     else
; 1316 :     {
; 1317 :         // The current size was less than or equal to the internal array size and as we always start
; 1318 :         // with a size that is at least the maximum internal size, then we must need to allocate new memory
; 1319 :         // for external pointers. We don't want to take the time to calculate if a requested element
; 1320 :         // is part of the internal or external entries, so we copy the internal ones to the new space
; 1321 :         //
; 1322 :         vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_MALLOC((sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));

  00074	8b 44 24 20	 mov	 eax, DWORD PTR newSize$[rsp]
  00078	48 6b c0 10	 imul	 rax, rax, 16
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00085	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0008a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1323 :         ANTLR3_MEMCPY(vector->elements, vector->internal, ANTLR3_VECTOR_INTERNAL_SIZE * sizeof(ANTLR3_VECTOR_ELEMENT));

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00092	48 83 c0 10	 add	 rax, 16
  00096	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0009c	48 8b d0	 mov	 rdx, rax
  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000a4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a7	e8 00 00 00 00	 call	 memcpy
$LN6@antlr3Vect:

; 1324 :     }
; 1325 : 
; 1326 : 	vector->elementsSize	= newSize;

  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000b1	8b 4c 24 20	 mov	 ecx, DWORD PTR newSize$[rsp]
  000b5	89 88 14 01 00
	00		 mov	 DWORD PTR [rax+276], ecx

; 1327 : }

  000bb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
antlr3VectorResize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumNextEntry
_TEXT	SEGMENT
bucket$ = 0
en$ = 32
antlr3EnumNextEntry PROC				; COMDAT

; 766  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 767  :     pANTLR3_HASH_BUCKET	bucket;
; 768  : 
; 769  :     /* See if the current entry pointer is valid first of all
; 770  :      */
; 771  :     if	(en->entry != NULL)

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0000f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00014	74 28		 je	 SHORT $LN4@antlr3Enum

; 772  :     {
; 773  : 	/* Current entry was a valid point, see if there is another
; 774  : 	 * one in the chain.
; 775  : 	 */
; 776  : 	if  (en->entry->nextEntry != NULL)

  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0001b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001f	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00024	74 18		 je	 SHORT $LN5@antlr3Enum

; 777  : 	{
; 778  : 	    /* Next entry in the enumeration is just the next entry
; 779  : 	     * in the chain.
; 780  : 	     */
; 781  : 	    en->entry = en->entry->nextEntry;

  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0002b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00034	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00038	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 782  : 	    return;

  0003c	eb 73		 jmp	 SHORT $LN1@antlr3Enum
$LN5@antlr3Enum:
$LN4@antlr3Enum:

; 783  : 	}
; 784  :     }
; 785  : 
; 786  :     /* There were no more entries in the current bucket, if there are
; 787  :      * more buckets then chase them until we find an entry.
; 788  :      */
; 789  :     en->bucket++;

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00043	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00046	ff c0		 inc	 eax
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  0004d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN2@antlr3Enum:

; 790  : 
; 791  :     while   (en->bucket < en->table->modulo)

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00055	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00060	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  00063	73 4c		 jae	 SHORT $LN3@antlr3Enum

; 792  :     {
; 793  : 	/* There was one more bucket, see if it has any elements in it
; 794  : 	 */
; 795  : 	bucket	= en->table->buckets + en->bucket;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00072	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00075	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00079	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  0007d	48 89 04 24	 mov	 QWORD PTR bucket$[rsp], rax

; 796  : 
; 797  : 	if  (bucket->entries != NULL)

  00081	48 8b 04 24	 mov	 rax, QWORD PTR bucket$[rsp]
  00085	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00089	74 12		 je	 SHORT $LN6@antlr3Enum

; 798  : 	{
; 799  : 	    /* There was an entry in this bucket, so we can use it
; 800  : 	     * for the next entry in the enumeration.
; 801  : 	     */
; 802  : 	    en->entry	= bucket->entries;

  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00090	48 8b 0c 24	 mov	 rcx, QWORD PTR bucket$[rsp]
  00094	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00097	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 803  : 	    return;

  0009b	eb 14		 jmp	 SHORT $LN1@antlr3Enum
$LN6@antlr3Enum:

; 804  : 	}
; 805  : 
; 806  : 	/* There was nothing in the bucket we just examined, move to the
; 807  : 	 * next one.
; 808  : 	 */
; 809  : 	en->bucket++;

  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  000a2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a5	ff c0		 inc	 eax
  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  000ac	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 810  :     }

  000af	eb 9f		 jmp	 SHORT $LN2@antlr3Enum
$LN3@antlr3Enum:
$LN1@antlr3Enum:

; 811  : 
; 812  :     /* Here we have exhausted all buckets and the enumeration pointer will 
; 813  :      * have its bucket count = table->modulo which signifies that we are done.
; 814  :      */
; 815  : }

  000b1	48 83 c4 10	 add	 rsp, 16
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
antlr3EnumNextEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT freeTopo
_TEXT	SEGMENT
i$ = 32
edgeList$1 = 40
topo$ = 64
freeTopo PROC						; COMDAT

; 2693 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2694 :     ANTLR3_UINT32   i;
; 2695 : 
; 2696 :     // Free the result vector
; 2697 :     //
; 2698 :     if  (topo->sorted != NULL)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0000f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00014	74 1c		 je	 SHORT $LN5@freeTopo

; 2699 :     {
; 2700 :         ANTLR3_FREE(topo->sorted);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0001b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2701 :         topo->sorted = NULL;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0002a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN5@freeTopo:

; 2702 :     }
; 2703 : 
; 2704 :     // Free the visited map
; 2705 :     //
; 2706 :     if  (topo->visited != NULL)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00037	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0003c	74 22		 je	 SHORT $LN6@freeTopo

; 2707 :     {
; 2708 : 
; 2709 :         topo->visited->free(topo->visited);

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00043	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  0004c	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00050	ff 50 70	 call	 QWORD PTR [rax+112]

; 2710 :         topo->visited = NULL;

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00058	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN6@freeTopo:

; 2711 :     }
; 2712 : 
; 2713 :     // Free any edgemaps
; 2714 :     //
; 2715 :     if  (topo->edges != NULL)

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00065	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00069	74 5c		 je	 SHORT $LN7@freeTopo

; 2716 :     {
; 2717 :         pANTLR3_BITSET edgeList;
; 2718 : 
; 2719 :         
; 2720 :         for (i=0; i<topo->limit; i++)

  0006b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00073	eb 0a		 jmp	 SHORT $LN4@freeTopo
$LN2@freeTopo:
  00075	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00079	ff c0		 inc	 eax
  0007b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@freeTopo:
  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00084	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00087	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0008b	73 2c		 jae	 SHORT $LN3@freeTopo

; 2721 :         {
; 2722 :             edgeList = *((topo->edges) + i);

  0008d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00096	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00099	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0009d	48 89 44 24 28	 mov	 QWORD PTR edgeList$1[rsp], rax

; 2723 :             if  (edgeList != NULL)

  000a2	48 83 7c 24 28
	00		 cmp	 QWORD PTR edgeList$1[rsp], 0
  000a8	74 0d		 je	 SHORT $LN8@freeTopo

; 2724 :             {
; 2725 :                 edgeList->free(edgeList);

  000aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR edgeList$1[rsp]
  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR edgeList$1[rsp]
  000b4	ff 50 70	 call	 QWORD PTR [rax+112]
$LN8@freeTopo:

; 2726 :             }
; 2727 :         }

  000b7	eb bc		 jmp	 SHORT $LN2@freeTopo
$LN3@freeTopo:

; 2728 : 
; 2729 :         ANTLR3_FREE(topo->edges);

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000be	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@freeTopo:

; 2730 :     }
; 2731 :     topo->edges = NULL;

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000cc	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2732 :     
; 2733 :     // Free any cycle map
; 2734 :     //
; 2735 :     if  (topo->cycle != NULL)

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000d8	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000dd	74 0f		 je	 SHORT $LN9@freeTopo

; 2736 :     {
; 2737 :         ANTLR3_FREE(topo->cycle);

  000df	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000e4	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@freeTopo:

; 2738 :     }
; 2739 : 
; 2740 :     ANTLR3_FREE(topo);

  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2741 : }

  000f9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
freeTopo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT sortVector
_TEXT	SEGMENT
i$ = 32
vIndex$ = 40
ind$1 = 48
topo$ = 80
v$ = 88
sortVector PROC						; COMDAT

; 2592 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2593 :     // To sort a vector, we first perform the
; 2594 :     // sort to an array, then use the results to reorder the vector
; 2595 :     // we are given. This is just a convenience routine that allows you to
; 2596 :     // sort the children of a tree node into topological order before or
; 2597 :     // during an AST walk. This can be useful for optimizations that require
; 2598 :     // dag reorders and also when the input stream defines thigns that are
; 2599 :     // interdependent and you want to walk the list of the generated trees
; 2600 :     // for those things in topological order so you can ignore the interdependencies
; 2601 :     // at that point.
; 2602 :     //
; 2603 :     ANTLR3_UINT32 i;
; 2604 : 
; 2605 :     // Used as a lookup index to find the current location in the vector of
; 2606 :     // the vector entry that was originally at position [0], [1], [2] etc
; 2607 :     //
; 2608 :     pANTLR3_UINT32  vIndex;
; 2609 : 
; 2610 :     // Sort into an array, then we can use the array that is
; 2611 :     // stored in the topo
; 2612 :     //
; 2613 :     if  (topo->sortToArray(topo) == 0)

  0000f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00019	ff 50 38	 call	 QWORD PTR [rax+56]
  0001c	48 85 c0	 test	 rax, rax
  0001f	75 05		 jne	 SHORT $LN8@sortVector

; 2614 :     {
; 2615 :         return;     // There were no edges

  00021	e9 3a 01 00 00	 jmp	 $LN1@sortVector
$LN8@sortVector:

; 2616 :     }
; 2617 : 
; 2618 :     if  (topo->hasCycle == ANTLR3_TRUE)

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0002b	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0002f	83 f8 01	 cmp	 eax, 1
  00032	75 05		 jne	 SHORT $LN9@sortVector

; 2619 :     {
; 2620 :         return;  // Do nothing if we detected a cycle

  00034	e9 27 01 00 00	 jmp	 $LN1@sortVector
$LN9@sortVector:

; 2621 :     }
; 2622 : 
; 2623 :     // Ensure that the vector we are sorting is at least as big as the
; 2624 :     // the input sequence we were adsked to sort. It does not matter if it is
; 2625 :     // bigger as thaat probably just means that nodes numbered higher than the
; 2626 :     // limit had no dependencies and so can be left alone.
; 2627 :     //
; 2628 :     if  (topo->limit > v->count)

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0003e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00043	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00046	39 48 20	 cmp	 DWORD PTR [rax+32], ecx
  00049	76 10		 jbe	 SHORT $LN10@sortVector

; 2629 :     {
; 2630 :         // We can only sort the entries that we have dude! The caller is
; 2631 :         // responsible for ensuring the vector is the correct one and is the
; 2632 :         // correct size etc.
; 2633 :         //
; 2634 :         topo->limit = v->count;

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00050	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00055	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00058	89 48 20	 mov	 DWORD PTR [rax+32], ecx
$LN10@sortVector:

; 2635 :     }
; 2636 :     // We need to know the locations of each of the entries
; 2637 :     // in the vector as we don't want to duplicate them in a new vector. We
; 2638 :     // just use an indirection table to get the vector entry for a particular sequence
; 2639 :     // acording to where we moved it last. Then we can just swap vector entries until
; 2640 :     // we are done :-)
; 2641 :     //
; 2642 :     vIndex = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  00060	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00063	48 c1 e0 02	 shl	 rax, 2
  00067	48 8b c8	 mov	 rcx, rax
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00070	48 89 44 24 28	 mov	 QWORD PTR vIndex$[rsp], rax

; 2643 : 
; 2644 :     // Start index, each vector entry is located where you think it is
; 2645 :     //
; 2646 :     for (i = 0; i < topo->limit; i++)

  00075	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007d	eb 0a		 jmp	 SHORT $LN4@sortVector
$LN2@sortVector:
  0007f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00083	ff c0		 inc	 eax
  00085	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@sortVector:
  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  0008e	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00091	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00095	73 12		 jae	 SHORT $LN3@sortVector

; 2647 :     {
; 2648 :         vIndex[i] = i;

  00097	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  000a0	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000a4	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 2649 :     }

  000a7	eb d6		 jmp	 SHORT $LN2@sortVector
$LN3@sortVector:

; 2650 : 
; 2651 :     // Now we traverse the sorted array and moved the entries of
; 2652 :     // the vector around according to the sort order and the indirection
; 2653 :     // table we just created. The index telsl us where in the vector the
; 2654 :     // original element entry n is now located via vIndex[n].
; 2655 :     //
; 2656 :     for (i=0; i < topo->limit; i++)

  000a9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b1	eb 0a		 jmp	 SHORT $LN7@sortVector
$LN5@sortVector:
  000b3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b7	ff c0		 inc	 eax
  000b9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@sortVector:
  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR topo$[rsp]
  000c2	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000c5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000c9	0f 83 86 00 00
	00		 jae	 $LN6@sortVector

; 2657 :     {
; 2658 :         ANTLR3_UINT32   ind;
; 2659 : 
; 2660 :         // If the vector entry at i is already the one that it
; 2661 :         // should be, then we skip moving it of course.
; 2662 :         //
; 2663 :         if  (vIndex[topo->sorted[i]] == i)

  000cf	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000d8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000dc	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  000e4	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  000e8	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  000eb	75 02		 jne	 SHORT $LN11@sortVector

; 2664 :         {
; 2665 :             continue;

  000ed	eb c4		 jmp	 SHORT $LN5@sortVector
$LN11@sortVector:

; 2666 :         }
; 2667 : 
; 2668 :         // The vector entry at i, should be replaced with the
; 2669 :         // vector entry indicated by topo->sorted[i]. The vector entry
; 2670 :         // at topo->sorted[i] may have already been swapped out though, so we
; 2671 :         // find where it is now and move it from there to i.
; 2672 :         //
; 2673 :         ind     = vIndex[topo->sorted[i]];

  000ef	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  000f8	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000fc	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  00104	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00107	89 44 24 30	 mov	 DWORD PTR ind$1[rsp], eax

; 2674 :         v->swap(v, i, ind);

  0010b	44 8b 44 24 30	 mov	 r8d, DWORD PTR ind$1[rsp]
  00110	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00114	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$[rsp]
  00119	48 8b 44 24 58	 mov	 rax, QWORD PTR v$[rsp]
  0011e	ff 90 40 01 00
	00		 call	 QWORD PTR [rax+320]

; 2675 : 
; 2676 :         // Update our index. The element at i is now the one we wanted
; 2677 :         // to be sorted here and the element we swapped out is now the
; 2678 :         // element that was at i just before we swapped it. If you are lost now
; 2679 :         // don't worry about it, we are just reindexing on the fly is all.
; 2680 :         //
; 2681 :         vIndex[topo->sorted[i]] = i;

  00124	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00128	48 8b 4c 24 50	 mov	 rcx, QWORD PTR topo$[rsp]
  0012d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00131	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00134	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  00139	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0013d	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 2682 :         vIndex[i] = ind;

  00140	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00144	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  00149	8b 54 24 30	 mov	 edx, DWORD PTR ind$1[rsp]
  0014d	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 2683 :     }

  00150	e9 5e ff ff ff	 jmp	 $LN5@sortVector
$LN6@sortVector:

; 2684 : 
; 2685 :     // Having traversed all the entries, we have sorted the vector in place.
; 2686 :     //
; 2687 :     ANTLR3_FREE(vIndex);

  00155	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vIndex$[rsp]
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@sortVector:

; 2688 :     return;
; 2689 : }

  00160	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00164	5f		 pop	 rdi
  00165	c3		 ret	 0
sortVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT sortToArray
_TEXT	SEGMENT
v$ = 32
oldLimit$ = 36
topo$ = 64
sortToArray PROC					; COMDAT

; 2524 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2525 :     ANTLR3_UINT32 v;
; 2526 :     ANTLR3_UINT32 oldLimit;
; 2527 : 
; 2528 :     // Guard against being called with no edges defined
; 2529 :     //
; 2530 :     if  (topo->edges == NULL)

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0000f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00013	75 07		 jne	 SHORT $LN5@sortToArra

; 2531 :     {
; 2532 :         return 0;

  00015	33 c0		 xor	 eax, eax
  00017	e9 d7 00 00 00	 jmp	 $LN1@sortToArra
$LN5@sortToArra:

; 2533 :     }
; 2534 :     // First we need a vector to populate with enough
; 2535 :     // entries to accomodate the sorted list and another to accomodate
; 2536 :     // the maximum cycle we could detect which is all nodes such as 0->1->2->3->0
; 2537 :     //
; 2538 :     topo->sorted    = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00021	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00024	48 c1 e0 02	 shl	 rax, 2
  00028	48 8b c8	 mov	 rcx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00036	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2539 :     topo->cycle     = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0003f	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00042	48 c1 e0 02	 shl	 rax, 2
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00054	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2540 : 
; 2541 :     // Next we need an empty bitset to show whether we have visited a node
; 2542 :     // or not. This is the bit that gives us linear time of course as we are essentially
; 2543 :     // dropping through the nodes in depth first order and when we get to a node that
; 2544 :     // has no edges, we pop back up the stack adding the nodes we traversed in reverse
; 2545 :     // order.
; 2546 :     //
; 2547 :     topo->visited   = antlr3BitsetNew(0);

  00058	33 c9		 xor	 ecx, ecx
  0005a	e8 00 00 00 00	 call	 antlr3BitsetNew
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00064	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 2548 : 
; 2549 :     // Now traverse the nodes as if we were just going left to right, but
; 2550 :     // then descend each node unless it has already been visited.
; 2551 :     //
; 2552 :     oldLimit    = topo->limit;     // Number of nodes to traverse linearly

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  0006d	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00070	89 44 24 24	 mov	 DWORD PTR oldLimit$[rsp], eax

; 2553 :     topo->limit = 0;               // Next entry in the sorted table

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00079	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 2554 : 
; 2555 :     for (v = 0; v < oldLimit; v++)

  00080	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR v$[rsp], 0
  00088	eb 0a		 jmp	 SHORT $LN4@sortToArra
$LN2@sortToArra:
  0008a	8b 44 24 20	 mov	 eax, DWORD PTR v$[rsp]
  0008e	ff c0		 inc	 eax
  00090	89 44 24 20	 mov	 DWORD PTR v$[rsp], eax
$LN4@sortToArra:
  00094	8b 44 24 24	 mov	 eax, DWORD PTR oldLimit$[rsp]
  00098	39 44 24 20	 cmp	 DWORD PTR v$[rsp], eax
  0009c	73 40		 jae	 SHORT $LN3@sortToArra

; 2556 :     {
; 2557 :         // If we did not already visit this node, then descend it until we
; 2558 :         // get a node without edges or arrive at a node we have already visited.
; 2559 :         //
; 2560 :         if  (topo->visited->isMember(topo->visited, v) == ANTLR3_FALSE)

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000a3	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a7	8b 54 24 20	 mov	 edx, DWORD PTR v$[rsp]
  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000b0	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b4	ff 50 48	 call	 QWORD PTR [rax+72]
  000b7	0f b6 c0	 movzx	 eax, al
  000ba	85 c0		 test	 eax, eax
  000bc	75 0e		 jne	 SHORT $LN6@sortToArra

; 2561 :         {
; 2562 :             // We have not visited this one so descend it
; 2563 :             //
; 2564 :             DFS(topo, v);

  000be	8b 54 24 20	 mov	 edx, DWORD PTR v$[rsp]
  000c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000c7	e8 00 00 00 00	 call	 DFS
$LN6@sortToArra:

; 2565 :         }
; 2566 : 
; 2567 :         // Break the loop if we detect a cycle as we have no need to go any
; 2568 :         // further
; 2569 :         //
; 2570 :         if  (topo->hasCycle == ANTLR3_TRUE)

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000d1	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	75 02		 jne	 SHORT $LN7@sortToArra

; 2571 :         {
; 2572 :             break;

  000da	eb 02		 jmp	 SHORT $LN3@sortToArra
$LN7@sortToArra:

; 2573 :         }
; 2574 :     }

  000dc	eb ac		 jmp	 SHORT $LN2@sortToArra
$LN3@sortToArra:

; 2575 : 
; 2576 :     // Reset the limit to the number we recorded as if we hit a
; 2577 :     // cycle, then limit will have stopped at the node where we
; 2578 :     // discovered the cycle, but in order to free the edge bitmaps
; 2579 :     // we need to know how many we may have allocated and traverse them all.
; 2580 :     //
; 2581 :     topo->limit = oldLimit;

  000de	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000e3	8b 4c 24 24	 mov	 ecx, DWORD PTR oldLimit$[rsp]
  000e7	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 2582 : 
; 2583 :     // Having traversed all the nodes we were given, we
; 2584 :     // are guaranteed to have ordered all the nodes or detected a
; 2585 :     // cycle.
; 2586 :     //
; 2587 :     return topo->sorted;

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000ef	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@sortToArra:

; 2588 : }

  000f3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f7	5f		 pop	 rdi
  000f8	c3		 ret	 0
sortToArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT addEdge
_TEXT	SEGMENT
i$ = 32
maxEdge$ = 36
edgeDeps$ = 40
topo$ = 64
edge$ = 72
dependency$ = 80
addEdge	PROC						; COMDAT

; 2317 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2318 :     ANTLR3_UINT32   i;
; 2319 :     ANTLR3_UINT32   maxEdge;
; 2320 :     pANTLR3_BITSET  edgeDeps;
; 2321 : 
; 2322 :     if (edge>dependency)

  00013	8b 44 24 50	 mov	 eax, DWORD PTR dependency$[rsp]
  00017	39 44 24 48	 cmp	 DWORD PTR edge$[rsp], eax
  0001b	76 0a		 jbe	 SHORT $LN5@addEdge

; 2323 :     {
; 2324 :         maxEdge = edge;

  0001d	8b 44 24 48	 mov	 eax, DWORD PTR edge$[rsp]
  00021	89 44 24 24	 mov	 DWORD PTR maxEdge$[rsp], eax

; 2325 :     }

  00025	eb 08		 jmp	 SHORT $LN6@addEdge
$LN5@addEdge:

; 2326 :     else
; 2327 :     {
; 2328 :         maxEdge = dependency;

  00027	8b 44 24 50	 mov	 eax, DWORD PTR dependency$[rsp]
  0002b	89 44 24 24	 mov	 DWORD PTR maxEdge$[rsp], eax
$LN6@addEdge:

; 2329 :     }
; 2330 :     // We need to add an edge to says that the node indexed by 'edge' is
; 2331 :     // dependent on the node indexed by 'dependency'
; 2332 :     //
; 2333 : 
; 2334 :     // First see if we have enough room in the edges array to add the edge?
; 2335 :     //
; 2336 :     if (topo->edges == NULL)

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00034	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00038	75 45		 jne	 SHORT $LN7@addEdge

; 2337 :     {
; 2338 :         // We don't have any edges yet, so create an array to hold them
; 2339 :         //
; 2340 :         topo->edges = ANTLR3_CALLOC(sizeof(pANTLR3_BITSET) * (maxEdge + 1), 1);

  0003a	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  0003e	ff c0		 inc	 eax
  00040	8b c0		 mov	 eax, eax
  00042	48 c1 e0 03	 shl	 rax, 3
  00046	ba 01 00 00 00	 mov	 edx, 1
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00059	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2341 :         if (topo->edges == NULL)

  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00061	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00065	75 05		 jne	 SHORT $LN9@addEdge

; 2342 :         {
; 2343 :             return;

  00067	e9 01 01 00 00	 jmp	 $LN1@addEdge
$LN9@addEdge:

; 2344 :         }
; 2345 : 
; 2346 :         // Set the limit to what we have now
; 2347 :         //
; 2348 :         topo->limit = maxEdge + 1;

  0006c	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  00070	ff c0		 inc	 eax
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00077	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 2349 :     }

  0007a	e9 89 00 00 00	 jmp	 $LN8@addEdge
$LN7@addEdge:

; 2350 :     else if (topo->limit <= maxEdge)

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  00084	8b 4c 24 24	 mov	 ecx, DWORD PTR maxEdge$[rsp]
  00088	39 48 20	 cmp	 DWORD PTR [rax+32], ecx
  0008b	77 7b		 ja	 SHORT $LN10@addEdge

; 2351 :     {
; 2352 :         // WE have some edges but not enough
; 2353 :         //
; 2354 :         topo->edges = ANTLR3_REALLOC(topo->edges, sizeof(pANTLR3_BITSET) * (maxEdge + 1));

  0008d	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  00091	ff c0		 inc	 eax
  00093	8b c0		 mov	 eax, eax
  00095	48 c1 e0 03	 shl	 rax, 3
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000a1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000af	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2355 :         if (topo->edges == NULL)

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000b7	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000bb	75 05		 jne	 SHORT $LN11@addEdge

; 2356 :         {
; 2357 :             return;

  000bd	e9 ab 00 00 00	 jmp	 $LN1@addEdge
$LN11@addEdge:

; 2358 :         }
; 2359 : 
; 2360 :         // Initialize the new bitmaps to ;indicate we have no edges defined yet
; 2361 :         //
; 2362 :         for (i = topo->limit; i <= maxEdge; i++)

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR topo$[rsp]
  000c7	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000ca	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000ce	eb 0a		 jmp	 SHORT $LN4@addEdge
$LN2@addEdge:
  000d0	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d4	ff c0		 inc	 eax
  000d6	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@addEdge:
  000da	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  000de	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000e2	77 16		 ja	 SHORT $LN3@addEdge

; 2363 :         {
; 2364 :             *((topo->edges) + i) = NULL;

  000e4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  000ed	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f0	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 2365 :         }

  000f8	eb d6		 jmp	 SHORT $LN2@addEdge
$LN3@addEdge:

; 2366 : 
; 2367 :         // Set the limit to what we have now
; 2368 :         //
; 2369 :         topo->limit = maxEdge + 1;

  000fa	8b 44 24 24	 mov	 eax, DWORD PTR maxEdge$[rsp]
  000fe	ff c0		 inc	 eax
  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00105	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN10@addEdge:
$LN8@addEdge:

; 2370 :     }
; 2371 : 
; 2372 :     // If the edge was flagged as depending on itself, then we just
; 2373 :     // do nothing as it means this routine was just called to add it
; 2374 :     // in to the list of nodes.
; 2375 :     //
; 2376 :     if  (edge == dependency)

  00108	8b 44 24 50	 mov	 eax, DWORD PTR dependency$[rsp]
  0010c	39 44 24 48	 cmp	 DWORD PTR edge$[rsp], eax
  00110	75 02		 jne	 SHORT $LN12@addEdge

; 2377 :     {
; 2378 :         return;

  00112	eb 59		 jmp	 SHORT $LN1@addEdge
$LN12@addEdge:

; 2379 :     }
; 2380 : 
; 2381 :     // Pick up the bit map for the requested edge
; 2382 :     //
; 2383 :     edgeDeps = *((topo->edges) + edge);

  00114	8b 44 24 48	 mov	 eax, DWORD PTR edge$[rsp]
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  0011d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00120	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00124	48 89 44 24 28	 mov	 QWORD PTR edgeDeps$[rsp], rax

; 2384 : 
; 2385 :     if  (edgeDeps == NULL)

  00129	48 83 7c 24 28
	00		 cmp	 QWORD PTR edgeDeps$[rsp], 0
  0012f	75 2b		 jne	 SHORT $LN13@addEdge

; 2386 :     {
; 2387 :         // No edges are defined yet for this node
; 2388 :         //
; 2389 :         edgeDeps                = antlr3BitsetNew(0);

  00131	33 c9		 xor	 ecx, ecx
  00133	e8 00 00 00 00	 call	 antlr3BitsetNew
  00138	48 89 44 24 28	 mov	 QWORD PTR edgeDeps$[rsp], rax

; 2390 :         *((topo->edges) + edge) = edgeDeps;

  0013d	8b 44 24 48	 mov	 eax, DWORD PTR edge$[rsp]
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR topo$[rsp]
  00146	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00149	48 8b 54 24 28	 mov	 rdx, QWORD PTR edgeDeps$[rsp]
  0014e	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2391 :         if (edgeDeps == NULL )

  00152	48 83 7c 24 28
	00		 cmp	 QWORD PTR edgeDeps$[rsp], 0
  00158	75 02		 jne	 SHORT $LN14@addEdge

; 2392 :         {
; 2393 :             return;  // Out of memory

  0015a	eb 11		 jmp	 SHORT $LN1@addEdge
$LN14@addEdge:
$LN13@addEdge:

; 2394 :         }
; 2395 :     }
; 2396 : 
; 2397 :     // Set the bit in the bitmap that corresponds to the requested
; 2398 :     // dependency.
; 2399 :     //
; 2400 :     edgeDeps->add(edgeDeps, dependency);

  0015c	8b 54 24 50	 mov	 edx, DWORD PTR dependency$[rsp]
  00160	48 8b 4c 24 28	 mov	 rcx, QWORD PTR edgeDeps$[rsp]
  00165	48 8b 44 24 28	 mov	 rax, QWORD PTR edgeDeps$[rsp]
  0016a	ff 50 30	 call	 QWORD PTR [rax+48]
$LN1@addEdge:

; 2401 : 
; 2402 :     // And we are all set
; 2403 :     //
; 2404 :     return;
; 2405 : }

  0016d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00171	5f		 pop	 rdi
  00172	c3		 ret	 0
addEdge	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieFree
_TEXT	SEGMENT
trie$ = 48
intTrieFree PROC					; COMDAT

; 2250 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2251 :     /* Descend from the root and free all the nodes
; 2252 :      */
; 2253 :     freeIntNode(trie->root);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR trie$[rsp]
  0000f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00012	e8 00 00 00 00	 call	 freeIntNode

; 2254 : 
; 2255 :     /* the nodes are all gone now, so we need only free the memory
; 2256 :      * for the structure itself
; 2257 :      */
; 2258 :     ANTLR3_FREE(trie);

  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR trie$[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2259 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
intTrieFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieAdd
_TEXT	SEGMENT
thisNode$ = 32
nextNode$ = 40
entNode$ = 48
depth$ = 56
newEnt$ = 64
nextEnt$ = 72
xorKey$ = 80
trie$ = 112
key$ = 120
type$ = 128
intVal$ = 136
data$ = 144
freeptr$ = 152
intTrieAdd PROC						; COMDAT

; 1914 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1915 : 	pANTLR3_INT_TRIE_NODE   thisNode;
; 1916 : 	pANTLR3_INT_TRIE_NODE   nextNode;
; 1917 : 	pANTLR3_INT_TRIE_NODE   entNode;
; 1918 : 	ANTLR3_UINT32			depth;
; 1919 : 	pANTLR3_TRIE_ENTRY	    newEnt;
; 1920 : 	pANTLR3_TRIE_ENTRY	    nextEnt;
; 1921 : 	ANTLR3_INTKEY		    xorKey;
; 1922 : 
; 1923 : 	/* Cache the bit depth of this trie, which is always the highest index, 
; 1924 : 	 * which is in the root node
; 1925 : 	 */
; 1926 : 	depth   = trie->root->bitNum;

  00019	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	8b 00		 mov	 eax, DWORD PTR [rax]
  00023	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 1927 : 
; 1928 : 	thisNode	= trie->root;		/* Start with the root node	    */

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 1929 : 	nextNode	= trie->root->leftN;	/* And assume we start to the left  */

  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00040	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax
$LN2@intTrieAdd:

; 1930 : 
; 1931 : 	/* Now find the only node that can be currently reached by the bits in the
; 1932 : 	 * key we are being asked to insert.
; 1933 : 	 */
; 1934 : 	while (thisNode->bitNum  > nextNode->bitNum)

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  0004a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  0004f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00051	39 08		 cmp	 DWORD PTR [rax], ecx
  00053	76 4c		 jbe	 SHORT $LN3@intTrieAdd

; 1935 : 	{
; 1936 : 		/* Still descending the structure, next node becomes current.
; 1937 : 		 */
; 1938 : 		thisNode = nextNode;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  0005a	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 1939 : 
; 1940 : 		if (key & bitMask[nextNode->bitNum])

  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00064	8b 00		 mov	 eax, DWORD PTR [rax]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  0006d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00071	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  00076	48 23 c8	 and	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 85 c0	 test	 rax, rax
  0007f	74 10		 je	 SHORT $LN8@intTrieAdd

; 1941 : 		{
; 1942 : 			/* Bit at the required index was 1, so travers the right node from here
; 1943 : 			 */
; 1944 : 			nextNode = nextNode->rightN;

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00086	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0008a	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax

; 1945 : 		}

  0008f	eb 0e		 jmp	 SHORT $LN9@intTrieAdd
$LN8@intTrieAdd:

; 1946 : 		else
; 1947 : 		{
; 1948 : 			/* Bit at the required index was 0, so we traverse to the left
; 1949 : 			 */
; 1950 : 			nextNode = nextNode->leftN;

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00096	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009a	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax
$LN9@intTrieAdd:

; 1951 : 		}
; 1952 : 	}

  0009f	eb a4		 jmp	 SHORT $LN2@intTrieAdd
$LN3@intTrieAdd:

; 1953 : 	/* Here we have located the only node that can be reached by the
; 1954 : 	 * bits in the requested key. It could in fact be that key or the node
; 1955 : 	 * we need to use to insert the new key.
; 1956 : 	 */
; 1957 : 	if (nextNode->key == key)

  000a1	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  000a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  000ab	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000af	0f 85 dd 00 00
	00		 jne	 $LN10@intTrieAdd

; 1958 : 	{
; 1959 : 		/* We have located an exact match, but we will only append to the bucket chain
; 1960 : 		 * if this trie accepts duplicate keys.
; 1961 : 		 */
; 1962 : 		if (trie->allowDups ==ANTLR3_TRUE)

  000b5	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  000ba	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  000be	83 f8 01	 cmp	 eax, 1
  000c1	0f 85 c4 00 00
	00		 jne	 $LN11@intTrieAdd

; 1963 : 		{
; 1964 : 			/* Yes, we are accepting duplicates
; 1965 : 			 */
; 1966 : 			newEnt = (pANTLR3_TRIE_ENTRY)ANTLR3_CALLOC(1, sizeof(ANTLR3_TRIE_ENTRY));

  000c7	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000d7	48 89 44 24 40	 mov	 QWORD PTR newEnt$[rsp], rax

; 1967 : 
; 1968 : 			if (newEnt == NULL)

  000dc	48 83 7c 24 40
	00		 cmp	 QWORD PTR newEnt$[rsp], 0
  000e2	75 07		 jne	 SHORT $LN13@intTrieAdd

; 1969 : 			{
; 1970 : 				/* Out of memory, all we can do is return the fact that the insert failed.
; 1971 : 				 */
; 1972 : 				return	ANTLR3_FALSE;

  000e4	32 c0		 xor	 al, al
  000e6	e9 95 04 00 00	 jmp	 $LN1@intTrieAdd
$LN13@intTrieAdd:

; 1973 : 			}
; 1974 : 
; 1975 : 			/* Otherwise insert this in the chain
; 1976 : 			*/
; 1977 : 			newEnt->type	= type;

  000eb	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  000f0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR type$[rsp]
  000f7	89 08		 mov	 DWORD PTR [rax], ecx

; 1978 : 			newEnt->freeptr	= freeptr;

  000f9	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  000fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR freeptr$[rsp]
  00106	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1979 : 			if (type == ANTLR3_HASH_TYPE_STR)

  0010a	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00112	75 13		 jne	 SHORT $LN14@intTrieAdd

; 1980 : 			{
; 1981 : 				newEnt->data.ptr = data;

  00114	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00119	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00121	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1982 : 			}

  00125	eb 11		 jmp	 SHORT $LN15@intTrieAdd
$LN14@intTrieAdd:

; 1983 : 			else
; 1984 : 			{
; 1985 : 				newEnt->data.intVal = intVal;

  00127	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  0012c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR intVal$[rsp]
  00134	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN15@intTrieAdd:

; 1986 : 			}
; 1987 : 
; 1988 : 			/* We want to be able to traverse the stored elements in the order that they were
; 1989 : 			 * added as duplicate keys. We might need to revise this opinion if we end up having many duplicate keys
; 1990 : 			 * as perhaps reverse order is just as good, so long as it is ordered.
; 1991 : 			 */
; 1992 : 			nextEnt = nextNode->buckets;

  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  0013d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00141	48 89 44 24 48	 mov	 QWORD PTR nextEnt$[rsp], rax
$LN4@intTrieAdd:

; 1993 : 			while (nextEnt->next != NULL)

  00146	48 8b 44 24 48	 mov	 rax, QWORD PTR nextEnt$[rsp]
  0014b	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00150	74 10		 je	 SHORT $LN5@intTrieAdd

; 1994 : 			{
; 1995 : 				nextEnt = nextEnt->next;    

  00152	48 8b 44 24 48	 mov	 rax, QWORD PTR nextEnt$[rsp]
  00157	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0015b	48 89 44 24 48	 mov	 QWORD PTR nextEnt$[rsp], rax

; 1996 : 			}

  00160	eb e4		 jmp	 SHORT $LN4@intTrieAdd
$LN5@intTrieAdd:

; 1997 : 			nextEnt->next = newEnt;

  00162	48 8b 44 24 48	 mov	 rax, QWORD PTR nextEnt$[rsp]
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newEnt$[rsp]
  0016c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1998 : 
; 1999 : 			trie->count++;

  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00175	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00178	ff c0		 inc	 eax
  0017a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trie$[rsp]
  0017f	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2000 : 			return  ANTLR3_TRUE;

  00182	b0 01		 mov	 al, 1
  00184	e9 f7 03 00 00	 jmp	 $LN1@intTrieAdd

; 2001 : 		}

  00189	eb 07		 jmp	 SHORT $LN12@intTrieAdd
$LN11@intTrieAdd:

; 2002 : 		else
; 2003 : 		{
; 2004 : 			/* We found the key is already there and we are not allowed duplicates in this
; 2005 : 			 * trie.
; 2006 : 			 */
; 2007 : 			return  ANTLR3_FALSE;

  0018b	32 c0		 xor	 al, al
  0018d	e9 ee 03 00 00	 jmp	 $LN1@intTrieAdd
$LN12@intTrieAdd:
$LN10@intTrieAdd:

; 2008 : 		}
; 2009 : 	}
; 2010 : 
; 2011 : 	/* Here we have discovered the only node that can be reached by the bits in the key
; 2012 : 	 * but we have found that this node is not the key we need to insert. We must find the
; 2013 : 	 * the leftmost bit by which the current key for that node and the new key we are going 
; 2014 : 	 * to insert, differ. While this nested series of ifs may look a bit strange, experimentation
; 2015 : 	 * showed that it allows a machine code path that works well with predicated execution
; 2016 : 	 */
; 2017 : 	xorKey = (key ^ nextNode->key);   /* Gives 1 bits only where they differ then we find the left most 1 bit*/

  00192	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00197	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0019b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  001a0	48 33 c8	 xor	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 89 44 24 50	 mov	 QWORD PTR xorKey$[rsp], rax

; 2018 : 
; 2019 : 	/* Most common case is a 32 bit key really
; 2020 : 	 */
; 2021 : #ifdef	ANTLR3_USE_64BIT
; 2022 : 	if	(xorKey & 0xFFFFFFFF00000000)

  001ab	48 b8 00 00 00
	00 ff ff ff ff	 mov	 rax, -4294967296	; ffffffff00000000H
  001b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  001ba	48 23 c8	 and	 rcx, rax
  001bd	48 8b c1	 mov	 rax, rcx
  001c0	48 85 c0	 test	 rax, rax
  001c3	0f 84 05 01 00
	00		 je	 $LN16@intTrieAdd

; 2023 : 	{
; 2024 : 		if  (xorKey & 0xFFFF000000000000)

  001c9	48 b8 00 00 00
	00 00 00 ff ff	 mov	 rax, -281474976710656	; ffff000000000000H
  001d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  001d8	48 23 c8	 and	 rcx, rax
  001db	48 8b c1	 mov	 rax, rcx
  001de	48 85 c0	 test	 rax, rax
  001e1	74 74		 je	 SHORT $LN18@intTrieAdd

; 2025 : 		{
; 2026 : 			if	(xorKey & 0xFF00000000000000)

  001e3	48 b8 00 00 00
	00 00 00 00 ff	 mov	 rax, -72057594037927936	; ff00000000000000H
  001ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  001f2	48 23 c8	 and	 rcx, rax
  001f5	48 8b c1	 mov	 rax, rcx
  001f8	48 85 c0	 test	 rax, rax
  001fb	74 2d		 je	 SHORT $LN20@intTrieAdd

; 2027 : 			{
; 2028 : 				depth = 56 + bitIndex[((xorKey & 0xFF00000000000000)>>56)];

  001fd	48 b8 00 00 00
	00 00 00 00 ff	 mov	 rax, -72057594037927936	; ff00000000000000H
  00207	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  0020c	48 23 c8	 and	 rcx, rax
  0020f	48 8b c1	 mov	 rax, rcx
  00212	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  0021d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00221	83 c0 38	 add	 eax, 56			; 00000038H
  00224	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2029 : 			}

  00228	eb 2b		 jmp	 SHORT $LN21@intTrieAdd
$LN20@intTrieAdd:

; 2030 : 			else
; 2031 : 			{
; 2032 : 				depth = 48 + bitIndex[((xorKey & 0x00FF000000000000)>>48)];

  0022a	48 b8 00 00 00
	00 00 00 ff 00	 mov	 rax, 71776119061217280	; 00ff000000000000H
  00234	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00239	48 23 c8	 and	 rcx, rax
  0023c	48 8b c1	 mov	 rax, rcx
  0023f	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  0024a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024e	83 c0 30	 add	 eax, 48			; 00000030H
  00251	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN21@intTrieAdd:

; 2033 : 			}
; 2034 : 		}

  00255	eb 72		 jmp	 SHORT $LN19@intTrieAdd
$LN18@intTrieAdd:

; 2035 : 		else
; 2036 : 		{
; 2037 : 			if	(xorKey & 0x0000FF0000000000)

  00257	48 b8 00 00 00
	00 00 ff 00 00	 mov	 rax, 280375465082880	; 0000ff0000000000H
  00261	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00266	48 23 c8	 and	 rcx, rax
  00269	48 8b c1	 mov	 rax, rcx
  0026c	48 85 c0	 test	 rax, rax
  0026f	74 2d		 je	 SHORT $LN22@intTrieAdd

; 2038 : 			{
; 2039 : 				depth = 40 + bitIndex[((xorKey & 0x0000FF0000000000)>>40)];

  00271	48 b8 00 00 00
	00 00 ff 00 00	 mov	 rax, 280375465082880	; 0000ff0000000000H
  0027b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00280	48 23 c8	 and	 rcx, rax
  00283	48 8b c1	 mov	 rax, rcx
  00286	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0028a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00291	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00295	83 c0 28	 add	 eax, 40			; 00000028H
  00298	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2040 : 			}

  0029c	eb 2b		 jmp	 SHORT $LN23@intTrieAdd
$LN22@intTrieAdd:

; 2041 : 			else
; 2042 : 			{
; 2043 : 				depth = 32 + bitIndex[((xorKey & 0x000000FF00000000)>>32)];

  0029e	48 b8 00 00 00
	00 ff 00 00 00	 mov	 rax, 1095216660480	; 000000ff00000000H
  002a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  002ad	48 23 c8	 and	 rcx, rax
  002b0	48 8b c1	 mov	 rax, rcx
  002b3	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  002be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c2	83 c0 20	 add	 eax, 32			; 00000020H
  002c5	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN23@intTrieAdd:
$LN19@intTrieAdd:

; 2044 : 			}
; 2045 : 		}
; 2046 : 	}

  002c9	e9 c2 00 00 00	 jmp	 $LN17@intTrieAdd
$LN16@intTrieAdd:

; 2047 : 	else
; 2048 : #endif
; 2049 : 	{
; 2050 : 		if  (xorKey & 0x00000000FFFF0000)

  002ce	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H
  002d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  002d8	48 23 c8	 and	 rcx, rax
  002db	48 8b c1	 mov	 rax, rcx
  002de	48 85 c0	 test	 rax, rax
  002e1	74 60		 je	 SHORT $LN24@intTrieAdd

; 2051 : 		{
; 2052 : 			if	(xorKey & 0x00000000FF000000)

  002e3	b8 00 00 00 ff	 mov	 eax, -16777216		; ff000000H
  002e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  002ed	48 23 c8	 and	 rcx, rax
  002f0	48 8b c1	 mov	 rax, rcx
  002f3	48 85 c0	 test	 rax, rax
  002f6	74 28		 je	 SHORT $LN26@intTrieAdd

; 2053 : 			{
; 2054 : 				depth = 24 + bitIndex[((xorKey & 0x00000000FF000000)>>24)];

  002f8	b8 00 00 00 ff	 mov	 eax, -16777216		; ff000000H
  002fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xorKey$[rsp]
  00302	48 23 c8	 and	 rcx, rax
  00305	48 8b c1	 mov	 rax, rcx
  00308	48 c1 e8 18	 shr	 rax, 24
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00313	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00317	83 c0 18	 add	 eax, 24
  0031a	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2055 : 			}

  0031e	eb 21		 jmp	 SHORT $LN27@intTrieAdd
$LN26@intTrieAdd:

; 2056 : 			else
; 2057 : 			{
; 2058 : 				depth = 16 + bitIndex[((xorKey & 0x0000000000FF0000)>>16)];

  00320	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  00325	48 25 00 00 ff
	00		 and	 rax, 16711680		; 00ff0000H
  0032b	48 c1 e8 10	 shr	 rax, 16
  0032f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00336	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033a	83 c0 10	 add	 eax, 16
  0033d	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN27@intTrieAdd:

; 2059 : 			}
; 2060 : 		}

  00341	eb 4d		 jmp	 SHORT $LN25@intTrieAdd
$LN24@intTrieAdd:

; 2061 : 		else
; 2062 : 		{
; 2063 : 			if	(xorKey & 0x000000000000FF00)

  00343	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  00348	48 25 00 ff 00
	00		 and	 rax, 65280		; 0000ff00H
  0034e	48 85 c0	 test	 rax, rax
  00351	74 23		 je	 SHORT $LN28@intTrieAdd

; 2064 : 			{
; 2065 : 				depth = 8 + bitIndex[((xorKey & 0x0000000000000FF00)>>8)];

  00353	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  00358	48 25 00 ff 00
	00		 and	 rax, 65280		; 0000ff00H
  0035e	48 c1 e8 08	 shr	 rax, 8
  00362	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00369	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036d	83 c0 08	 add	 eax, 8
  00370	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax

; 2066 : 			}

  00374	eb 1a		 jmp	 SHORT $LN29@intTrieAdd
$LN28@intTrieAdd:

; 2067 : 			else
; 2068 : 			{
; 2069 : 				depth = bitIndex[xorKey & 0x00000000000000FF];

  00376	48 8b 44 24 50	 mov	 rax, QWORD PTR xorKey$[rsp]
  0037b	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitIndex
  00388	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0038c	89 44 24 38	 mov	 DWORD PTR depth$[rsp], eax
$LN29@intTrieAdd:
$LN25@intTrieAdd:
$LN17@intTrieAdd:

; 2070 : 			}
; 2071 : 		}
; 2072 : 	}
; 2073 : 
; 2074 :     /* We have located the leftmost differing bit, indicated by the depth variable. So, we know what
; 2075 :      * bit index we are to insert the new entry at. There are two cases, being where the two keys
; 2076 :      * differ at a bit position that is not currently part of the bit testing, where they differ on a bit
; 2077 :      * that is currently being skipped in the indexed comparisons, and where they differ on a bit
; 2078 :      * that is merely lower down in the current bit search. If the bit index went bit 4, bit 2 and they differ
; 2079 :      * at bit 3, then we have the "skipped" bit case. But if that chain was Bit 4, Bit 2 and they differ at bit 1
; 2080 :      * then we have the easy bit <pun>.
; 2081 :      *
; 2082 :      * So, set up to descend the tree again, but this time looking for the insert point
; 2083 :      * according to whether we skip the bit that differs or not.
; 2084 :      */
; 2085 :     thisNode	= trie->root;

  00390	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00395	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00398	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 2086 :     entNode	= trie->root->leftN;

  0039d	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  003a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  003a9	48 89 44 24 30	 mov	 QWORD PTR entNode$[rsp], rax
$LN6@intTrieAdd:

; 2087 : 
; 2088 :     /* Note the slight difference in the checks here to cover both cases
; 2089 :      */
; 2090 :     while (thisNode->bitNum > entNode->bitNum && entNode->bitNum > depth)

  003ae	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  003b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entNode$[rsp]
  003b8	8b 09		 mov	 ecx, DWORD PTR [rcx]
  003ba	39 08		 cmp	 DWORD PTR [rax], ecx
  003bc	76 59		 jbe	 SHORT $LN7@intTrieAdd
  003be	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003c3	8b 4c 24 38	 mov	 ecx, DWORD PTR depth$[rsp]
  003c7	39 08		 cmp	 DWORD PTR [rax], ecx
  003c9	76 4c		 jbe	 SHORT $LN7@intTrieAdd

; 2091 :     {
; 2092 : 	/* Still descending the structure, next node becomes current.
; 2093 : 	 */
; 2094 : 	thisNode = entNode;

  003cb	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003d0	48 89 44 24 20	 mov	 QWORD PTR thisNode$[rsp], rax

; 2095 : 
; 2096 : 	if (key & bitMask[entNode->bitNum])

  003d5	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003da	8b 00		 mov	 eax, DWORD PTR [rax]
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  003e3	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  003ec	48 23 c8	 and	 rcx, rax
  003ef	48 8b c1	 mov	 rax, rcx
  003f2	48 85 c0	 test	 rax, rax
  003f5	74 10		 je	 SHORT $LN30@intTrieAdd

; 2097 : 	{
; 2098 : 	    /* Bit at the required index was 1, so traverse the right node from here
; 2099 : 	     */
; 2100 : 	    entNode = entNode->rightN;

  003f7	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  003fc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00400	48 89 44 24 30	 mov	 QWORD PTR entNode$[rsp], rax

; 2101 : 	}

  00405	eb 0e		 jmp	 SHORT $LN31@intTrieAdd
$LN30@intTrieAdd:

; 2102 : 	else
; 2103 : 	{
; 2104 : 	    /* Bit at the required index was 0, so we traverse to the left
; 2105 : 	     */
; 2106 : 	    entNode = entNode->leftN;

  00407	48 8b 44 24 30	 mov	 rax, QWORD PTR entNode$[rsp]
  0040c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00410	48 89 44 24 30	 mov	 QWORD PTR entNode$[rsp], rax
$LN31@intTrieAdd:

; 2107 : 	}
; 2108 :     }

  00415	eb 97		 jmp	 SHORT $LN6@intTrieAdd
$LN7@intTrieAdd:

; 2109 : 
; 2110 :     /* We have located the correct insert point for this new key, so we need
; 2111 :      * to allocate our entry and insert it etc.
; 2112 :      */
; 2113 :     nextNode	= (pANTLR3_INT_TRIE_NODE)ANTLR3_CALLOC(1, sizeof(ANTLR3_INT_TRIE_NODE));

  00417	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0041c	b9 01 00 00 00	 mov	 ecx, 1
  00421	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00427	48 89 44 24 28	 mov	 QWORD PTR nextNode$[rsp], rax

; 2114 :     if (nextNode == NULL)

  0042c	48 83 7c 24 28
	00		 cmp	 QWORD PTR nextNode$[rsp], 0
  00432	75 07		 jne	 SHORT $LN32@intTrieAdd

; 2115 :     {
; 2116 : 	/* All that work and no memory - bummer.
; 2117 : 	 */
; 2118 : 	return	ANTLR3_FALSE;

  00434	32 c0		 xor	 al, al
  00436	e9 45 01 00 00	 jmp	 $LN1@intTrieAdd
$LN32@intTrieAdd:

; 2119 :     }
; 2120 : 
; 2121 :     /* Build a new entry block for the new node
; 2122 :      */
; 2123 :     newEnt = (pANTLR3_TRIE_ENTRY)ANTLR3_CALLOC(1, sizeof(ANTLR3_TRIE_ENTRY));

  0043b	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00440	b9 01 00 00 00	 mov	 ecx, 1
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0044b	48 89 44 24 40	 mov	 QWORD PTR newEnt$[rsp], rax

; 2124 : 
; 2125 :     if (newEnt == NULL)

  00450	48 83 7c 24 40
	00		 cmp	 QWORD PTR newEnt$[rsp], 0
  00456	75 07		 jne	 SHORT $LN33@intTrieAdd

; 2126 :     {
; 2127 : 	/* Out of memory, all we can do is return the fact that the insert failed.
; 2128 : 	 */
; 2129 : 	return	ANTLR3_FALSE;

  00458	32 c0		 xor	 al, al
  0045a	e9 21 01 00 00	 jmp	 $LN1@intTrieAdd
$LN33@intTrieAdd:

; 2130 :     }
; 2131 : 
; 2132 :     /* Otherwise enter this in our new node
; 2133 :     */
; 2134 :     newEnt->type	= type;

  0045f	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00464	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR type$[rsp]
  0046b	89 08		 mov	 DWORD PTR [rax], ecx

; 2135 :     newEnt->freeptr	= freeptr;

  0046d	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  00472	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR freeptr$[rsp]
  0047a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2136 :     if (type == ANTLR3_HASH_TYPE_STR)

  0047e	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00486	75 13		 jne	 SHORT $LN34@intTrieAdd

; 2137 :     {
; 2138 : 	newEnt->data.ptr = data;

  00488	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  0048d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00495	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2139 :     }

  00499	eb 11		 jmp	 SHORT $LN35@intTrieAdd
$LN34@intTrieAdd:

; 2140 :     else
; 2141 :     {
; 2142 : 	newEnt->data.intVal = intVal;

  0049b	48 8b 44 24 40	 mov	 rax, QWORD PTR newEnt$[rsp]
  004a0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR intVal$[rsp]
  004a8	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN35@intTrieAdd:

; 2143 :     }
; 2144 :     /* Install it
; 2145 :      */
; 2146 :     nextNode->buckets	= newEnt;

  004ac	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newEnt$[rsp]
  004b6	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2147 :     nextNode->key	= key;

  004ba	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  004c4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2148 :     nextNode->bitNum	= depth;

  004c8	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004cd	8b 4c 24 38	 mov	 ecx, DWORD PTR depth$[rsp]
  004d1	89 08		 mov	 DWORD PTR [rax], ecx

; 2149 : 
; 2150 :     /* Work out the right and left pointers for this new node, which involve
; 2151 :      * terminating with the current found node either right or left according
; 2152 :      * to whether the current index bit is 1 or 0
; 2153 :      */
; 2154 :     if (key & bitMask[depth])

  004d3	8b 44 24 38	 mov	 eax, DWORD PTR depth$[rsp]
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  004de	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  004e2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  004e7	48 23 c8	 and	 rcx, rax
  004ea	48 8b c1	 mov	 rax, rcx
  004ed	48 85 c0	 test	 rax, rax
  004f0	74 1e		 je	 SHORT $LN36@intTrieAdd

; 2155 :     {
; 2156 : 	nextNode->leftN	    = entNode;	    /* Terminates at previous position	*/

  004f2	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  004f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entNode$[rsp]
  004fc	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2157 : 	nextNode->rightN    = nextNode;	    /* Terminates with itself		*/

  00500	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00505	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  0050a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2158 :     }

  0050e	eb 1c		 jmp	 SHORT $LN37@intTrieAdd
$LN36@intTrieAdd:

; 2159 :     else
; 2160 :     {
; 2161 : 	nextNode->rightN   = entNode;	    /* Terminates at previous position	*/

  00510	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00515	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entNode$[rsp]
  0051a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2162 : 	nextNode->leftN    = nextNode;	    /* Terminates with itself		*/		

  0051e	48 8b 44 24 28	 mov	 rax, QWORD PTR nextNode$[rsp]
  00523	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  00528	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN37@intTrieAdd:

; 2163 :     }
; 2164 : 
; 2165 :     /* Finally, we need to change the pointers at the node we located
; 2166 :      * for inserting. If the key bit at its index is set then the right
; 2167 :      * pointer for that node becomes the newly created node, otherwise the left 
; 2168 :      * pointer does.
; 2169 :      */
; 2170 :     if (key & bitMask[thisNode->bitNum] )

  0052c	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  00531	8b 00		 mov	 eax, DWORD PTR [rax]
  00533	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  0053a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0053e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  00543	48 23 c8	 and	 rcx, rax
  00546	48 8b c1	 mov	 rax, rcx
  00549	48 85 c0	 test	 rax, rax
  0054c	74 10		 je	 SHORT $LN38@intTrieAdd

; 2171 :     {
; 2172 : 	thisNode->rightN    = nextNode;

  0054e	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  00553	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  00558	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 2173 :     }

  0055c	eb 0e		 jmp	 SHORT $LN39@intTrieAdd
$LN38@intTrieAdd:

; 2174 :     else
; 2175 :     {
; 2176 : 	thisNode->leftN	    = nextNode;

  0055e	48 8b 44 24 20	 mov	 rax, QWORD PTR thisNode$[rsp]
  00563	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nextNode$[rsp]
  00568	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
$LN39@intTrieAdd:

; 2177 :     }
; 2178 : 
; 2179 :     /* Et voila
; 2180 :      */
; 2181 :     trie->count++;

  0056c	48 8b 44 24 70	 mov	 rax, QWORD PTR trie$[rsp]
  00571	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00574	ff c0		 inc	 eax
  00576	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trie$[rsp]
  0057b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2182 :     return  ANTLR3_TRUE;

  0057e	b0 01		 mov	 al, 1
$LN1@intTrieAdd:

; 2183 : 
; 2184 : }

  00580	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00584	5f		 pop	 rdi
  00585	c3		 ret	 0
intTrieAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieDel
_TEXT	SEGMENT
p$ = 0
trie$ = 32
key$ = 40
intTrieDel PROC						; COMDAT

; 1892 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 1893 :     pANTLR3_INT_TRIE_NODE   p;
; 1894 : 
; 1895 :     p=trie->root;

  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 89 04 24	 mov	 QWORD PTR p$[rsp], rax

; 1896 :     key = key;

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR key$[rsp]
  00020	48 89 44 24 28	 mov	 QWORD PTR key$[rsp], rax

; 1897 : 
; 1898 :     return ANTLR3_FALSE;

  00025	32 c0		 xor	 al, al

; 1899 : }

  00027	48 83 c4 10	 add	 rsp, 16
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
intTrieDel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT intTrieGet
_TEXT	SEGMENT
thisNode$ = 0
nextNode$ = 8
trie$ = 32
key$ = 40
intTrieGet PROC						; COMDAT

; 1822 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 1823 : 	pANTLR3_INT_TRIE_NODE    thisNode; 
; 1824 : 	pANTLR3_INT_TRIE_NODE    nextNode; 
; 1825 : 
; 1826 : 	if (trie->count == 0)

  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00014	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00018	75 07		 jne	 SHORT $LN4@intTrieGet

; 1827 : 	{
; 1828 : 		return NULL;	    /* Nothing in this trie yet	*/

  0001a	33 c0		 xor	 eax, eax
  0001c	e9 92 00 00 00	 jmp	 $LN1@intTrieGet
$LN4@intTrieGet:

; 1829 : 	}
; 1830 : 	/* Starting at the root node in the trie, compare the bit index
; 1831 : 	 * of the current node with its next child node (starts left from root).
; 1832 : 	 * When the bit index of the child node is greater than the bit index of the current node
; 1833 : 	 * then by definition (as the bit index decreases as we descent the trie)
; 1834 : 	 * we have reached a 'backward' pointer. A backward pointer means we
; 1835 : 	 * have reached the only node that can be reached by the bits given us so far
; 1836 : 	 * and it must either be the key we are looking for, or if not then it
; 1837 : 	 * means the entry was not in the trie, and we return NULL. A backward pointer
; 1838 : 	 * points back in to the tree structure rather than down (deeper) within the
; 1839 : 	 * tree branches.
; 1840 : 	 */
; 1841 : 	thisNode	= trie->root;		/* Start at the root node		*/

  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 04 24	 mov	 QWORD PTR thisNode$[rsp], rax

; 1842 : 	nextNode	= thisNode->leftN;	/* Examine the left node from the root	*/

  0002d	48 8b 04 24	 mov	 rax, QWORD PTR thisNode$[rsp]
  00031	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00035	48 89 44 24 08	 mov	 QWORD PTR nextNode$[rsp], rax
$LN2@intTrieGet:

; 1843 : 
; 1844 : 	/* While we are descending the tree nodes...
; 1845 : 	 */
; 1846 : 	while (thisNode->bitNum > nextNode->bitNum)

  0003a	48 8b 04 24	 mov	 rax, QWORD PTR thisNode$[rsp]
  0003e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR nextNode$[rsp]
  00043	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00045	39 08		 cmp	 DWORD PTR [rax], ecx
  00047	76 4b		 jbe	 SHORT $LN3@intTrieGet

; 1847 : 	{
; 1848 : 		/* Next node now becomes the new 'current' node
; 1849 : 		 */
; 1850 : 		thisNode    = nextNode;

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  0004e	48 89 04 24	 mov	 QWORD PTR thisNode$[rsp], rax

; 1851 : 
; 1852 : 		/* We now test the bit indicated by the bitmap in the next node
; 1853 : 		 * in the key we are searching for. The new next node is the
; 1854 : 		 * right node if that bit is set and the left node it is not.
; 1855 : 		 */
; 1856 : 		if (key & bitMask[nextNode->bitNum])

  00052	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  00057	8b 00		 mov	 eax, DWORD PTR [rax]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bitMask
  00060	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR key$[rsp]
  00069	48 23 c8	 and	 rcx, rax
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 85 c0	 test	 rax, rax
  00072	74 10		 je	 SHORT $LN5@intTrieGet

; 1857 : 		{
; 1858 : 			nextNode = nextNode->rightN;	/* 1 is right	*/

  00074	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  00079	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007d	48 89 44 24 08	 mov	 QWORD PTR nextNode$[rsp], rax

; 1859 : 		}

  00082	eb 0e		 jmp	 SHORT $LN6@intTrieGet
$LN5@intTrieGet:

; 1860 : 		else
; 1861 : 		{
; 1862 : 			nextNode = nextNode->leftN;		/* 0 is left	*/

  00084	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  00089	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008d	48 89 44 24 08	 mov	 QWORD PTR nextNode$[rsp], rax
$LN6@intTrieGet:

; 1863 : 		}
; 1864 : 	}

  00092	eb a6		 jmp	 SHORT $LN2@intTrieGet
$LN3@intTrieGet:

; 1865 : 
; 1866 : 	/* Here we have reached a node where the bitMap index is lower than
; 1867 : 	 * its parent. This means it is pointing backward in the tree and
; 1868 : 	 * must therefore be a terminal node, being the only point than can
; 1869 : 	 * be reached with the bits seen so far. It is either the actual key
; 1870 : 	 * we wanted, or if that key is not in the trie it is another key
; 1871 : 	 * that is currently the only one that can be reached by those bits.
; 1872 : 	 * That situation would obviously change if the key was to be added
; 1873 : 	 * to the trie.
; 1874 : 	 *
; 1875 : 	 * Hence it only remains to test whether this is actually the key or not.
; 1876 : 	 */
; 1877 : 	if (nextNode->key == key)

  00094	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  00099	48 8b 4c 24 28	 mov	 rcx, QWORD PTR key$[rsp]
  0009e	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000a2	75 0d		 jne	 SHORT $LN7@intTrieGet

; 1878 : 	{
; 1879 : 		/* This was the key, so return the entry pointer
; 1880 : 		 */
; 1881 : 		return	nextNode->buckets;

  000a4	48 8b 44 24 08	 mov	 rax, QWORD PTR nextNode$[rsp]
  000a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ad	eb 04		 jmp	 SHORT $LN1@intTrieGet

; 1882 : 	}

  000af	eb 02		 jmp	 SHORT $LN8@intTrieGet
$LN7@intTrieGet:

; 1883 : 	else
; 1884 : 	{
; 1885 : 		return	NULL;	/* That key is not in the trie (note that we set the pointer to -1 if no payload) */

  000b1	33 c0		 xor	 eax, eax
$LN8@intTrieGet:
$LN1@intTrieGet:

; 1886 : 	}
; 1887 : }

  000b3	48 83 c4 10	 add	 rsp, 16
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
intTrieGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT returnVector
_TEXT	SEGMENT
factory$ = 48
vector$ = 56
returnVector PROC					; COMDAT

; 1479 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1480 : 	// First we need to clear out anything that is still in the vector
; 1481 : 	//
; 1482 : 	vector->clear(vector);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vector$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR vector$[rsp]
  00019	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 1483 : 
; 1484 : 	// We have a free stack available so we can add the vector we were
; 1485 : 	// given into the free chain. The vector has to have come from this
; 1486 : 	// factory, so we already know how to release its memory when it
; 1487 : 	// dies by virtue of the factory being closed.
; 1488 : 	//
; 1489 : 	factory->freeStack->push(factory->freeStack, vector, NULL);

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00024	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  0002b	45 33 c0	 xor	 r8d, r8d
  0002e	48 8b 54 24 38	 mov	 rdx, QWORD PTR vector$[rsp]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00038	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  0003f	ff 50 28	 call	 QWORD PTR [rax+40]

; 1490 : 
; 1491 : 	// TODO: remove this line once happy printf("Returned vector %08X to the pool, stack size is %d\n", vector, factory->freeStack->size(factory->freeStack));
; 1492 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
returnVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT newVector
_TEXT	SEGMENT
vector$ = 32
factory$ = 64
newVector PROC						; COMDAT

; 1639 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1640 :     pANTLR3_VECTOR vector;
; 1641 : 
; 1642 : 	// If we have anything on the re claim stack, reuse it
; 1643 : 	//
; 1644 : 	vector = factory->freeStack->peek(factory->freeStack);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0001b	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  00022	ff 50 38	 call	 QWORD PTR [rax+56]
  00025	48 89 44 24 20	 mov	 QWORD PTR vector$[rsp], rax

; 1645 : 
; 1646 : 	if  (vector != NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR vector$[rsp], 0
  00030	74 25		 je	 SHORT $LN2@newVector

; 1647 : 	{
; 1648 : 		// Cool we got something we could reuse
; 1649 : 		//
; 1650 : 		factory->freeStack->pop(factory->freeStack);

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00037	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00043	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  0004a	ff 50 18	 call	 QWORD PTR [rax+24]

; 1651 : 
; 1652 : 		// TODO: remove this line once happy printf("Reused vector %08X from stack, size is now %d\n", vector, factory->freeStack->size(factory->freeStack));
; 1653 : 		return vector;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  00052	e9 87 00 00 00	 jmp	 $LN1@newVector
$LN2@newVector:

; 1654 : 
; 1655 : 	}
; 1656 : 
; 1657 : 	// See if we need a new vector pool before allocating a new
; 1658 :     // one
; 1659 :     //
; 1660 :     if (factory->nextVector >= ANTLR3_FACTORY_VPOOL_SIZE)

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0005c	81 78 0c 00 01
	00 00		 cmp	 DWORD PTR [rax+12], 256	; 00000100H
  00063	72 0a		 jb	 SHORT $LN3@newVector

; 1661 :     {
; 1662 :         // We ran out of vectors in the current pool, so we need a new pool
; 1663 :         //
; 1664 :         newPool(factory);

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0006a	e8 00 00 00 00	 call	 newPool
$LN3@newVector:

; 1665 :     }
; 1666 : 
; 1667 :     // Assuming everything went well (we are trying for performance here so doing minimal
; 1668 :     // error checking. Then we can work out what the pointer is to the next vector.
; 1669 :     //
; 1670 :     vector = factory->pools[factory->thisPool] + factory->nextVector;

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00074	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0007d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00080	48 8b 54 24 40	 mov	 rdx, QWORD PTR factory$[rsp]
  00085	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  00088	48 69 d2 60 01
	00 00		 imul	 rdx, rdx, 352		; 00000160H
  0008f	48 03 14 c1	 add	 rdx, QWORD PTR [rcx+rax*8]
  00093	48 8b c2	 mov	 rax, rdx
  00096	48 89 44 24 20	 mov	 QWORD PTR vector$[rsp], rax

; 1671 :     factory->nextVector++;

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000a0	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000a3	ff c0		 inc	 eax
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000aa	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1672 : 
; 1673 :     // We have our token pointer now, so we can initialize it to the predefined model.
; 1674 :     //
; 1675 :     antlr3SetVectorApi(vector, ANTLR3_VECTOR_INTERNAL_SIZE);

  000ad	ba 10 00 00 00	 mov	 edx, 16
  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000b7	e8 00 00 00 00	 call	 antlr3SetVectorApi

; 1676 :     vector->factoryMade = ANTLR3_TRUE;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  000c1	c6 80 10 01 00
	00 01		 mov	 BYTE PTR [rax+272], 1

; 1677 : 
; 1678 :     // We know that the pool vectors are created at the default size, which means they
; 1679 :     // will start off using their internal entry pointers. We must intialize our pool vector
; 1680 :     // to point to its own internal entry table and not the pre-made one.
; 1681 :     //
; 1682 :     vector->elements = vector->internal;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  000cd	48 83 c0 10	 add	 rax, 16
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000d6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1683 : 
; 1684 : 		// TODO: remove this line once happy printf("Used a new vector at %08X from the pools as nothing on the reusue stack\n", vector);
; 1685 : 
; 1686 :     // And we are done
; 1687 :     //
; 1688 :     return vector;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
$LN1@newVector:

; 1689 : }

  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
newVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT closeVectorFactory
_TEXT	SEGMENT
pool$ = 32
poolCount$ = 40
limit$ = 44
vector$ = 48
check$ = 56
tv80 = 64
tv131 = 68
factory$ = 96
closeVectorFactory PROC					; COMDAT

; 1526 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1527 :     pANTLR3_VECTOR      pool;
; 1528 :     ANTLR3_INT32        poolCount;
; 1529 :     ANTLR3_UINT32       limit;
; 1530 :     ANTLR3_UINT32       vector;
; 1531 :     pANTLR3_VECTOR      check;
; 1532 : 
; 1533 : 	// First see if we have a free chain stack to release?
; 1534 : 	//
; 1535 : 	if	(factory->freeStack != NULL)

  0000a	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	48 83 b8 70 01
	00 00 00	 cmp	 QWORD PTR [rax+368], 0
  00017	74 1b		 je	 SHORT $LN14@closeVecto

; 1536 : 	{
; 1537 : 		factory->freeStack->free(factory->freeStack);

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0001e	48 8b 80 70 01
	00 00		 mov	 rax, QWORD PTR [rax+368]
  00025	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0002a	48 8b 89 70 01
	00 00		 mov	 rcx, QWORD PTR [rcx+368]
  00031	ff 50 10	 call	 QWORD PTR [rax+16]
$LN14@closeVecto:

; 1538 : 	}
; 1539 : 
; 1540 :     /* We iterate the vector pools one at a time
; 1541 :      */
; 1542 :     for (poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  00034	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  0003c	eb 0a		 jmp	 SHORT $LN4@closeVecto
$LN2@closeVecto:
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR poolCount$[rsp]
  00042	ff c0		 inc	 eax
  00044	89 44 24 28	 mov	 DWORD PTR poolCount$[rsp], eax
$LN4@closeVecto:
  00048	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0004d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00050	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00054	0f 8f 99 00 00
	00		 jg	 $LN3@closeVecto

; 1543 :     {
; 1544 :         /* Pointer to current pool
; 1545 :          */
; 1546 :         pool = factory->pools[poolCount];

  0005a	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  0005f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  00064	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00067	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0006b	48 89 44 24 20	 mov	 QWORD PTR pool$[rsp], rax

; 1547 : 
; 1548 :         /* Work out how many tokens we need to check in this pool.
; 1549 :          */
; 1550 :         limit = (poolCount == factory->thisPool ? factory->nextVector : ANTLR3_FACTORY_VPOOL_SIZE);

  00070	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00075	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00078	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  0007c	75 0e		 jne	 SHORT $LN19@closeVecto
  0007e	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00083	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00086	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  0008a	eb 08		 jmp	 SHORT $LN20@closeVecto
$LN19@closeVecto:
  0008c	c7 44 24 40 00
	01 00 00	 mov	 DWORD PTR tv80[rsp], 256 ; 00000100H
$LN20@closeVecto:
  00094	8b 44 24 40	 mov	 eax, DWORD PTR tv80[rsp]
  00098	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 1551 : 
; 1552 :         /* Marginal condition, we might be at the start of a brand new pool
; 1553 :          * where the nextToken is 0 and nothing has been allocated.
; 1554 :          */
; 1555 :         if (limit > 0)

  0009c	83 7c 24 2c 00	 cmp	 DWORD PTR limit$[rsp], 0
  000a1	76 4b		 jbe	 SHORT $LN15@closeVecto

; 1556 :         {
; 1557 :             /* We have some vectors allocated from this pool
; 1558 :              */
; 1559 :             for (vector = 0; vector < limit; vector++)

  000a3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR vector$[rsp], 0
  000ab	eb 0a		 jmp	 SHORT $LN7@closeVecto
$LN5@closeVecto:
  000ad	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  000b1	ff c0		 inc	 eax
  000b3	89 44 24 30	 mov	 DWORD PTR vector$[rsp], eax
$LN7@closeVecto:
  000b7	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  000bb	39 44 24 30	 cmp	 DWORD PTR vector$[rsp], eax
  000bf	73 2d		 jae	 SHORT $LN6@closeVecto

; 1560 :             {
; 1561 :                 /* Next one in the chain
; 1562 :                  */
; 1563 :                 check = pool + vector;

  000c1	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  000c5	48 69 c0 60 01
	00 00		 imul	 rax, rax, 352		; 00000160H
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pool$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 38	 mov	 QWORD PTR check$[rsp], rax

; 1564 : 
; 1565 :                 // Call the free function on each of the vectors in the pool,
; 1566 :                 // which in turn will cause any elements it holds that also have a free
; 1567 :                 // pointer to be freed. However, because any vector may be in any other
; 1568 :                 // vector, we don't free the element allocations yet. We do that in a
; 1569 :                 // a specific pass, coming up next. The vector free function knows that
; 1570 :                 // this is a factory allocated pool vector and so it won't free things it
; 1571 :                 // should not.
; 1572 :                 //
; 1573 :                 check->free(check);

  000dc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR check$[rsp]
  000e1	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000e6	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 1574 :             }

  000ec	eb bf		 jmp	 SHORT $LN5@closeVecto
$LN6@closeVecto:
$LN15@closeVecto:

; 1575 :         }
; 1576 :     }

  000ee	e9 4b ff ff ff	 jmp	 $LN2@closeVecto
$LN3@closeVecto:

; 1577 : 
; 1578 :     /* We iterate the vector pools one at a time once again, but this time
; 1579 :      * we are going to free up any allocated element pointers. Note that we are doing this
; 1580 :      * so that we do not try to release vectors twice. When building ASTs we just copy
; 1581 :      * the vectors all over the place and they may be embedded in this vector pool
; 1582 :      * numerous times.
; 1583 :      */
; 1584 :     for (poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  000f3	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  000fb	eb 0a		 jmp	 SHORT $LN10@closeVecto
$LN8@closeVecto:
  000fd	8b 44 24 28	 mov	 eax, DWORD PTR poolCount$[rsp]
  00101	ff c0		 inc	 eax
  00103	89 44 24 28	 mov	 DWORD PTR poolCount$[rsp], eax
$LN10@closeVecto:
  00107	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0010c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010f	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00113	0f 8f ee 00 00
	00		 jg	 $LN9@closeVecto

; 1585 :     {
; 1586 :         /* Pointer to current pool
; 1587 :          */
; 1588 :         pool = factory->pools[poolCount];

  00119	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  0011e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  00123	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00126	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0012a	48 89 44 24 20	 mov	 QWORD PTR pool$[rsp], rax

; 1589 : 
; 1590 :         /* Work out how many tokens we need to check in this pool.
; 1591 :          */
; 1592 :         limit = (poolCount == factory->thisPool ? factory->nextVector : ANTLR3_FACTORY_VPOOL_SIZE);

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00134	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00137	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  0013b	75 0e		 jne	 SHORT $LN21@closeVecto
  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00142	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00145	89 44 24 44	 mov	 DWORD PTR tv131[rsp], eax
  00149	eb 08		 jmp	 SHORT $LN22@closeVecto
$LN21@closeVecto:
  0014b	c7 44 24 44 00
	01 00 00	 mov	 DWORD PTR tv131[rsp], 256 ; 00000100H
$LN22@closeVecto:
  00153	8b 44 24 44	 mov	 eax, DWORD PTR tv131[rsp]
  00157	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 1593 : 
; 1594 :         /* Marginal condition, we might be at the start of a brand new pool
; 1595 :          * where the nextToken is 0 and nothing has been allocated.
; 1596 :          */
; 1597 :         if (limit > 0)

  0015b	83 7c 24 2c 00	 cmp	 DWORD PTR limit$[rsp], 0
  00160	76 74		 jbe	 SHORT $LN16@closeVecto

; 1598 :         {
; 1599 :             /* We have some vectors allocated from this pool
; 1600 :              */
; 1601 :             for (vector = 0; vector < limit; vector++)

  00162	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR vector$[rsp], 0
  0016a	eb 0a		 jmp	 SHORT $LN13@closeVecto
$LN11@closeVecto:
  0016c	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  00170	ff c0		 inc	 eax
  00172	89 44 24 30	 mov	 DWORD PTR vector$[rsp], eax
$LN13@closeVecto:
  00176	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  0017a	39 44 24 30	 cmp	 DWORD PTR vector$[rsp], eax
  0017e	73 56		 jae	 SHORT $LN12@closeVecto

; 1602 :             {
; 1603 :                 /* Next one in the chain
; 1604 :                  */
; 1605 :                 check = pool + vector;

  00180	8b 44 24 30	 mov	 eax, DWORD PTR vector$[rsp]
  00184	48 69 c0 60 01
	00 00		 imul	 rax, rax, 352		; 00000160H
  0018b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pool$[rsp]
  00190	48 03 c8	 add	 rcx, rax
  00193	48 8b c1	 mov	 rax, rcx
  00196	48 89 44 24 38	 mov	 QWORD PTR check$[rsp], rax

; 1606 : 
; 1607 :                 // Anything in here should be factory made, but we do this just
; 1608 :                 // to triple check. We just free up the elements if they were
; 1609 :                 // allocated beyond the internal size.
; 1610 :                 //
; 1611 :                 if (check->factoryMade == ANTLR3_TRUE && check->elementsSize > ANTLR3_VECTOR_INTERNAL_SIZE)

  0019b	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001a0	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  001a7	83 f8 01	 cmp	 eax, 1
  001aa	75 28		 jne	 SHORT $LN17@closeVecto
  001ac	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001b1	83 b8 14 01 00
	00 10		 cmp	 DWORD PTR [rax+276], 16
  001b8	76 1a		 jbe	 SHORT $LN17@closeVecto

; 1612 :                 {
; 1613 :                     ANTLR3_FREE(check->elements);

  001ba	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001bf	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1614 :                     check->elements = NULL;

  001c8	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  001cd	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN17@closeVecto:

; 1615 :                 }
; 1616 :             }

  001d4	eb 96		 jmp	 SHORT $LN11@closeVecto
$LN12@closeVecto:
$LN16@closeVecto:

; 1617 :         }
; 1618 : 
; 1619 :         // We can now free this pool allocation as we have called free on every element in every vector
; 1620 :         // and freed any memory for pointers the grew beyond the internal size limit.
; 1621 :         //
; 1622 :         ANTLR3_FREE(factory->pools[poolCount]);

  001d6	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  001db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  001e0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001e3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1623 :         factory->pools[poolCount] = NULL;

  001ed	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  001f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  001f7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001fa	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 1624 :     }

  00202	e9 f6 fe ff ff	 jmp	 $LN8@closeVecto
$LN9@closeVecto:

; 1625 : 
; 1626 :     /* All the pools are deallocated we can free the pointers to the pools
; 1627 :      * now.
; 1628 :      */
; 1629 :     ANTLR3_FREE(factory->pools);

  00207	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0020c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1630 : 
; 1631 :     /* Finally, we can free the space for the factory itself
; 1632 :      */
; 1633 :     ANTLR3_FREE(factory);

  00215	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1634 : 
; 1635 : }

  00220	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00224	5f		 pop	 rdi
  00225	c3		 ret	 0
closeVectorFactory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT newPool
_TEXT	SEGMENT
factory$ = 48
newPool	PROC						; COMDAT

; 1496 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1497 :     /* Increment factory count
; 1498 :      */
; 1499 :     factory->thisPool++;

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	ff c0		 inc	 eax
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00019	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1500 : 
; 1501 :     /* Ensure we have enough pointers allocated
; 1502 :      */
; 1503 :     factory->pools = (pANTLR3_VECTOR *)

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	ff c0		 inc	 eax
  00026	48 98		 cdqe
  00028	48 c1 e0 03	 shl	 rax, 3
  0002c	8b c0		 mov	 eax, eax
  0002e	8b d0		 mov	 edx, eax
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00043	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1504 : 		     ANTLR3_REALLOC(	(void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
; 1505 : 					(ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_VECTOR *))	/* Memory for new pool pointers */
; 1506 : 					);
; 1507 : 
; 1508 :     /* Allocate a new pool for the factory
; 1509 :      */
; 1510 :     factory->pools[factory->thisPool]	=

  00046	b9 00 60 01 00	 mov	 ecx, 90112		; 00016000H
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00056	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  0005a	48 8b 54 24 30	 mov	 rdx, QWORD PTR factory$[rsp]
  0005f	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00062	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 1511 : 			    (pANTLR3_VECTOR)
; 1512 : 				ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR) * ANTLR3_FACTORY_VPOOL_SIZE));
; 1513 : 
; 1514 : 
; 1515 :     /* Reset the counters
; 1516 :      */
; 1517 :     factory->nextVector	= 0;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0006b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 1518 : 
; 1519 :     /* Done
; 1520 :      */
; 1521 :     return;
; 1522 : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
newPool	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorSwap
_TEXT	SEGMENT
tempEntry$ = 0
freeptr$ = 8
vector$ = 32
entry1$ = 40
entry2$ = 48
antlr3VectorSwap PROC					; COMDAT

; 1394 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 10	 sub	 rsp, 16

; 1395 : 
; 1396 :     void               * tempEntry;
; 1397 :     void (ANTLR3_CDECL *freeptr)(void *);
; 1398 : 
; 1399 : 	// If the vector is currently not big enough, then we do nothing
; 1400 : 	//
; 1401 : 	if (entry1 >= vector->elementsSize || entry2 >= vector->elementsSize)

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  00018	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  0001e	39 44 24 28	 cmp	 DWORD PTR entry1$[rsp], eax
  00022	73 11		 jae	 SHORT $LN3@antlr3Vect
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
  00029	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  0002f	39 44 24 30	 cmp	 DWORD PTR entry2$[rsp], eax
  00033	72 07		 jb	 SHORT $LN2@antlr3Vect
$LN3@antlr3Vect:

; 1402 : 	{
; 1403 :         return ANTLR3_FALSE;

  00035	32 c0		 xor	 al, al
  00037	e9 b8 00 00 00	 jmp	 $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1404 : 	}
; 1405 : 
; 1406 : 	// Valid request, swap them
; 1407 : 	//
; 1408 :     tempEntry   = vector->elements[entry1].element;

  0003c	8b 44 24 28	 mov	 eax, DWORD PTR entry1$[rsp]
  00040	48 6b c0 10	 imul	 rax, rax, 16
  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  00049	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00050	48 89 04 24	 mov	 QWORD PTR tempEntry$[rsp], rax

; 1409 :     freeptr     = vector->elements[entry1].freeptr;

  00054	8b 44 24 28	 mov	 eax, DWORD PTR entry1$[rsp]
  00058	48 6b c0 10	 imul	 rax, rax, 16
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  00061	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00064	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00069	48 89 44 24 08	 mov	 QWORD PTR freeptr$[rsp], rax

; 1410 : 
; 1411 : 	// Install the new pointers
; 1412 : 	//
; 1413 :     vector->elements[entry1].freeptr	= vector->elements[entry2].freeptr;

  0006e	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  00072	48 6b c0 10	 imul	 rax, rax, 16
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  0007b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007e	8b 54 24 28	 mov	 edx, DWORD PTR entry1$[rsp]
  00082	48 6b d2 10	 imul	 rdx, rdx, 16
  00086	4c 8b 44 24 20	 mov	 r8, QWORD PTR vector$[rsp]
  0008b	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0008e	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00093	49 89 44 10 08	 mov	 QWORD PTR [r8+rdx+8], rax

; 1414 : 	vector->elements[entry1].element	= vector->elements[entry2].element;

  00098	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  0009c	48 6b c0 10	 imul	 rax, rax, 16
  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000a5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a8	8b 54 24 28	 mov	 edx, DWORD PTR entry1$[rsp]
  000ac	48 6b d2 10	 imul	 rdx, rdx, 16
  000b0	4c 8b 44 24 20	 mov	 r8, QWORD PTR vector$[rsp]
  000b5	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000b8	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000bc	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax

; 1415 : 
; 1416 : 	vector->elements[entry2].freeptr	= freeptr;

  000c0	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  000c4	48 6b c0 10	 imul	 rax, rax, 16
  000c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000cd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d0	48 8b 54 24 08	 mov	 rdx, QWORD PTR freeptr$[rsp]
  000d5	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1417 : 	vector->elements[entry2].element	= tempEntry;

  000da	8b 44 24 30	 mov	 eax, DWORD PTR entry2$[rsp]
  000de	48 6b c0 10	 imul	 rax, rax, 16
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  000e7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ea	48 8b 14 24	 mov	 rdx, QWORD PTR tempEntry$[rsp]
  000ee	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1418 : 
; 1419 : 	return  ANTLR3_TRUE;

  000f2	b0 01		 mov	 al, 1
$LN1@antlr3Vect:

; 1420 : 
; 1421 : }

  000f4	48 83 c4 10	 add	 rsp, 16
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
antlr3VectorSwap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorSize
_TEXT	SEGMENT
vector$ = 16
antlr3VectorSize PROC					; COMDAT

; 1424 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1425 :     return  vector->count;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR vector$[rsp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 1426 : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr3VectorSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorSet
_TEXT	SEGMENT
vector$ = 48
entry$ = 56
element$ = 64
freeptr$ = 72
freeExisting$ = 80
antlr3VectorSet PROC					; COMDAT

; 1357 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1358 : 
; 1359 : 	// If the vector is currently not big enough, then we expand it
; 1360 : 	//
; 1361 : 	if (entry >= vector->elementsSize)

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0001d	8b 80 14 01 00
	00		 mov	 eax, DWORD PTR [rax+276]
  00023	39 44 24 38	 cmp	 DWORD PTR entry$[rsp], eax
  00027	72 0e		 jb	 SHORT $LN2@antlr3Vect

; 1362 : 	{
; 1363 : 		antlr3VectorResize(vector, entry);	// We will get at least this many 

  00029	8b 54 24 38	 mov	 edx, DWORD PTR entry$[rsp]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00032	e8 00 00 00 00	 call	 antlr3VectorResize
$LN2@antlr3Vect:

; 1364 : 	}
; 1365 : 
; 1366 : 	// Valid request, replace the current one, freeing any prior entry if told to
; 1367 : 	//
; 1368 : 	if	(		entry < vector->count						// If actually replacing an element
; 1369 : 			&&	freeExisting								// And told to free any existing element
; 1370 : 			&&	vector->elements[entry].freeptr != NULL		// And the existing element has a free pointer

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0003c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003f	39 44 24 38	 cmp	 DWORD PTR entry$[rsp], eax
  00043	73 4a		 jae	 SHORT $LN3@antlr3Vect
  00045	0f b6 44 24 50	 movzx	 eax, BYTE PTR freeExisting$[rsp]
  0004a	85 c0		 test	 eax, eax
  0004c	74 41		 je	 SHORT $LN3@antlr3Vect
  0004e	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  00052	48 6b c0 10	 imul	 rax, rax, 16
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  0005b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005e	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00064	74 29		 je	 SHORT $LN3@antlr3Vect

; 1371 : 		)
; 1372 : 	{
; 1373 : 		vector->elements[entry].freeptr(vector->elements[entry].element);

  00066	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  0006a	48 6b c0 10	 imul	 rax, rax, 16
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00073	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00076	8b 54 24 38	 mov	 edx, DWORD PTR entry$[rsp]
  0007a	48 6b d2 10	 imul	 rdx, rdx, 16
  0007e	4c 8b 44 24 30	 mov	 r8, QWORD PTR vector$[rsp]
  00083	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00086	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0008a	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]
$LN3@antlr3Vect:

; 1374 : 	}
; 1375 : 
; 1376 : 	// Install the new pointers
; 1377 : 	//
; 1378 : 	vector->elements[entry].freeptr	= freeptr;

  0008f	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  00093	48 6b c0 10	 imul	 rax, rax, 16
  00097	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  0009c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009f	48 8b 54 24 48	 mov	 rdx, QWORD PTR freeptr$[rsp]
  000a4	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1379 : 	vector->elements[entry].element	= element;

  000a9	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  000ad	48 6b c0 10	 imul	 rax, rax, 16
  000b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  000b6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b9	48 8b 54 24 40	 mov	 rdx, QWORD PTR element$[rsp]
  000be	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1380 : 
; 1381 : 	if (entry >= vector->count)

  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  000c7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ca	39 44 24 38	 cmp	 DWORD PTR entry$[rsp], eax
  000ce	72 0e		 jb	 SHORT $LN4@antlr3Vect

; 1382 : 	{
; 1383 : 		vector->count = entry + 1;

  000d0	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]
  000d4	ff c0		 inc	 eax
  000d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  000db	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN4@antlr3Vect:

; 1384 : 	}
; 1385 : 	return  (ANTLR3_UINT32)(entry);	    // Indicates the replacement was successful

  000de	8b 44 24 38	 mov	 eax, DWORD PTR entry$[rsp]

; 1386 : 
; 1387 : }

  000e2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
antlr3VectorSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorAdd
_TEXT	SEGMENT
vector$ = 48
element$ = 56
freeptr$ = 64
antlr3VectorAdd PROC					; COMDAT

; 1333 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1334 : 	// Do we need to resize the vector table?
; 1335 : 	//
; 1336 : 	if	(vector->count == vector->elementsSize)

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  0001e	8b 89 14 01 00
	00		 mov	 ecx, DWORD PTR [rcx+276]
  00024	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00027	75 0c		 jne	 SHORT $LN2@antlr3Vect

; 1337 : 	{
; 1338 : 		antlr3VectorResize(vector, 0);	    // Give no hint, we let it add 1024 or double it

  00029	33 d2		 xor	 edx, edx
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00030	e8 00 00 00 00	 call	 antlr3VectorResize
$LN2@antlr3Vect:

; 1339 : 	}
; 1340 : 
; 1341 : 	// Insert the new entry
; 1342 : 	//
; 1343 : 	vector->elements[vector->count].element	= element;

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	48 6b c0 10	 imul	 rax, rax, 16
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00046	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00049	48 8b 54 24 38	 mov	 rdx, QWORD PTR element$[rsp]
  0004e	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1344 : 	vector->elements[vector->count].freeptr	= freeptr;

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00057	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0005a	48 6b c0 10	 imul	 rax, rax, 16
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  00063	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00066	48 8b 54 24 40	 mov	 rdx, QWORD PTR freeptr$[rsp]
  0006b	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1345 : 
; 1346 : 	vector->count++;	    // One more element counted

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00075	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00078	ff c0		 inc	 eax
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR vector$[rsp]
  0007f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1347 : 
; 1348 : 	return  (ANTLR3_UINT32)(vector->count);

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR vector$[rsp]
  00087	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 1349 : 
; 1350 : }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
antlr3VectorAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorClear
_TEXT	SEGMENT
entry$ = 32
vector$ = 64
antlr3VectorClear PROC					; COMDAT

; 1137 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1138 : 	ANTLR3_UINT32   entry;
; 1139 : 
; 1140 : 	// We must traverse every entry in the vector and if it has
; 1141 : 	// a pointer to a free function then we call it with the
; 1142 : 	// the entry pointer
; 1143 : 	//
; 1144 : 	for	(entry = 0; entry < vector->count; entry++)

  0000a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR entry$[rsp], 0
  00012	eb 0a		 jmp	 SHORT $LN4@antlr3Vect
$LN2@antlr3Vect:
  00014	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00018	ff c0		 inc	 eax
  0001a	89 44 24 20	 mov	 DWORD PTR entry$[rsp], eax
$LN4@antlr3Vect:
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	39 44 24 20	 cmp	 DWORD PTR entry$[rsp], eax
  0002a	73 77		 jae	 SHORT $LN3@antlr3Vect

; 1145 : 	{
; 1146 : 		if  (vector->elements[entry].freeptr != NULL)

  0002c	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00030	48 6b c0 10	 imul	 rax, rax, 16
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00042	74 29		 je	 SHORT $LN5@antlr3Vect

; 1147 : 		{
; 1148 : 			vector->elements[entry].freeptr(vector->elements[entry].element);

  00044	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00048	48 6b c0 10	 imul	 rax, rax, 16
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	8b 54 24 20	 mov	 edx, DWORD PTR entry$[rsp]
  00058	48 6b d2 10	 imul	 rdx, rdx, 16
  0005c	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  00061	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00064	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00068	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]
$LN5@antlr3Vect:

; 1149 : 		}
; 1150 : 		vector->elements[entry].freeptr    = NULL;

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00071	48 6b c0 10	 imul	 rax, rax, 16
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0007a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007d	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1151 : 		vector->elements[entry].element    = NULL;

  00086	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0008a	48 6b c0 10	 imul	 rax, rax, 16
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00093	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00096	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1152 : 	}

  0009e	e9 71 ff ff ff	 jmp	 $LN2@antlr3Vect
$LN3@antlr3Vect:

; 1153 : 
; 1154 : 	// Having called any free pointers, we just reset the entry count
; 1155 : 	// back to zero.
; 1156 : 	//
; 1157 : 	vector->count	= 0;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000a8	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1158 : }

  000af	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
antlr3VectorClear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antrl3VectorRemove
_TEXT	SEGMENT
element$ = 32
tv132 = 40
vector$ = 64
entry$ = 72
antrl3VectorRemove PROC					; COMDAT

; 1251 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1252 : 	void * element;
; 1253 : 
; 1254 : 	// Check this is a valid request first 
; 1255 : 	//
; 1256 : 	if	(entry >= vector->count)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00013	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00016	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0001a	72 07		 jb	 SHORT $LN2@antrl3Vect

; 1257 : 	{
; 1258 : 		return NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	e9 c6 00 00 00	 jmp	 $LN1@antrl3Vect
$LN2@antrl3Vect:

; 1259 : 	}
; 1260 : 
; 1261 : 	// Valid request, return the sorted pointer
; 1262 : 	//
; 1263 : 
; 1264 : 	element				    = vector->elements[entry].element;

  00023	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00027	48 6b c0 10	 imul	 rax, rax, 16
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00037	48 89 44 24 20	 mov	 QWORD PTR element$[rsp], rax

; 1265 : 
; 1266 : 	if	(entry == vector->count - 1)

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00041	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00044	ff c8		 dec	 eax
  00046	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0004a	75 33		 jne	 SHORT $LN3@antrl3Vect

; 1267 : 	{
; 1268 : 		// Ensure the pointer is never reused by accident, but otherwise just 
; 1269 : 		// decrement the pointer.
; 1270 : 		///
; 1271 : 		vector->elements[entry].element    = NULL;

  0004c	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00050	48 6b c0 10	 imul	 rax, rax, 16
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00059	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005c	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1272 : 		vector->elements[entry].freeptr    = NULL;

  00064	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00068	48 6b c0 10	 imul	 rax, rax, 16
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00071	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00074	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1273 : 	}

  0007d	eb 53		 jmp	 SHORT $LN4@antrl3Vect
$LN3@antrl3Vect:

; 1274 : 	else
; 1275 : 	{
; 1276 : 		// Need to shuffle trailing pointers back over the deleted entry
; 1277 : 		//
; 1278 : 		ANTLR3_MEMMOVE(vector->elements + entry, vector->elements + entry + 1, sizeof(ANTLR3_VECTOR_ELEMENT) * (vector->count - entry - 1));

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00084	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  00088	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008b	2b c1		 sub	 eax, ecx
  0008d	ff c8		 dec	 eax
  0008f	8b c0		 mov	 eax, eax
  00091	48 6b c0 10	 imul	 rax, rax, 16
  00095	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  00099	48 6b c9 10	 imul	 rcx, rcx, 16
  0009d	48 8b 54 24 40	 mov	 rdx, QWORD PTR vector$[rsp]
  000a2	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000a5	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  000aa	8b 54 24 48	 mov	 edx, DWORD PTR entry$[rsp]
  000ae	48 6b d2 10	 imul	 rdx, rdx, 16
  000b2	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  000b7	49 03 10	 add	 rdx, QWORD PTR [r8]
  000ba	48 89 54 24 28	 mov	 QWORD PTR tv132[rsp], rdx
  000bf	4c 8b c0	 mov	 r8, rax
  000c2	48 8b d1	 mov	 rdx, rcx
  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR tv132[rsp]
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 memmove
$LN4@antrl3Vect:

; 1279 : 	}
; 1280 : 
; 1281 : 	// One less entry in the vector now
; 1282 : 	//
; 1283 : 	vector->count--;

  000d2	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000d7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000da	ff c8		 dec	 eax
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000e1	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1284 : 
; 1285 : 	return  element;

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR element$[rsp]
$LN1@antrl3Vect:

; 1286 : }

  000e9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ed	5f		 pop	 rdi
  000ee	c3		 ret	 0
antrl3VectorRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorGet
_TEXT	SEGMENT
vector$ = 16
entry$ = 24
antlr3VectorGet PROC					; COMDAT

; 1232 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 1233 : 	// Ensure this is a valid request
; 1234 : 	//
; 1235 : 	if	(entry < vector->count)

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR vector$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	39 44 24 18	 cmp	 DWORD PTR entry$[rsp], eax
  00016	73 18		 jae	 SHORT $LN2@antlr3Vect

; 1236 : 	{
; 1237 : 		return	vector->elements[entry].element;

  00018	8b 44 24 18	 mov	 eax, DWORD PTR entry$[rsp]
  0001c	48 6b c0 10	 imul	 rax, rax, 16
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR vector$[rsp]
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0002c	eb 04		 jmp	 SHORT $LN1@antlr3Vect

; 1238 : 	}

  0002e	eb 02		 jmp	 SHORT $LN3@antlr3Vect
$LN2@antlr3Vect:

; 1239 : 	else
; 1240 : 	{
; 1241 : 		// I know nothing, Mr. Fawlty!
; 1242 : 		//
; 1243 : 		return	NULL;

  00030	33 c0		 xor	 eax, eax
$LN3@antlr3Vect:
$LN1@antlr3Vect:

; 1244 : 	}
; 1245 : }

  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
antlr3VectorGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorDel
_TEXT	SEGMENT
tv144 = 32
vector$ = 64
entry$ = 72
antlr3VectorDel PROC					; COMDAT

; 1196 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1197 : 	// Check this is a valid request first
; 1198 : 	//
; 1199 : 	if	(entry >= vector->count)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00013	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00016	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  0001a	72 05		 jb	 SHORT $LN2@antlr3Vect

; 1200 : 	{
; 1201 : 		return;

  0001c	e9 e9 00 00 00	 jmp	 $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1202 : 	}
; 1203 : 
; 1204 : 	// Valid request, check for free pointer and call it if present
; 1205 : 	//
; 1206 : 	if	(vector->elements[entry].freeptr != NULL)

  00021	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00025	48 6b c0 10	 imul	 rax, rax, 16
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0002e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00031	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00037	74 42		 je	 SHORT $LN3@antlr3Vect

; 1207 : 	{
; 1208 : 		vector->elements[entry].freeptr(vector->elements[entry].element);

  00039	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  0003d	48 6b c0 10	 imul	 rax, rax, 16
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00046	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00049	8b 54 24 48	 mov	 edx, DWORD PTR entry$[rsp]
  0004d	48 6b d2 10	 imul	 rdx, rdx, 16
  00051	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  00056	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00059	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0005d	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]

; 1209 : 		vector->elements[entry].freeptr    = NULL;

  00062	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  00066	48 6b c0 10	 imul	 rax, rax, 16
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0006f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00072	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0
$LN3@antlr3Vect:

; 1210 : 	}
; 1211 : 
; 1212 : 	if	(entry == vector->count - 1)

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00083	ff c8		 dec	 eax
  00085	39 44 24 48	 cmp	 DWORD PTR entry$[rsp], eax
  00089	75 1a		 jne	 SHORT $LN4@antlr3Vect

; 1213 : 	{
; 1214 : 		// Ensure the pointer is never reused by accident, but otherwise just 
; 1215 : 		// decrement the pointer.
; 1216 : 		//
; 1217 : 		vector->elements[entry].element    = NULL;

  0008b	8b 44 24 48	 mov	 eax, DWORD PTR entry$[rsp]
  0008f	48 6b c0 10	 imul	 rax, rax, 16
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00098	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009b	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1218 : 	}

  000a3	eb 53		 jmp	 SHORT $LN5@antlr3Vect
$LN4@antlr3Vect:

; 1219 : 	else
; 1220 : 	{
; 1221 : 		// Need to shuffle trailing pointers back over the deleted entry
; 1222 : 		//
; 1223 : 		ANTLR3_MEMMOVE(vector->elements + entry, vector->elements + entry + 1, sizeof(ANTLR3_VECTOR_ELEMENT) * (vector->count - entry - 1));

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000aa	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  000ae	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000b1	2b c1		 sub	 eax, ecx
  000b3	ff c8		 dec	 eax
  000b5	8b c0		 mov	 eax, eax
  000b7	48 6b c0 10	 imul	 rax, rax, 16
  000bb	8b 4c 24 48	 mov	 ecx, DWORD PTR entry$[rsp]
  000bf	48 6b c9 10	 imul	 rcx, rcx, 16
  000c3	48 8b 54 24 40	 mov	 rdx, QWORD PTR vector$[rsp]
  000c8	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000cb	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  000d0	8b 54 24 48	 mov	 edx, DWORD PTR entry$[rsp]
  000d4	48 6b d2 10	 imul	 rdx, rdx, 16
  000d8	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  000dd	49 03 10	 add	 rdx, QWORD PTR [r8]
  000e0	48 89 54 24 20	 mov	 QWORD PTR tv144[rsp], rdx
  000e5	4c 8b c0	 mov	 r8, rax
  000e8	48 8b d1	 mov	 rdx, rcx
  000eb	48 8b 44 24 20	 mov	 rax, QWORD PTR tv144[rsp]
  000f0	48 8b c8	 mov	 rcx, rax
  000f3	e8 00 00 00 00	 call	 memmove
$LN5@antlr3Vect:

; 1224 : 	}
; 1225 : 
; 1226 : 	// One less entry in the vector now
; 1227 : 	//
; 1228 : 	vector->count--;

  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000fd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00100	ff c8		 dec	 eax
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00107	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN1@antlr3Vect:

; 1229 : }

  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
antlr3VectorDel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorFree
_TEXT	SEGMENT
entry$ = 32
vector$ = 64
antlr3VectorFree PROC					; COMDAT

; 1162 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1163 : 	ANTLR3_UINT32   entry;
; 1164 : 
; 1165 : 	// We must traverse every entry in the vector and if it has
; 1166 : 	// a pointer to a free function then we call it with the
; 1167 : 	// the entry pointer
; 1168 : 	//
; 1169 : 	for	(entry = 0; entry < vector->count; entry++)

  0000a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR entry$[rsp], 0
  00012	eb 0a		 jmp	 SHORT $LN4@antlr3Vect
$LN2@antlr3Vect:
  00014	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00018	ff c0		 inc	 eax
  0001a	89 44 24 20	 mov	 DWORD PTR entry$[rsp], eax
$LN4@antlr3Vect:
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	39 44 24 20	 cmp	 DWORD PTR entry$[rsp], eax
  0002a	73 77		 jae	 SHORT $LN3@antlr3Vect

; 1170 : 	{
; 1171 : 		if  (vector->elements[entry].freeptr != NULL)

  0002c	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00030	48 6b c0 10	 imul	 rax, rax, 16
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00042	74 29		 je	 SHORT $LN5@antlr3Vect

; 1172 : 		{
; 1173 : 			vector->elements[entry].freeptr(vector->elements[entry].element);

  00044	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00048	48 6b c0 10	 imul	 rax, rax, 16
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00051	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00054	8b 54 24 20	 mov	 edx, DWORD PTR entry$[rsp]
  00058	48 6b d2 10	 imul	 rdx, rdx, 16
  0005c	4c 8b 44 24 40	 mov	 r8, QWORD PTR vector$[rsp]
  00061	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00064	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00068	41 ff 54 10 08	 call	 QWORD PTR [r8+rdx+8]
$LN5@antlr3Vect:

; 1174 : 		}
; 1175 : 		vector->elements[entry].freeptr    = NULL;

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  00071	48 6b c0 10	 imul	 rax, rax, 16
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0007a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007d	48 c7 44 01 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+8], 0

; 1176 : 		vector->elements[entry].element    = NULL;

  00086	8b 44 24 20	 mov	 eax, DWORD PTR entry$[rsp]
  0008a	48 6b c0 10	 imul	 rax, rax, 16
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00093	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00096	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1177 : 	}

  0009e	e9 71 ff ff ff	 jmp	 $LN2@antlr3Vect
$LN3@antlr3Vect:

; 1178 : 
; 1179 : 	if	(vector->factoryMade == ANTLR3_FALSE)

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000a8	0f b6 80 10 01
	00 00		 movzx	 eax, BYTE PTR [rax+272]
  000af	85 c0		 test	 eax, eax
  000b1	75 33		 jne	 SHORT $LN6@antlr3Vect

; 1180 : 	{
; 1181 : 		// The entries are freed, so free the element allocation
; 1182 : 		//
; 1183 :         if  (vector->elementsSize > ANTLR3_VECTOR_INTERNAL_SIZE)

  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000b8	83 b8 14 01 00
	00 10		 cmp	 DWORD PTR [rax+276], 16
  000bf	76 0e		 jbe	 SHORT $LN7@antlr3Vect

; 1184 :         {
; 1185 :             ANTLR3_FREE(vector->elements);

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000c6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@antlr3Vect:

; 1186 :         }
; 1187 : 		vector->elements = NULL;

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000d4	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1188 : 
; 1189 : 		// Finally, free the allocation for the vector itself
; 1190 : 		//
; 1191 : 		ANTLR3_FREE(vector);

  000db	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@antlr3Vect:

; 1192 : 	}
; 1193 : }

  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
antlr3VectorFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackPeek
_TEXT	SEGMENT
stack$ = 16
antlr3StackPeek PROC					; COMDAT

; 1042 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1043 :     return  stack->top;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR stack$[rsp]
  0000b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1044 : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
antlr3StackPeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackSize
_TEXT	SEGMENT
stack$ = 16
antlr3StackSize PROC					; COMDAT

; 1000 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1001 :     return  stack->vector->count;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR stack$[rsp]
  0000b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 1002 : }

  00011	5f		 pop	 rdi
  00012	c3		 ret	 0
antlr3StackSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackPush
_TEXT	SEGMENT
stack$ = 48
element$ = 56
freeptr$ = 64
antlr3StackPush PROC					; COMDAT

; 1048 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1049 :     stack->top	= element;

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00019	48 8b 4c 24 38	 mov	 rcx, QWORD PTR element$[rsp]
  0001e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1050 :     return (ANTLR3_BOOLEAN)(stack->vector->add(stack->vector, element, freeptr));

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	4c 8b 44 24 40	 mov	 r8, QWORD PTR freeptr$[rsp]
  0002f	48 8b 54 24 38	 mov	 rdx, QWORD PTR element$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  00039	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003c	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 1051 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
antlr3StackPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackGet
_TEXT	SEGMENT
stack$ = 48
key$ = 56
antlr3StackGet PROC					; COMDAT

; 1036 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1037 :     return  stack->vector->get(stack->vector, (ANTLR3_UINT32)key);

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	8b 54 24 38	 mov	 edx, DWORD PTR key$[rsp]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  00020	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00023	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 1038 : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
antlr3StackGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackPop
_TEXT	SEGMENT
tv86 = 32
tv83 = 40
stack$ = 64
antlr3StackPop PROC					; COMDAT

; 1019 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1020 :     // Delete the element that is currently at the top of the stack
; 1021 :     //
; 1022 :     stack->vector->del(stack->vector, stack->vector->count - 1);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00015	ff c8		 dec	 eax
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stack$[rsp]
  0001c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001f	48 89 4c 24 20	 mov	 QWORD PTR tv86[rsp], rcx
  00024	8b d0		 mov	 edx, eax
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv86[rsp]
  00033	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 1023 : 
; 1024 :     // And get the element that is the now the top of the stack (if anything)
; 1025 :     // NOTE! This is not quite like a 'real' stack, which would normally return you
; 1026 :     // the current top of the stack, then remove it from the stack.
; 1027 :     // TODO: Review this, it is correct for follow sets which is what this was done for
; 1028 :     //       but is not as obvious when using it as a 'real'stack.
; 1029 :     //
; 1030 :     stack->top = stack->vector->get(stack->vector, stack->vector->count - 1);

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00044	ff c8		 dec	 eax
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stack$[rsp]
  0004b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004e	48 89 4c 24 28	 mov	 QWORD PTR tv83[rsp], rcx
  00053	8b d0		 mov	 edx, eax
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  0005a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv83[rsp]
  00062	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stack$[rsp]
  0006d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1031 :     return stack->top;

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR stack$[rsp]
  00076	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 1032 : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
antlr3StackPop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackFree
_TEXT	SEGMENT
stack$ = 48
antlr3StackFree PROC					; COMDAT

; 1007 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1008 :     /* Free the list that supports the stack
; 1009 :      */
; 1010 :     stack->vector->free(stack->vector);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 1011 :     stack->vector   = NULL;

  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00025	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1012 :     stack->top	    = NULL;

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR stack$[rsp]
  00031	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1013 : 
; 1014 :     ANTLR3_FREE(stack);

  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR stack$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1015 : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
antlr3StackFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListSize
_TEXT	SEGMENT
list$ = 48
antlr3ListSize PROC					; COMDAT

; 899  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 900  :     return  list->table->size(list->table);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	ff 50 60	 call	 QWORD PTR [rax+96]

; 901  : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5f		 pop	 rdi
  00022	c3		 ret	 0
antlr3ListSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListRemove
_TEXT	SEGMENT
entry$ = 32
list$ = 64
key$ = 72
antlr3ListRemove PROC					; COMDAT

; 942  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 943  :     pANTLR3_HASH_ENTRY	    entry;
; 944  : 
; 945  :     entry = list->table->removeI(list->table, key);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00021	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00024	ff 50 48	 call	 QWORD PTR [rax+72]
  00027	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 946  : 
; 947  :     if	(entry != NULL)

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00032	74 0d		 je	 SHORT $LN2@antlr3List

; 948  :     {
; 949  :         return  entry->data;

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00039	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003d	eb 04		 jmp	 SHORT $LN1@antlr3List

; 950  :     }

  0003f	eb 02		 jmp	 SHORT $LN3@antlr3List
$LN2@antlr3List:

; 951  :     else
; 952  :     {
; 953  : 	return	NULL;

  00041	33 c0		 xor	 eax, eax
$LN3@antlr3List:
$LN1@antlr3List:

; 954  :     }
; 955  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
antlr3ListRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListAdd
_TEXT	SEGMENT
key$ = 32
list$ = 64
element$ = 72
freeptr$ = 80
antlr3ListAdd PROC					; COMDAT

; 930  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 931  :     ANTLR3_INTKEY   key;
; 932  : 
; 933  :     key	    = list->table->size(list->table) + 1;

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00021	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00024	ff 50 60	 call	 QWORD PTR [rax+96]
  00027	ff c0		 inc	 eax
  00029	8b c0		 mov	 eax, eax
  0002b	48 89 44 24 20	 mov	 QWORD PTR key$[rsp], rax

; 934  :     return list->put(list, key, element, freeptr);

  00030	4c 8b 4c 24 50	 mov	 r9, QWORD PTR freeptr$[rsp]
  00035	4c 8b 44 24 48	 mov	 r8, QWORD PTR element$[rsp]
  0003a	48 8b 54 24 20	 mov	 rdx, QWORD PTR key$[rsp]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR list$[rsp]
  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR list$[rsp]
  00049	ff 50 30	 call	 QWORD PTR [rax+48]

; 935  : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
antlr3ListAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListPut
_TEXT	SEGMENT
list$ = 48
key$ = 56
element$ = 64
freeptr$ = 72
antlr3ListPut PROC					; COMDAT

; 959  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 960  :     return  list->table->putI(list->table, key, element, freeptr);

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	4c 8b 4c 24 48	 mov	 r9, QWORD PTR freeptr$[rsp]
  00026	4c 8b 44 24 40	 mov	 r8, QWORD PTR element$[rsp]
  0002b	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	ff 50 58	 call	 QWORD PTR [rax+88]

; 961  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
antlr3ListPut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListGet
_TEXT	SEGMENT
list$ = 48
key$ = 56
antlr3ListGet PROC					; COMDAT

; 923  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 924  :     return list->table->getI(list->table, key);

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00021	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00024	ff 50 50	 call	 QWORD PTR [rax+80]

; 925  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
antlr3ListGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListDelete
_TEXT	SEGMENT
list$ = 48
key$ = 56
antlr3ListDelete PROC					; COMDAT

; 917  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 918  :     list->table->delI(list->table, key);

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR key$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00021	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00024	ff 50 40	 call	 QWORD PTR [rax+64]

; 919  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
antlr3ListDelete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListFree
_TEXT	SEGMENT
list$ = 48
antlr3ListFree PROC					; COMDAT

; 905  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 906  :     /* Free the hashtable that stores the list
; 907  :      */
; 908  :     list->table->free(list->table);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	ff 50 18	 call	 QWORD PTR [rax+24]

; 909  : 
; 910  :     /* Free the allocation for the list itself
; 911  :      */
; 912  :     ANTLR3_FREE(list);

  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 913  : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
antlr3ListFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumFree
_TEXT	SEGMENT
en$ = 48
antlr3EnumFree PROC					; COMDAT

; 823  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 824  :     /* Nothing to check, we just free it.
; 825  :      */
; 826  :     ANTLR3_FREE(en);

  0000a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR en$[rsp]
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 827  : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
antlr3EnumFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumNext
_TEXT	SEGMENT
en$ = 48
key$ = 56
data$ = 64
antlr3EnumNext PROC					; COMDAT

; 730  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 731  :     /* If the current entry is valid, then use it
; 732  :      */
; 733  :     if  (en->bucket >= en->table->modulo)

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR en$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR en$[rsp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00024	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  00027	72 07		 jb	 SHORT $LN2@antlr3Enum

; 734  :     {
; 735  :         /* Already exhausted the table
; 736  :          */
; 737  :         return	ANTLR3_FAIL;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	eb 32		 jmp	 SHORT $LN1@antlr3Enum
$LN2@antlr3Enum:

; 738  :     }
; 739  : 
; 740  :     /* Pointers are already set to the current entry to return, or
; 741  :      * we would not be at this point in the logic flow.
; 742  :      */
; 743  :     *key	= &(en->entry->keybase);

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR en$[rsp]
  00035	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00039	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  0003e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 744  :     *data	= en->entry->data;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR en$[rsp]
  00046	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0004f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00053	48 89 01	 mov	 QWORD PTR [rcx], rax

; 745  : 
; 746  :     /* Return pointers are set up, so now we move the element
; 747  :      * pointer to the next in the table (if any).
; 748  :      */
; 749  :     antlr3EnumNextEntry(en);

  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR en$[rsp]
  0005b	e8 00 00 00 00	 call	 antlr3EnumNextEntry

; 750  : 
; 751  :     return	ANTLR3_SUCCESS;

  00060	33 c0		 xor	 eax, eax
$LN1@antlr3Enum:

; 752  : }

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
antlr3EnumNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashSize
_TEXT	SEGMENT
table$ = 16
antlr3HashSize PROC					; COMDAT

; 267  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 268  :     return  table->count;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR table$[rsp]
  0000b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 269  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr3HashSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashFree
_TEXT	SEGMENT
bucket$ = 32
thisBucket$ = 40
entry$ = 48
nextEntry$ = 56
table$ = 80
antlr3HashFree PROC					; COMDAT

; 196  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 197  :     ANTLR3_UINT32	bucket;	/* Used to traverse the buckets	*/
; 198  : 
; 199  :     pANTLR3_HASH_BUCKET	thisBucket;
; 200  :     pANTLR3_HASH_ENTRY	entry;
; 201  :     pANTLR3_HASH_ENTRY	nextEntry;
; 202  : 
; 203  :     /* Free the table, all buckets and all entries, and all the
; 204  :      * keys and data (if the table exists)
; 205  :      */
; 206  :     if	(table	!= NULL)

  0000a	48 83 7c 24 50
	00		 cmp	 QWORD PTR table$[rsp], 0
  00010	0f 84 e7 00 00
	00		 je	 $LN7@antlr3Hash

; 207  :     {
; 208  : 	for	(bucket = 0; bucket < table->modulo; bucket++)

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bucket$[rsp], 0
  0001e	eb 0a		 jmp	 SHORT $LN4@antlr3Hash
$LN2@antlr3Hash:
  00020	8b 44 24 20	 mov	 eax, DWORD PTR bucket$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 44 24 20	 mov	 DWORD PTR bucket$[rsp], eax
$LN4@antlr3Hash:
  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  0002f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00032	39 44 24 20	 cmp	 DWORD PTR bucket$[rsp], eax
  00036	0f 83 b2 00 00
	00		 jae	 $LN3@antlr3Hash

; 209  : 	{
; 210  : 	    thisBucket	= &(table->buckets[bucket]);

  0003c	8b 44 24 20	 mov	 eax, DWORD PTR bucket$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00045	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00049	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0004d	48 89 44 24 28	 mov	 QWORD PTR thisBucket$[rsp], rax

; 211  : 
; 212  : 	    /* Allow sparse tables, though we don't create them as such at present
; 213  : 	     */
; 214  : 	    if	( thisBucket != NULL)

  00052	48 83 7c 24 28
	00		 cmp	 QWORD PTR thisBucket$[rsp], 0
  00058	0f 84 8b 00 00
	00		 je	 $LN8@antlr3Hash

; 215  : 	    {
; 216  : 		entry	= thisBucket->entries;

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR thisBucket$[rsp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
$LN5@antlr3Hash:

; 217  : 
; 218  : 		/* Search all entries in the bucket and free them up
; 219  : 		 */
; 220  : 		while	(entry != NULL)

  0006b	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00071	74 6a		 je	 SHORT $LN6@antlr3Hash

; 221  : 		{
; 222  : 		    /* Save next entry - we do not want to access memory in entry after we
; 223  : 		     * have freed it.
; 224  : 		     */
; 225  : 		    nextEntry	= entry->nextEntry;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00078	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007c	48 89 44 24 38	 mov	 QWORD PTR nextEntry$[rsp], rax

; 226  : 
; 227  : 		    /* Free any data pointer, this only happens if the user supplied
; 228  : 		     * a pointer to a routine that knwos how to free the structure they
; 229  : 		     * added to the table.
; 230  : 		     */
; 231  : 		    if	(entry->free != NULL)

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00086	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0008b	74 11		 je	 SHORT $LN9@antlr3Hash

; 232  : 		    {
; 233  : 			entry->free(entry->data);

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00092	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0009b	ff 50 18	 call	 QWORD PTR [rax+24]
$LN9@antlr3Hash:

; 234  : 		    }
; 235  : 
; 236  : 		    /* Free the key memory - we know that we allocated this
; 237  : 		     */
; 238  : 		    if	(entry->keybase.type == ANTLR3_HASH_TYPE_STR && entry->keybase.key.sKey != NULL)

  0009e	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a6	83 f8 01	 cmp	 eax, 1
  000a9	75 1b		 jne	 SHORT $LN10@antlr3Hash
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000b0	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000b5	74 0f		 je	 SHORT $LN10@antlr3Hash

; 239  : 		    {
; 240  : 			ANTLR3_FREE(entry->keybase.key.sKey);

  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000bc	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN10@antlr3Hash:

; 241  : 		    }
; 242  : 
; 243  : 		    /* Free this entry
; 244  : 		     */
; 245  : 		    ANTLR3_FREE(entry);

  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 246  : 		    entry   = nextEntry;    /* Load next pointer to see if we shoud free it */

  000d1	48 8b 44 24 38	 mov	 rax, QWORD PTR nextEntry$[rsp]
  000d6	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 247  : 		}

  000db	eb 8e		 jmp	 SHORT $LN5@antlr3Hash
$LN6@antlr3Hash:

; 248  : 		/* Invalidate the current pointer
; 249  : 		 */
; 250  : 		thisBucket->entries = NULL;

  000dd	48 8b 44 24 28	 mov	 rax, QWORD PTR thisBucket$[rsp]
  000e2	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN8@antlr3Hash:

; 251  : 	    }
; 252  : 	}

  000e9	e9 32 ff ff ff	 jmp	 $LN2@antlr3Hash
$LN3@antlr3Hash:

; 253  : 
; 254  : 	/* Now we can free the bucket memory
; 255  : 	 */
; 256  : 	ANTLR3_FREE(table->buckets);

  000ee	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  000f3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@antlr3Hash:

; 257  :     }
; 258  : 
; 259  :     /* Now we free teh memory for the table itself
; 260  :      */
; 261  :     ANTLR3_FREE(table);

  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 262  : }

  00108	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
antlr3HashFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashPutI
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
newPointer$ = 56
tv65 = 64
table$ = 96
key$ = 104
element$ = 112
freeptr$ = 120
antlr3HashPutI PROC					; COMDAT

; 524  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 525  : 	ANTLR3_UINT32	    hash;
; 526  : 	pANTLR3_HASH_BUCKET	    bucket;
; 527  : 	pANTLR3_HASH_ENTRY	    entry;
; 528  : 	pANTLR3_HASH_ENTRY	    * newPointer;
; 529  : 
; 530  : 	/* First we need to know the hash of the provided key
; 531  : 	*/
; 532  : 	hash    = (ANTLR3_UINT32)(key % (ANTLR3_INTKEY)(table->modulo));

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR table$[rsp]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00021	48 89 44 24 40	 mov	 QWORD PTR tv65[rsp], rax
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 68	 mov	 rax, QWORD PTR key$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv65[rsp]
  00032	48 f7 f1	 div	 rcx
  00035	48 8b c2	 mov	 rax, rdx
  00038	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 533  : 
; 534  : 	/* Knowing the hash, we can find the bucket
; 535  : 	*/
; 536  : 	bucket  = table->buckets + hash;

  0003c	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  00040	48 8b 4c 24 60	 mov	 rcx, QWORD PTR table$[rsp]
  00045	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00049	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0004d	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 537  : 
; 538  : 	/* Knowing the bucket, we can traverse the entries until we
; 539  : 	* we find a NULL pointer or we find that this is already 
; 540  : 	* in the table and duplicates were not allowed.
; 541  : 	*/
; 542  : 	newPointer	= &bucket->entries;

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00057	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax
$LN2@antlr3Hash:

; 543  : 
; 544  : 	while   (*newPointer !=  NULL)

  0005c	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00061	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00065	74 3a		 je	 SHORT $LN3@antlr3Hash

; 545  : 	{
; 546  : 		/* The value at new pointer is pointing to an existing entry.
; 547  : 		* If duplicates are allowed then we don't care what it is, but
; 548  : 		* must reject this add if the key is the same as the one we are
; 549  : 		* supplied with.
; 550  : 		*/
; 551  : 		if  (table->allowDups == ANTLR3_FALSE)

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR table$[rsp]
  0006c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0006f	75 1d		 jne	 SHORT $LN4@antlr3Hash

; 552  : 		{
; 553  : 			if	((*newPointer)->keybase.key.iKey == key)

  00071	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00076	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR key$[rsp]
  0007e	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00082	75 0a		 jne	 SHORT $LN5@antlr3Hash

; 554  : 			{
; 555  : 				return	ANTLR3_ERR_HASHDUP;

  00084	b8 03 00 00 00	 mov	 eax, 3
  00089	e9 92 00 00 00	 jmp	 $LN1@antlr3Hash
$LN5@antlr3Hash:
$LN4@antlr3Hash:

; 556  : 			}
; 557  : 		}
; 558  : 
; 559  : 		/* Point to the next entry pointer of the current entry we
; 560  : 		* are traversing, if it is NULL we will create our new
; 561  : 		* structure and point this to it.
; 562  : 		*/
; 563  : 		newPointer = &((*newPointer)->nextEntry);

  0008e	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00093	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00096	48 83 c0 20	 add	 rax, 32			; 00000020H
  0009a	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax

; 564  : 	}

  0009f	eb bb		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 565  : 
; 566  : 	/* newPointer is now pointing at the pointer where we need to
; 567  : 	* add our new entry, so let's crate the entry and add it in.
; 568  : 	*/
; 569  : 	entry   = (pANTLR3_HASH_ENTRY)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_HASH_ENTRY));

  000a1	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000ac	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 570  : 
; 571  : 	if	(entry == NULL)

  000b1	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  000b7	75 07		 jne	 SHORT $LN6@antlr3Hash

; 572  : 	{
; 573  : 		return	ANTLR3_ERR_NOMEM;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	eb 60		 jmp	 SHORT $LN1@antlr3Hash
$LN6@antlr3Hash:

; 574  : 	}
; 575  : 
; 576  : 	entry->data			= element;		/* Install the data element supplied			*/

  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR element$[rsp]
  000ca	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 577  : 	entry->free			= freeptr;		/* Function that knows how to release the entry		*/

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000d3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR freeptr$[rsp]
  000d8	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 578  : 	entry->keybase.type		= ANTLR3_HASH_TYPE_INT;	/* Indicate the key type stored here for when we free	*/

  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000e1	c6 00 00	 mov	 BYTE PTR [rax], 0

; 579  : 	entry->keybase.key.iKey	= key;			/* Record the key value					*/

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR key$[rsp]
  000ee	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 580  : 	entry->nextEntry		= NULL;			/* Ensure that the forward pointer ends the chain	*/

  000f2	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000f7	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 581  : 
; 582  : 	*newPointer	= entry;    /* Install the next entry in this bucket	*/

  000ff	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  00109	48 89 08	 mov	 QWORD PTR [rax], rcx

; 583  : 
; 584  : 	table->count++;

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR table$[rsp]
  00111	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00114	ff c0		 inc	 eax
  00116	48 8b 4c 24 60	 mov	 rcx, QWORD PTR table$[rsp]
  0011b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 585  : 
; 586  : 	return  ANTLR3_SUCCESS;

  0011e	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 587  : }

  00120	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00124	5f		 pop	 rdi
  00125	c3		 ret	 0
antlr3HashPutI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashRemoveI
_TEXT	SEGMENT
hash$ = 0
bucket$ = 8
entry$ = 16
nextPointer$ = 24
tv65 = 32
table$ = 64
key$ = 72
antlr3HashRemoveI PROC					; COMDAT

; 275  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 276  :     ANTLR3_UINT32	    hash;
; 277  :     pANTLR3_HASH_BUCKET	    bucket;
; 278  :     pANTLR3_HASH_ENTRY	    entry;
; 279  :     pANTLR3_HASH_ENTRY	    * nextPointer;
; 280  : 
; 281  :     /* First we need to know the hash of the provided key
; 282  :      */
; 283  :     hash    = (ANTLR3_UINT32)(key % (ANTLR3_INTKEY)(table->modulo));

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR table$[rsp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00017	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00028	48 f7 f1	 div	 rcx
  0002b	48 8b c2	 mov	 rax, rdx
  0002e	89 04 24	 mov	 DWORD PTR hash$[rsp], eax

; 284  : 
; 285  :     /* Knowing the hash, we can find the bucket
; 286  :      */
; 287  :     bucket  = table->buckets + hash;

  00031	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  00039	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003d	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00041	48 89 44 24 08	 mov	 QWORD PTR bucket$[rsp], rax

; 288  : 
; 289  :     /* Now, we traverse the entries in the bucket until
; 290  :      * we find the key or the end of the entries in the bucket. 
; 291  :      * We track the element prior to the one we are examining
; 292  :      * as we need to set its next pointer to the next pointer
; 293  :      * of the entry we are deleting (if we find it).
; 294  :      */
; 295  :     entry	    =   bucket->entries;    /* Entry to examine					    */

  00046	48 8b 44 24 08	 mov	 rax, QWORD PTR bucket$[rsp]
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax

; 296  :     nextPointer	    = & bucket->entries;    /* Where to put the next pointer of the deleted entry   */

  00053	48 8b 44 24 08	 mov	 rax, QWORD PTR bucket$[rsp]
  00058	48 89 44 24 18	 mov	 QWORD PTR nextPointer$[rsp], rax
$LN2@antlr3Hash:

; 297  : 
; 298  :     while   (entry != NULL)

  0005d	48 83 7c 24 10
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00063	74 5a		 je	 SHORT $LN3@antlr3Hash

; 299  :     {
; 300  : 	/* See if this is the entry we wish to delete
; 301  : 	 */
; 302  : 	if  (entry->keybase.key.iKey == key)

  00065	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  0006a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0006f	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00073	75 2c		 jne	 SHORT $LN4@antlr3Hash

; 303  : 	{
; 304  : 	    /* It was the correct entry, so we set the next pointer
; 305  : 	     * of the previous entry to the next pointer of this
; 306  : 	     * located one, which takes it out of the chain.
; 307  : 	     */
; 308  : 	    (*nextPointer)		= entry->nextEntry;

  00075	48 8b 44 24 18	 mov	 rax, QWORD PTR nextPointer$[rsp]
  0007a	48 8b 4c 24 10	 mov	 rcx, QWORD PTR entry$[rsp]
  0007f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00083	48 89 08	 mov	 QWORD PTR [rax], rcx

; 309  : 
; 310  : 	    table->count--;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR table$[rsp]
  0008b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0008e	ff c8		 dec	 eax
  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  00095	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 311  : 
; 312  : 	    return entry;

  00098	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  0009d	eb 22		 jmp	 SHORT $LN1@antlr3Hash

; 313  : 	}

  0009f	eb 1c		 jmp	 SHORT $LN5@antlr3Hash
$LN4@antlr3Hash:

; 314  : 	else
; 315  : 	{
; 316  : 	    /* We found an entry but it wasn't the one that was wanted, so
; 317  : 	     * move to the next one, if any.
; 318  : 	     */
; 319  : 	    nextPointer	= & (entry->nextEntry);	    /* Address of the next pointer in the current entry	    */

  000a1	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  000a6	48 83 c0 20	 add	 rax, 32			; 00000020H
  000aa	48 89 44 24 18	 mov	 QWORD PTR nextPointer$[rsp], rax

; 320  : 	    entry	= entry->nextEntry;	    /* Address of the next element in the bucket (if any)   */

  000af	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  000b4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000b8	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax
$LN5@antlr3Hash:

; 321  : 	}
; 322  :     }

  000bd	eb 9e		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 323  : 
; 324  :     return NULL;  /* Not found */

  000bf	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 325  : }

  000c1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
antlr3HashRemoveI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashGetI
_TEXT	SEGMENT
hash$ = 0
bucket$ = 8
entry$ = 16
tv65 = 24
table$ = 48
key$ = 56
antlr3HashGetI PROC					; COMDAT

; 445  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 446  :     ANTLR3_UINT32	    hash;
; 447  :     pANTLR3_HASH_BUCKET	    bucket;
; 448  :     pANTLR3_HASH_ENTRY	    entry;
; 449  : 
; 450  :     /* First we need to know the hash of the provided key
; 451  :      */
; 452  :     hash    = (ANTLR3_UINT32)(key % (ANTLR3_INTKEY)(table->modulo));

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR table$[rsp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00017	48 89 44 24 18	 mov	 QWORD PTR tv65[rsp], rax
  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR key$[rsp]
  00023	48 8b 4c 24 18	 mov	 rcx, QWORD PTR tv65[rsp]
  00028	48 f7 f1	 div	 rcx
  0002b	48 8b c2	 mov	 rax, rdx
  0002e	89 04 24	 mov	 DWORD PTR hash$[rsp], eax

; 453  : 
; 454  :     /* Knowing the hash, we can find the bucket
; 455  :      */
; 456  :     bucket  = table->buckets + hash;

  00031	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR table$[rsp]
  00039	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003d	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00041	48 89 44 24 08	 mov	 QWORD PTR bucket$[rsp], rax

; 457  : 
; 458  :     /* Now we can inspect the key at each entry in the bucket
; 459  :      * and see if we have a match.
; 460  :      */
; 461  :     entry   = bucket->entries;

  00046	48 8b 44 24 08	 mov	 rax, QWORD PTR bucket$[rsp]
  0004b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004e	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax
$LN2@antlr3Hash:

; 462  : 
; 463  :     while   (entry != NULL)

  00053	48 83 7c 24 10
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00059	74 2b		 je	 SHORT $LN3@antlr3Hash

; 464  :     {
; 465  : 	if  (entry->keybase.key.iKey == key)

  0005b	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  00060	48 8b 4c 24 38	 mov	 rcx, QWORD PTR key$[rsp]
  00065	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00069	75 0b		 jne	 SHORT $LN4@antlr3Hash

; 466  : 	{
; 467  : 	    /* Match was found, return the data pointer for this entry
; 468  : 	     */
; 469  : 	    return  entry->data;

  0006b	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  00070	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00074	eb 12		 jmp	 SHORT $LN1@antlr3Hash
$LN4@antlr3Hash:

; 470  : 	}
; 471  : 	entry = entry->nextEntry;

  00076	48 8b 44 24 10	 mov	 rax, QWORD PTR entry$[rsp]
  0007b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007f	48 89 44 24 10	 mov	 QWORD PTR entry$[rsp], rax

; 472  :     }

  00084	eb cd		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 473  : 
; 474  :     /* If we got here, then we did not find the key
; 475  :      */
; 476  :     return  NULL;

  00086	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 477  : }

  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
antlr3HashGetI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashDeleteI
_TEXT	SEGMENT
entry$ = 32
table$ = 64
key$ = 72
antlr3HashDeleteI PROC					; COMDAT

; 397  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 398  :     pANTLR3_HASH_ENTRY	entry;
; 399  : 
; 400  :     entry = antlr3HashRemoveI(table, key);

  0000f	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  00019	e8 00 00 00 00	 call	 antlr3HashRemoveI
  0001e	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 401  : 	
; 402  :     /* Now we can free the elements and the entry in order
; 403  :      */
; 404  :     if	(entry != NULL && entry->free != NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00029	74 2a		 je	 SHORT $LN2@antlr3Hash
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00030	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00035	74 1e		 je	 SHORT $LN2@antlr3Hash

; 405  :     {
; 406  : 	/* Call programmer supplied function to release this entry data
; 407  : 	 */
; 408  : 	entry->free(entry->data);

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0003c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00045	ff 50 18	 call	 QWORD PTR [rax+24]

; 409  : 	entry->data = NULL;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0004d	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN2@antlr3Hash:

; 410  :     }
; 411  :     /* Finally release the space for this entry block.
; 412  :      */
; 413  :     ANTLR3_FREE(entry);

  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR entry$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 414  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
antlr3HashDeleteI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashPut
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
newPointer$ = 56
table$ = 80
key$ = 88
element$ = 96
freeptr$ = 104
antlr3HashPut PROC					; COMDAT

; 595  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 596  : 	ANTLR3_UINT32	    hash;
; 597  : 	pANTLR3_HASH_BUCKET	    bucket;
; 598  : 	pANTLR3_HASH_ENTRY	    entry;
; 599  : 	pANTLR3_HASH_ENTRY	    * newPointer;
; 600  : 
; 601  : 	/* First we need to know the hash of the provided key
; 602  : 	*/
; 603  : 	hash    = antlr3Hash(key, (ANTLR3_UINT32)strlen((const char *)key));

  00019	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0001e	e8 00 00 00 00	 call	 strlen
  00023	8b d0		 mov	 edx, eax
  00025	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0002a	e8 00 00 00 00	 call	 antlr3Hash
  0002f	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 604  : 
; 605  : 	/* Knowing the hash, we can find the bucket
; 606  : 	*/
; 607  : 	bucket  = table->buckets + (hash % table->modulo);

  00033	33 d2		 xor	 edx, edx
  00035	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  00039	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  0003e	f7 71 04	 div	 DWORD PTR [rcx+4]
  00041	8b c2		 mov	 eax, edx
  00043	8b c0		 mov	 eax, eax
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  0004a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004e	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00052	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 608  : 
; 609  : 	/* Knowign the bucket, we can traverse the entries until we
; 610  : 	* we find a NULL pointer ofr we find that this is already 
; 611  : 	* in the table and duplicates were not allowed.
; 612  : 	*/
; 613  : 	newPointer	= &bucket->entries;

  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  0005c	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax
$LN2@antlr3Hash:

; 614  : 
; 615  : 	while   (*newPointer !=  NULL)

  00061	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00066	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006a	74 41		 je	 SHORT $LN3@antlr3Hash

; 616  : 	{
; 617  : 		/* The value at new pointer is pointing to an existing entry.
; 618  : 		* If duplicates are allowed then we don't care what it is, but
; 619  : 		* must reject this add if the key is the same as the one we are
; 620  : 		* supplied with.
; 621  : 		*/
; 622  : 		if  (table->allowDups == ANTLR3_FALSE)

  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  00071	83 38 00	 cmp	 DWORD PTR [rax], 0
  00074	75 24		 jne	 SHORT $LN4@antlr3Hash

; 623  : 		{
; 624  : 			if	(strcmp((const char*) key, (const char *)(*newPointer)->keybase.key.sKey) == 0)

  00076	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  0007b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00087	e8 00 00 00 00	 call	 strcmp
  0008c	85 c0		 test	 eax, eax
  0008e	75 0a		 jne	 SHORT $LN5@antlr3Hash

; 625  : 			{
; 626  : 				return	ANTLR3_ERR_HASHDUP;

  00090	b8 03 00 00 00	 mov	 eax, 3
  00095	e9 b9 00 00 00	 jmp	 $LN1@antlr3Hash
$LN5@antlr3Hash:
$LN4@antlr3Hash:

; 627  : 			}
; 628  : 		}
; 629  : 
; 630  : 		/* Point to the next entry pointer of the current entry we
; 631  : 		* are traversing, if it is NULL we will create our new
; 632  : 		* structure and point this to it.
; 633  : 		*/
; 634  : 		newPointer = &((*newPointer)->nextEntry);

  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  0009f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  000a6	48 89 44 24 38	 mov	 QWORD PTR newPointer$[rsp], rax

; 635  : 	}

  000ab	eb b4		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 636  : 
; 637  : 	/* newPointer is now poiting at the pointer where we need to
; 638  : 	* add our new entry, so let's crate the entry and add it in.
; 639  : 	*/
; 640  : 	entry   = (pANTLR3_HASH_ENTRY)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_HASH_ENTRY));

  000ad	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000b8	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 641  : 
; 642  : 	if	(entry == NULL)

  000bd	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  000c3	75 0a		 jne	 SHORT $LN6@antlr3Hash

; 643  : 	{
; 644  : 		return	ANTLR3_ERR_NOMEM;

  000c5	b8 01 00 00 00	 mov	 eax, 1
  000ca	e9 84 00 00 00	 jmp	 $LN1@antlr3Hash
$LN6@antlr3Hash:

; 645  : 	}
; 646  : 
; 647  : 	entry->data			= element;					/* Install the data element supplied				*/

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR element$[rsp]
  000d9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 648  : 	entry->free			= freeptr;					/* Function that knows how to release the entry	    */

  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000e2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR freeptr$[rsp]
  000e7	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 649  : 	entry->keybase.type	= ANTLR3_HASH_TYPE_STR;     /* Indicate the key type stored here for free()	    */

  000eb	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000f0	c6 00 01	 mov	 BYTE PTR [rax], 1

; 650  :     if  (table->doStrdup == ANTLR3_TRUE)

  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  000f8	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	75 16		 jne	 SHORT $LN7@antlr3Hash

; 651  :     {
; 652  :         entry->keybase.key.sKey	= ANTLR3_STRDUP(key);	/* Record the key value								*/

  00101	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0010c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  00111	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 653  :     }

  00115	eb 0e		 jmp	 SHORT $LN8@antlr3Hash
$LN7@antlr3Hash:

; 654  :     else
; 655  :     {
; 656  :         entry->keybase.key.sKey	= key;                  /* Record the key value								*/

  00117	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0011c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00121	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN8@antlr3Hash:

; 657  :     }
; 658  : 	entry->nextEntry		= NULL;					/* Ensure that the forward pointer ends the chain   */

  00125	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0012a	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 659  : 
; 660  : 	*newPointer	= entry;    /* Install the next entry in this bucket	*/

  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR newPointer$[rsp]
  00137	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  0013c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 661  : 
; 662  : 	table->count++;

  0013f	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  00144	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00147	ff c0		 inc	 eax
  00149	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  0014e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 663  : 
; 664  : 	return  ANTLR3_SUCCESS;

  00151	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 665  : }

  00153	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00157	5f		 pop	 rdi
  00158	c3		 ret	 0
antlr3HashPut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashRemove
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
nextPointer$ = 56
table$ = 80
key$ = 88
antlr3HashRemove PROC					; COMDAT

; 332  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 333  :     ANTLR3_UINT32	    hash;
; 334  :     pANTLR3_HASH_BUCKET	    bucket;
; 335  :     pANTLR3_HASH_ENTRY	    entry;
; 336  :     pANTLR3_HASH_ENTRY	    * nextPointer;
; 337  : 
; 338  :     /* First we need to know the hash of the provided key
; 339  :      */
; 340  :     hash    = antlr3Hash(key, (ANTLR3_UINT32)strlen((const char *)key));

  0000f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	8b d0		 mov	 edx, eax
  0001b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00020	e8 00 00 00 00	 call	 antlr3Hash
  00025	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 341  : 
; 342  :     /* Knowing the hash, we can find the bucket
; 343  :      */
; 344  :     bucket  = table->buckets + (hash % table->modulo);

  00029	33 d2		 xor	 edx, edx
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  0002f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00034	f7 71 04	 div	 DWORD PTR [rcx+4]
  00037	8b c2		 mov	 eax, edx
  00039	8b c0		 mov	 eax, eax
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00040	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00044	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00048	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 345  : 
; 346  :     /* Now, we traverse the entries in the bucket until
; 347  :      * we find the key or the end of the entires in the bucket. 
; 348  :      * We track the element prior to the one we are exmaining
; 349  :      * as we need to set its next pointer to the next pointer
; 350  :      * of the entry we are deleting (if we find it).
; 351  :      */
; 352  :     entry	    =   bucket->entries;    /* Entry to examine					    */

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 353  :     nextPointer	    = & bucket->entries;    /* Where to put the next pointer of the deleted entry   */

  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  0005f	48 89 44 24 38	 mov	 QWORD PTR nextPointer$[rsp], rax
$LN2@antlr3Hash:

; 354  : 
; 355  :     while   (entry != NULL)

  00064	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  0006a	0f 84 8e 00 00
	00		 je	 $LN3@antlr3Hash

; 356  :     {
; 357  : 	/* See if this is the entry we wish to delete
; 358  : 	 */
; 359  : 	if  (strcmp((const char *)key, (const char *)entry->keybase.key.sKey) == 0)

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00075	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00079	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  0007e	e8 00 00 00 00	 call	 strcmp
  00083	85 c0		 test	 eax, eax
  00085	75 56		 jne	 SHORT $LN4@antlr3Hash

; 360  : 	{
; 361  : 	    /* It was the correct entry, so we set the next pointer
; 362  : 	     * of the previous entry to the next pointer of this
; 363  : 	     * located one, which takes it out of the chain.
; 364  : 	     */
; 365  : 	    (*nextPointer)		= entry->nextEntry;

  00087	48 8b 44 24 38	 mov	 rax, QWORD PTR nextPointer$[rsp]
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR entry$[rsp]
  00091	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx

; 366  : 
; 367  : 	    /* Release the key - if we allocated that
; 368  : 	     */
; 369  :         if (table->doStrdup == ANTLR3_TRUE)

  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  0009d	0f b6 40 14	 movzx	 eax, BYTE PTR [rax+20]
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	75 0f		 jne	 SHORT $LN6@antlr3Hash

; 370  :         {
; 371  :             ANTLR3_FREE(entry->keybase.key.sKey);

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000ab	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@antlr3Hash:

; 372  :         }
; 373  : 	    entry->keybase.key.sKey	= NULL;

  000b5	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000ba	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 374  : 
; 375  : 	    table->count--;

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR table$[rsp]
  000c7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ca	ff c8		 dec	 eax
  000cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  000d1	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 376  : 
; 377  : 	    return entry;

  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000d9	eb 25		 jmp	 SHORT $LN1@antlr3Hash

; 378  : 	}

  000db	eb 1c		 jmp	 SHORT $LN5@antlr3Hash
$LN4@antlr3Hash:

; 379  : 	else
; 380  : 	{
; 381  : 	    /* We found an entry but it wasn't the one that was wanted, so
; 382  : 	     * move to the next one, if any.
; 383  : 	     */
; 384  : 	    nextPointer	= & (entry->nextEntry);	    /* Address of the next pointer in the current entry	    */

  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000e2	48 83 c0 20	 add	 rax, 32			; 00000020H
  000e6	48 89 44 24 38	 mov	 QWORD PTR nextPointer$[rsp], rax

; 385  : 	    entry	= entry->nextEntry;	    /* Address of the next element in the bucket (if any)   */

  000eb	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  000f0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000f4	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
$LN5@antlr3Hash:

; 386  : 	}
; 387  :     }

  000f9	e9 66 ff ff ff	 jmp	 $LN2@antlr3Hash
$LN3@antlr3Hash:

; 388  : 
; 389  :     return NULL;  /* Not found */

  000fe	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 390  : }

  00100	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
antlr3HashRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashGet
_TEXT	SEGMENT
hash$ = 32
bucket$ = 40
entry$ = 48
table$ = 80
key$ = 88
antlr3HashGet PROC					; COMDAT

; 484  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 485  :     ANTLR3_UINT32	    hash;
; 486  :     pANTLR3_HASH_BUCKET	    bucket;
; 487  :     pANTLR3_HASH_ENTRY	    entry;
; 488  : 
; 489  : 
; 490  :     /* First we need to know the hash of the provided key
; 491  :      */
; 492  :     hash    = antlr3Hash(key, (ANTLR3_UINT32)strlen((const char *)key));

  0000f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	8b d0		 mov	 edx, eax
  0001b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00020	e8 00 00 00 00	 call	 antlr3Hash
  00025	89 44 24 20	 mov	 DWORD PTR hash$[rsp], eax

; 493  : 
; 494  :     /* Knowing the hash, we can find the bucket
; 495  :      */
; 496  :     bucket  = table->buckets + (hash % table->modulo);

  00029	33 d2		 xor	 edx, edx
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR hash$[rsp]
  0002f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00034	f7 71 04	 div	 DWORD PTR [rcx+4]
  00037	8b c2		 mov	 eax, edx
  00039	8b c0		 mov	 eax, eax
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR table$[rsp]
  00040	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00044	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00048	48 89 44 24 28	 mov	 QWORD PTR bucket$[rsp], rax

; 497  : 
; 498  :     /* Now we can inspect the key at each entry in the bucket
; 499  :      * and see if we have a match.
; 500  :      */
; 501  :     entry   = bucket->entries;

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR bucket$[rsp]
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax
$LN2@antlr3Hash:

; 502  : 
; 503  :     while   (entry != NULL)

  0005a	48 83 7c 24 30
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00060	74 32		 je	 SHORT $LN3@antlr3Hash

; 504  :     {
; 505  : 	if  (strcmp((const char *)key, (const char *)entry->keybase.key.sKey) == 0)

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00067	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0006b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR key$[rsp]
  00070	e8 00 00 00 00	 call	 strcmp
  00075	85 c0		 test	 eax, eax
  00077	75 0b		 jne	 SHORT $LN4@antlr3Hash

; 506  : 	{
; 507  : 	    /* Match was found, return the data pointer for this entry
; 508  : 	     */
; 509  : 	    return  entry->data;

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  0007e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00082	eb 12		 jmp	 SHORT $LN1@antlr3Hash
$LN4@antlr3Hash:

; 510  : 	}
; 511  : 	entry = entry->nextEntry;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00089	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0008d	48 89 44 24 30	 mov	 QWORD PTR entry$[rsp], rax

; 512  :     }

  00092	eb c6		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 513  : 
; 514  :     /* If we got here, then we did not find the key
; 515  :      */
; 516  :     return  NULL;

  00094	33 c0		 xor	 eax, eax
$LN1@antlr3Hash:

; 517  : }

  00096	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
antlr3HashGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashDelete
_TEXT	SEGMENT
entry$ = 32
table$ = 64
key$ = 72
antlr3HashDelete PROC					; COMDAT

; 421  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 422  :     pANTLR3_HASH_ENTRY	entry;
; 423  : 
; 424  :     entry = antlr3HashRemove(table, key);

  0000f	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  00019	e8 00 00 00 00	 call	 antlr3HashRemove
  0001e	48 89 44 24 20	 mov	 QWORD PTR entry$[rsp], rax

; 425  : 	
; 426  :     /* Now we can free the elements and the entry in order
; 427  :      */
; 428  :     if	(entry != NULL && entry->free != NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR entry$[rsp], 0
  00029	74 2a		 je	 SHORT $LN2@antlr3Hash
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00030	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00035	74 1e		 je	 SHORT $LN2@antlr3Hash

; 429  :     {
; 430  : 	/* Call programmer supplied function to release this entry data
; 431  : 	 */
; 432  : 	entry->free(entry->data);

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0003c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  00045	ff 50 18	 call	 QWORD PTR [rax+24]

; 433  : 	entry->data = NULL;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR entry$[rsp]
  0004d	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN2@antlr3Hash:

; 434  :     }
; 435  :     /* Finally release the space for this entry block.
; 436  :      */
; 437  :     ANTLR3_FREE(entry);

  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR entry$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 438  : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
antlr3HashDelete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3TopoNew
_TEXT	SEGMENT
topo$ = 32
antlr3TopoNew PROC					; COMDAT

; 2285 : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2286 :     pANTLR3_TOPO topo = (pANTLR3_TOPO)ANTLR3_MALLOC(sizeof(ANTLR3_TOPO));

  00006	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00011	48 89 44 24 20	 mov	 QWORD PTR topo$[rsp], rax

; 2287 : 
; 2288 :     if  (topo == NULL)

  00016	48 83 7c 24 20
	00		 cmp	 QWORD PTR topo$[rsp], 0
  0001c	75 07		 jne	 SHORT $LN2@antlr3Topo

; 2289 :     {
; 2290 :         return NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	e9 99 00 00 00	 jmp	 $LN1@antlr3Topo
$LN2@antlr3Topo:

; 2291 :     }
; 2292 : 
; 2293 :     // Initialize variables
; 2294 :     //
; 2295 : 
; 2296 :     topo->visited   = NULL;                 // Don't know how big it is yet

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0002a	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 2297 :     topo->limit     = 1;                    // No edges added yet

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00037	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 2298 :     topo->edges     = NULL;                 // No edges added yet

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00043	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2299 :     topo->sorted    = NULL;                 // Nothing sorted at the start

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0004f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 2300 :     topo->cycle     = NULL;                 // No cycles at the start

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0005c	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 2301 :     topo->cycleMark = 0;                    // No cycles at the start

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00069	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 2302 :     topo->hasCycle  = ANTLR3_FALSE;         // No cycle at the start

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  00075	c6 40 18 00	 mov	 BYTE PTR [rax+24], 0

; 2303 :     
; 2304 :     // API
; 2305 :     //
; 2306 :     topo->addEdge       = addEdge;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addEdge
  00085	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 2307 :     topo->sortToArray   = sortToArray;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sortToArray
  00095	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 2308 :     topo->sortVector    = sortVector;

  00099	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sortVector
  000a5	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 2309 :     topo->free          = freeTopo;

  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:freeTopo
  000b5	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 2310 : 
; 2311 :     return topo;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR topo$[rsp]
$LN1@antlr3Topo:

; 2312 : }

  000be	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
antlr3TopoNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3SetVectorApi
_TEXT	SEGMENT
initialSize$ = 32
vector$ = 64
sizeHint$ = 72
antlr3SetVectorApi PROC					; COMDAT

; 1079 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1080 :     ANTLR3_UINT32   initialSize;
; 1081 : 
; 1082 :     // Allow vectors to be guessed by ourselves, so input size can be zero
; 1083 :     //
; 1084 :     if	(sizeHint > ANTLR3_VECTOR_INTERNAL_SIZE)

  0000e	83 7c 24 48 10	 cmp	 DWORD PTR sizeHint$[rsp], 16
  00013	76 0a		 jbe	 SHORT $LN2@antlr3SetV

; 1085 :     {
; 1086 :         initialSize = sizeHint;

  00015	8b 44 24 48	 mov	 eax, DWORD PTR sizeHint$[rsp]
  00019	89 44 24 20	 mov	 DWORD PTR initialSize$[rsp], eax

; 1087 :     }

  0001d	eb 08		 jmp	 SHORT $LN3@antlr3SetV
$LN2@antlr3SetV:

; 1088 :     else
; 1089 :     {
; 1090 :         initialSize = ANTLR3_VECTOR_INTERNAL_SIZE;

  0001f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR initialSize$[rsp], 16
$LN3@antlr3SetV:

; 1091 :     }
; 1092 : 
; 1093 :     if  (sizeHint > ANTLR3_VECTOR_INTERNAL_SIZE)

  00027	83 7c 24 48 10	 cmp	 DWORD PTR sizeHint$[rsp], 16
  0002c	76 1b		 jbe	 SHORT $LN4@antlr3SetV

; 1094 :     {
; 1095 :         vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR_ELEMENT) * initialSize));

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR initialSize$[rsp]
  00032	48 6b c0 10	 imul	 rax, rax, 16
  00036	48 8b c8	 mov	 rcx, rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00044	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1096 :     }

  00047	eb 11		 jmp	 SHORT $LN5@antlr3SetV
$LN4@antlr3SetV:

; 1097 :     else
; 1098 :     {
; 1099 :         vector->elements    = vector->internal;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0004e	48 83 c0 10	 add	 rax, 16
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  00057	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@antlr3SetV:

; 1100 :     }
; 1101 : 
; 1102 :     if	(vector->elements == NULL)

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0005f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00063	75 10		 jne	 SHORT $LN6@antlr3SetV

; 1103 :     {
; 1104 :         ANTLR3_FREE(vector);

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vector$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1105 :         return;

  00070	e9 d2 00 00 00	 jmp	 $LN1@antlr3SetV
$LN6@antlr3SetV:

; 1106 :     }
; 1107 : 
; 1108 :     // Memory allocated successfully
; 1109 :     //
; 1110 :     vector->count			= 0;			// No entries yet of course

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0007a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1111 :     vector->elementsSize    = initialSize;  // Available entries

  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00086	8b 4c 24 20	 mov	 ecx, DWORD PTR initialSize$[rsp]
  0008a	89 88 14 01 00
	00		 mov	 DWORD PTR [rax+276], ecx

; 1112 : 
; 1113 :     // Now we can install the API
; 1114 :     //
; 1115 :     vector->add	    = antlr3VectorAdd;

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorAdd
  0009c	48 89 88 48 01
	00 00		 mov	 QWORD PTR [rax+328], rcx

; 1116 :     vector->del	    = antlr3VectorDel;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorDel
  000af	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 1117 :     vector->get	    = antlr3VectorGet;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorGet
  000c2	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 1118 :     vector->free    = antlr3VectorFree;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorFree
  000d5	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 1119 :     vector->set	    = antlr3VectorSet;

  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorSet
  000e8	48 89 88 50 01
	00 00		 mov	 QWORD PTR [rax+336], rcx

; 1120 :     vector->remove  = antrl3VectorRemove;

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antrl3VectorRemove
  000fb	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 1121 :     vector->clear   = antlr3VectorClear;

  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorClear
  0010e	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 1122 :     vector->size    = antlr3VectorSize;

  00115	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorSize
  00121	48 89 88 58 01
	00 00		 mov	 QWORD PTR [rax+344], rcx

; 1123 :     vector->swap    = antlr3VectorSwap;

  00128	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3VectorSwap
  00134	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 1124 : 
; 1125 :     // Assume that this is not a factory made vector
; 1126 :     //
; 1127 :     vector->factoryMade	= ANTLR3_FALSE;

  0013b	48 8b 44 24 40	 mov	 rax, QWORD PTR vector$[rsp]
  00140	c6 80 10 01 00
	00 00		 mov	 BYTE PTR [rax+272], 0
$LN1@antlr3SetV:

; 1128 : }

  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
antlr3SetVectorApi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3StackNew
_TEXT	SEGMENT
stack$ = 32
sizeHint$ = 64
antlr3StackNew PROC					; COMDAT

; 965  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 966  :     pANTLR3_STACK   stack;
; 967  : 
; 968  :     /* Allocate memory
; 969  :      */
; 970  :     stack    = (pANTLR3_STACK)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_STACK));

  00009	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR stack$[rsp], rax

; 971  : 
; 972  :     if	(stack == NULL)

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR stack$[rsp], 0
  0001f	75 0a		 jne	 SHORT $LN2@antlr3Stac

; 973  :     {
; 974  : 	return	(pANTLR3_STACK)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	e9 95 00 00 00	 jmp	 $LN1@antlr3Stac
$LN2@antlr3Stac:

; 975  :     }
; 976  : 
; 977  :     /* Now we need to add a new table
; 978  :      */
; 979  :     stack->vector   = antlr3VectorNew(sizeHint);

  0002b	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  0002f	e8 00 00 00 00	 call	 antlr3VectorNew
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stack$[rsp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax

; 980  :     stack->top	    = NULL;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00041	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 981  : 
; 982  :     if	(stack->vector == (pANTLR3_VECTOR)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM))

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  0004e	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00052	75 07		 jne	 SHORT $LN3@antlr3Stac

; 983  :     {
; 984  : 	return	(pANTLR3_STACK)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	eb 65		 jmp	 SHORT $LN1@antlr3Stac
$LN3@antlr3Stac:

; 985  :     }
; 986  : 
; 987  :     /* Looks good, now add the interface
; 988  :      */
; 989  :     stack->get	=  antlr3StackGet;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackGet
  00067	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 990  :     stack->free	=  antlr3StackFree;

  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackFree
  00077	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 991  :     stack->pop	=  antlr3StackPop;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackPop
  00087	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 992  :     stack->push	=  antlr3StackPush;

  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackPush
  00097	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 993  :     stack->size	=  antlr3StackSize;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackSize
  000a7	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 994  :     stack->peek	=  antlr3StackPeek;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3StackPeek
  000b7	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 995  : 
; 996  :     return  stack;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR stack$[rsp]
$LN1@antlr3Stac:

; 997  : }

  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
antlr3StackNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorNew
_TEXT	SEGMENT
vector$ = 32
sizeHint$ = 64
antlr3VectorNew PROC					; COMDAT

; 1055 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1056 : 	pANTLR3_VECTOR  vector;
; 1057 : 
; 1058 : 
; 1059 : 	// Allocate memory for the vector structure itself
; 1060 : 	//
; 1061 : 	vector  = (pANTLR3_VECTOR) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR)));

  00009	b9 60 01 00 00	 mov	 ecx, 352		; 00000160H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR vector$[rsp], rax

; 1062 : 
; 1063 : 	if	(vector == NULL)

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR vector$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@antlr3Vect

; 1064 : 	{
; 1065 : 		return	(pANTLR3_VECTOR)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	eb 13		 jmp	 SHORT $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1066 : 	}
; 1067 : 
; 1068 : 	// Now fill in the defaults
; 1069 : 	//
; 1070 :     antlr3SetVectorApi(vector, sizeHint);

  00028	8b 54 24 40	 mov	 edx, DWORD PTR sizeHint$[rsp]
  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR vector$[rsp]
  00031	e8 00 00 00 00	 call	 antlr3SetVectorApi

; 1071 : 
; 1072 : 	// And everything is hunky dory
; 1073 : 	//
; 1074 : 	return  vector;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR vector$[rsp]
$LN1@antlr3Vect:

; 1075 : }

  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
antlr3VectorNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3VectorFactoryNew
_TEXT	SEGMENT
factory$ = 32
sizeHint$ = 64
antlr3VectorFactoryNew PROC				; COMDAT

; 1436 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1437 : 	pANTLR3_VECTOR_FACTORY  factory;
; 1438 : 
; 1439 : 	// Allocate memory for the factory
; 1440 : 	//
; 1441 : 	factory = (pANTLR3_VECTOR_FACTORY)ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR_FACTORY)));

  00009	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 1442 : 
; 1443 : 	if	(factory == NULL)

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@antlr3Vect

; 1444 : 	{
; 1445 : 		return	NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 98 00 00 00	 jmp	 $LN1@antlr3Vect
$LN2@antlr3Vect:

; 1446 : 	}
; 1447 : 
; 1448 : 	// Factory memory is good, so create a new vector pool
; 1449 : 	//
; 1450 :     factory->pools      = NULL;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0002d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1451 :     factory->thisPool   = -1;

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00039	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 1452 : 
; 1453 :     newPool(factory);

  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00045	e8 00 00 00 00	 call	 newPool

; 1454 : 
; 1455 :     // Initialize the API, ignore the hint as this algorithm does
; 1456 :     // a better job really.
; 1457 :     //
; 1458 :     antlr3SetVectorApi(&(factory->unTruc), ANTLR3_VECTOR_INTERNAL_SIZE);

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0004f	48 83 c0 10	 add	 rax, 16
  00053	ba 10 00 00 00	 mov	 edx, 16
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 antlr3SetVectorApi

; 1459 :     
; 1460 :     factory->unTruc.factoryMade = ANTLR3_TRUE;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00065	c6 80 20 01 00
	00 01		 mov	 BYTE PTR [rax+288], 1

; 1461 : 
; 1462 : 	// Install the factory API
; 1463 : 	//
; 1464 : 	factory->close			= closeVectorFactory;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:closeVectorFactory
  00078	48 89 88 78 01
	00 00		 mov	 QWORD PTR [rax+376], rcx

; 1465 : 	factory->newVector		= newVector;

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newVector
  0008b	48 89 88 80 01
	00 00		 mov	 QWORD PTR [rax+384], rcx

; 1466 : 	factory->returnVector	= returnVector;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:returnVector
  0009e	48 89 88 88 01
	00 00		 mov	 QWORD PTR [rax+392], rcx

; 1467 : 
; 1468 : 	// Create a stack to accumulate reusable vectors
; 1469 : 	//
; 1470 : 	factory->freeStack		= antlr3StackNew(16);

  000a5	b9 10 00 00 00	 mov	 ecx, 16
  000aa	e8 00 00 00 00	 call	 antlr3StackNew
  000af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000b4	48 89 81 70 01
	00 00		 mov	 QWORD PTR [rcx+368], rax

; 1471 : 	return  factory;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Vect:

; 1472 : }

  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
antlr3VectorFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3ListNew
_TEXT	SEGMENT
list$ = 32
sizeHint$ = 64
antlr3ListNew PROC					; COMDAT

; 864  : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 865  :     pANTLR3_LIST    list;
; 866  : 
; 867  :     /* Allocate memory
; 868  :      */
; 869  :     list    = (pANTLR3_LIST)ANTLR3_MALLOC((size_t)sizeof(ANTLR3_LIST));

  00009	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR list$[rsp], rax

; 870  : 
; 871  :     if	(list == NULL)

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR list$[rsp], 0
  0001f	75 0a		 jne	 SHORT $LN2@antlr3List

; 872  :     {
; 873  : 	return	(pANTLR3_LIST)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	e9 98 00 00 00	 jmp	 $LN1@antlr3List
$LN2@antlr3List:

; 874  :     }
; 875  : 
; 876  :     /* Now we need to add a new table
; 877  :      */
; 878  :     list->table	= antlr3HashTableNew(sizeHint);

  0002b	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  0002f	e8 00 00 00 00	 call	 antlr3HashTableNew
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax

; 879  : 
; 880  :     if	(list->table == (pANTLR3_HASH_TABLE)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM))

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00041	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00045	75 07		 jne	 SHORT $LN3@antlr3List

; 881  :     {
; 882  : 	return	(pANTLR3_LIST)ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	eb 75		 jmp	 SHORT $LN1@antlr3List
$LN3@antlr3List:

; 883  :     }
; 884  : 
; 885  :     /* Allocation was good, install interface
; 886  :      */
; 887  :     list->free	    =  antlr3ListFree;

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListFree
  0005a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 888  :     list->del	    =  antlr3ListDelete;

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListDelete
  0006a	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 889  :     list->get	    =  antlr3ListGet;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListGet
  0007a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 890  :     list->add	    =  antlr3ListAdd;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListAdd
  0008a	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 891  :     list->remove    =  antlr3ListRemove;

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListRemove
  0009a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 892  :     list->put	    =  antlr3ListPut;

  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListPut
  000aa	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 893  :     list->size	    =  antlr3ListSize;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3ListSize
  000ba	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 894  : 
; 895  :     return  list;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
$LN1@antlr3List:

; 896  : }

  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
antlr3ListNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3EnumNew
_TEXT	SEGMENT
en$ = 32
table$ = 64
antlr3EnumNew PROC					; COMDAT

; 674  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 675  :     pANTLR3_HASH_ENUM	en;
; 676  : 
; 677  :     /* Allocate structure memory
; 678  :      */
; 679  :     en    = (pANTLR3_HASH_ENUM) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_HASH_ENUM));

  0000a	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 20	 mov	 QWORD PTR en$[rsp], rax

; 680  : 
; 681  :     /* Check that the allocation was good 
; 682  :      */
; 683  :     if	(en == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR en$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@antlr3Enum

; 684  :     {
; 685  : 	return	(pANTLR3_HASH_ENUM) ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	eb 6c		 jmp	 SHORT $LN1@antlr3Enum
$LN2@antlr3Enum:

; 686  :     }
; 687  :     
; 688  :     /* Initialize the start pointers
; 689  :     */
; 690  :     en->table	= table;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR table$[rsp]
  00033	48 89 08	 mov	 QWORD PTR [rax], rcx

; 691  :     en->bucket	= 0;				/* First bucket		    */

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0003b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 692  :     en->entry	= en->table->buckets->entries;	/* First entry to return    */

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  00053	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00056	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 693  : 
; 694  :     /* Special case in that the first bucket may not have anything in it
; 695  :      * but the antlr3EnumNext() function expects that the en->entry is
; 696  :      * set to the next valid pointer. Hence if it is not a valid element
; 697  :      * pointer, attempt to find the next one that is, (table may be empty
; 698  :      * of course.
; 699  :      */
; 700  :     if	(en->entry == NULL)

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  0005f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00064	75 0a		 jne	 SHORT $LN3@antlr3Enum

; 701  :     {
; 702  : 	antlr3EnumNextEntry(en);

  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR en$[rsp]
  0006b	e8 00 00 00 00	 call	 antlr3EnumNextEntry
$LN3@antlr3Enum:

; 703  :     }
; 704  : 
; 705  :     /* Install the interface
; 706  :      */
; 707  :     en->free	=  antlr3EnumFree;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3EnumFree
  0007c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 708  :     en->next	=  antlr3EnumNext;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3EnumNext
  0008c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 709  : 
; 710  :     /* All is good
; 711  :      */
; 712  :     return  en;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR en$[rsp]
$LN1@antlr3Enum:

; 713  : }

  00095	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
antlr3EnumNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3Hash
_TEXT	SEGMENT
hash$ = 0
keyPtr$ = 8
i1$ = 16
key$ = 48
keylen$ = 56
antlr3Hash PROC						; COMDAT

; 835  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 836  :     /* Accumulate the hash value of the key
; 837  :      */
; 838  :     ANTLR3_UINT32   hash;
; 839  :     pANTLR3_UINT8   keyPtr;
; 840  :     ANTLR3_UINT32   i1;
; 841  : 
; 842  :     hash    = 0;

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR hash$[rsp], 0

; 843  :     keyPtr  = (pANTLR3_UINT8) key;

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR key$[rsp]
  0001a	48 89 44 24 08	 mov	 QWORD PTR keyPtr$[rsp], rax
$LN2@antlr3Hash:

; 844  : 
; 845  :     /* Iterate the key and accumulate the hash
; 846  :      */
; 847  :     while(keylen > 0)

  0001f	83 7c 24 38 00	 cmp	 DWORD PTR keylen$[rsp], 0
  00024	76 5e		 jbe	 SHORT $LN3@antlr3Hash

; 848  :     {
; 849  : 	hash = (hash << 4) + (*(keyPtr++));

  00026	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  00029	c1 e0 04	 shl	 eax, 4
  0002c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR keyPtr$[rsp]
  00031	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00034	03 c1		 add	 eax, ecx
  00036	89 04 24	 mov	 DWORD PTR hash$[rsp], eax
  00039	48 8b 44 24 08	 mov	 rax, QWORD PTR keyPtr$[rsp]
  0003e	48 ff c0	 inc	 rax
  00041	48 89 44 24 08	 mov	 QWORD PTR keyPtr$[rsp], rax

; 850  : 
; 851  : 	if ((i1=hash&0xf0000000) != 0)

  00046	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]
  00049	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  0004e	89 44 24 10	 mov	 DWORD PTR i1$[rsp], eax
  00052	83 7c 24 10 00	 cmp	 DWORD PTR i1$[rsp], 0
  00057	74 1f		 je	 SHORT $LN4@antlr3Hash

; 852  : 	{
; 853  : 		hash = hash ^ (i1 >> 24);

  00059	8b 44 24 10	 mov	 eax, DWORD PTR i1$[rsp]
  0005d	c1 e8 18	 shr	 eax, 24
  00060	8b 0c 24	 mov	 ecx, DWORD PTR hash$[rsp]
  00063	33 c8		 xor	 ecx, eax
  00065	8b c1		 mov	 eax, ecx
  00067	89 04 24	 mov	 DWORD PTR hash$[rsp], eax

; 854  : 		hash = hash ^ i1;

  0006a	8b 44 24 10	 mov	 eax, DWORD PTR i1$[rsp]
  0006e	8b 0c 24	 mov	 ecx, DWORD PTR hash$[rsp]
  00071	33 c8		 xor	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 04 24	 mov	 DWORD PTR hash$[rsp], eax
$LN4@antlr3Hash:

; 855  : 	}
; 856  : 	keylen--;

  00078	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0007c	ff c8		 dec	 eax
  0007e	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 857  :     }

  00082	eb 9b		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 858  : 
; 859  :     return  hash;

  00084	8b 04 24	 mov	 eax, DWORD PTR hash$[rsp]

; 860  : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
antlr3Hash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3HashTableNew
_TEXT	SEGMENT
table$ = 32
bucket$ = 40
sizeHint$ = 64
antlr3HashTableNew PROC					; COMDAT

; 127  : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 128  : 	// All we have to do is create the hashtable tracking structure
; 129  : 	// and allocate memory for the requested number of buckets.
; 130  : 	//
; 131  : 	pANTLR3_HASH_TABLE	table;
; 132  : 
; 133  : 	ANTLR3_UINT32	bucket;	// Used to traverse the buckets
; 134  : 
; 135  : 	table   = ANTLR3_MALLOC(sizeof(ANTLR3_HASH_TABLE));

  00009	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR table$[rsp], rax

; 136  : 
; 137  : 	// Error out if no memory left
; 138  : 	if	(table	== NULL)

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR table$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN5@antlr3Hash

; 139  : 	{
; 140  : 		return	NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 3e 01 00 00	 jmp	 $LN1@antlr3Hash
$LN5@antlr3Hash:

; 141  : 	}
; 142  : 
; 143  : 	// Allocate memory for the buckets
; 144  : 	//
; 145  : 	table->buckets = (pANTLR3_HASH_BUCKET) ANTLR3_MALLOC((size_t) (sizeof(ANTLR3_HASH_BUCKET) * sizeHint)); 

  00028	8b 44 24 40	 mov	 eax, DWORD PTR sizeHint$[rsp]
  0002c	48 c1 e0 03	 shl	 rax, 3
  00030	48 8b c8	 mov	 rcx, rax
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$[rsp]
  0003e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 146  : 
; 147  : 	if	(table->buckets == NULL)

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00047	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004c	75 12		 jne	 SHORT $LN6@antlr3Hash

; 148  : 	{
; 149  : 		ANTLR3_FREE((void *)table);

  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$[rsp]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 150  : 		return	NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 06 01 00 00	 jmp	 $LN1@antlr3Hash
$LN6@antlr3Hash:

; 151  : 	}
; 152  : 
; 153  : 	// Modulo of the table, (bucket count).
; 154  : 	//
; 155  : 	table->modulo   = sizeHint;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00065	8b 4c 24 40	 mov	 ecx, DWORD PTR sizeHint$[rsp]
  00069	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 156  : 
; 157  : 	table->count    = 0;	    /* Nothing in there yet ( I hope)	*/

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00071	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 158  : 
; 159  : 	/* Initialize the buckets to empty
; 160  : 	*/
; 161  : 	for	(bucket = 0; bucket < sizeHint; bucket++)

  00078	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR bucket$[rsp], 0
  00080	eb 0a		 jmp	 SHORT $LN4@antlr3Hash
$LN2@antlr3Hash:
  00082	8b 44 24 28	 mov	 eax, DWORD PTR bucket$[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 28	 mov	 DWORD PTR bucket$[rsp], eax
$LN4@antlr3Hash:
  0008c	8b 44 24 40	 mov	 eax, DWORD PTR sizeHint$[rsp]
  00090	39 44 24 28	 cmp	 DWORD PTR bucket$[rsp], eax
  00094	73 17		 jae	 SHORT $LN3@antlr3Hash

; 162  : 	{
; 163  : 		table->buckets[bucket].entries = NULL;

  00096	8b 44 24 28	 mov	 eax, DWORD PTR bucket$[rsp]
  0009a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$[rsp]
  0009f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a3	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 164  : 	}

  000ab	eb d5		 jmp	 SHORT $LN2@antlr3Hash
$LN3@antlr3Hash:

; 165  : 
; 166  : 	/* Exclude duplicate entries by default
; 167  : 	*/
; 168  : 	table->allowDups	= ANTLR3_FALSE;

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 169  : 
; 170  :     /* Assume that keys should by strduped before they are
; 171  :      * entered in the table.
; 172  :      */
; 173  :     table->doStrdup     = ANTLR3_TRUE;

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000bd	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 174  : 
; 175  : 	/* Install the interface
; 176  : 	*/
; 177  : 
; 178  : 	table->get		=  antlr3HashGet;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashGet
  000cd	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 179  : 	table->put		=  antlr3HashPut;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashPut
  000dd	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 180  : 	table->del		=  antlr3HashDelete;

  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashDelete
  000ed	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 181  : 	table->remove	=  antlr3HashRemove;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashRemove
  000fd	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 182  : 
; 183  : 	table->getI		=  antlr3HashGetI;

  00101	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashGetI
  0010d	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 184  : 	table->putI		=  antlr3HashPutI;

  00111	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashPutI
  0011d	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 185  : 	table->delI		=  antlr3HashDeleteI;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashDeleteI
  0012d	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 186  : 	table->removeI	=  antlr3HashRemoveI;

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashRemoveI
  0013d	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 187  : 
; 188  : 	table->size		=  antlr3HashSize;

  00141	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashSize
  0014d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 189  : 	table->free		=  antlr3HashFree;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3HashFree
  0015d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 190  : 
; 191  : 	return  table;

  00161	48 8b 44 24 20	 mov	 rax, QWORD PTR table$[rsp]
$LN1@antlr3Hash:

; 192  : }

  00166	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016a	5f		 pop	 rdi
  0016b	c3		 ret	 0
antlr3HashTableNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3collections.c
;	COMDAT antlr3IntTrieNew
_TEXT	SEGMENT
trie$ = 32
depth$ = 64
antlr3IntTrieNew PROC					; COMDAT

; 1769 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1770 : 	pANTLR3_INT_TRIE	trie;
; 1771 : 
; 1772 : 	trie    = (pANTLR3_INT_TRIE) ANTLR3_CALLOC(1, sizeof(ANTLR3_INT_TRIE));	/* Base memory required	*/

  00009	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00019	48 89 44 24 20	 mov	 QWORD PTR trie$[rsp], rax

; 1773 : 
; 1774 : 	if (trie == NULL)

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR trie$[rsp], 0
  00024	75 0a		 jne	 SHORT $LN2@antlr3IntT

; 1775 : 	{
; 1776 : 		return	(pANTLR3_INT_TRIE) ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	e9 bf 00 00 00	 jmp	 $LN1@antlr3IntT
$LN2@antlr3IntT:

; 1777 : 	}
; 1778 : 
; 1779 : 	/* Now we need to allocate the root node. This makes it easier
; 1780 : 	 * to use the tree as we don't have to do anything special 
; 1781 : 	 * for the root node.
; 1782 : 	 */
; 1783 : 	trie->root	= (pANTLR3_INT_TRIE_NODE) ANTLR3_CALLOC(1, sizeof(ANTLR3_INT_TRIE));

  00030	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  00035	b9 01 00 00 00	 mov	 ecx, 1
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1784 : 
; 1785 : 	if (trie->root == NULL)

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  0004d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00051	75 15		 jne	 SHORT $LN3@antlr3IntT

; 1786 : 	{
; 1787 : 		ANTLR3_FREE(trie);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1788 : 		return	(pANTLR3_INT_TRIE) ANTLR3_FUNC_PTR(ANTLR3_ERR_NOMEM);

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	e9 87 00 00 00	 jmp	 $LN1@antlr3IntT
$LN3@antlr3IntT:

; 1789 : 	}
; 1790 : 
; 1791 : 	trie->add	= intTrieAdd;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieAdd
  00074	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1792 : 	trie->del	= intTrieDel;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieDel
  00084	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1793 : 	trie->free	= intTrieFree;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieFree
  00094	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1794 : 	trie->get	= intTrieGet;

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:intTrieGet
  000a4	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1795 : 
; 1796 : 	/* Now we seed the root node with the index being the
; 1797 : 	 * highest left most bit we want to test, which limits the
; 1798 : 	 * keys in the trie. This is the trie 'depth'. The limit for
; 1799 : 	 * this implementation is 63 (bits 0..63).
; 1800 : 	 */
; 1801 : 	trie->root->bitNum = depth;

  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	8b 4c 24 40	 mov	 ecx, DWORD PTR depth$[rsp]
  000b4	89 08		 mov	 DWORD PTR [rax], ecx

; 1802 : 
; 1803 : 	/* And as we have nothing in here yet, we set both child pointers
; 1804 : 	 * of the root node to point back to itself.
; 1805 : 	 */
; 1806 : 	trie->root->leftN	= trie->root;

  000b6	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000bb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  000c3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1807 : 	trie->root->rightN	= trie->root;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trie$[rsp]
  000d7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000da	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1808 : 	trie->count			= 0;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
  000e3	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 1809 : 
; 1810 : 	/* Finally, note that the key for this root node is 0 because
; 1811 : 	 * we use calloc() to initialise it.
; 1812 : 	 */
; 1813 : 
; 1814 : 	return trie;

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR trie$[rsp]
$LN1@antlr3IntT:

; 1815 : }

  000ef	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
antlr3IntTrieNew ENDP
_TEXT	ENDS
END
