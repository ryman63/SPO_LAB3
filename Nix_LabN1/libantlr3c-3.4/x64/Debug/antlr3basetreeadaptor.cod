; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34435.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	antlr3BaseTreeAdaptorInit
PUBLIC	??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@	; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n@				; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r@				; `string'
PUBLIC	??_C@_03EKALBCDP@?$CC?$FN?6@			; `string'
PUBLIC	??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@ ; `string'
PUBLIC	??_C@_04BBDFLMDN@?5?9?$DO?5@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@ ; `string'
PUBLIC	??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@ ; `string'
PUBLIC	??_C@_02JHLIKEIA@?6?$HN@			; `string'
PUBLIC	??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@ ; `string'
PUBLIC	??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@ ; `string'
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BaseTreeAdaptorInit DD imagerel $LN5
	DD	imagerel $LN5+569
	DD	imagerel $unwind$antlr3BaseTreeAdaptorInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nilNode DD imagerel nilNode
	DD	imagerel nilNode+34
	DD	imagerel $unwind$nilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgNil DD imagerel dbgNil
	DD	imagerel dbgNil+73
	DD	imagerel $unwind$dbgNil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTree DD imagerel dupTree
	DD	imagerel dupTree+42
	DD	imagerel $unwind$dupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgDupTree DD imagerel dbgDupTree
	DD	imagerel dbgDupTree+67
	DD	imagerel $unwind$dbgDupTree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dupTreeTT DD imagerel dupTreeTT
	DD	imagerel dupTreeTT+267
	DD	imagerel $unwind$dupTreeTT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChild DD imagerel addChild
	DD	imagerel addChild+61
	DD	imagerel $unwind$addChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgAddChild DD imagerel dbgAddChild
	DD	imagerel dbgAddChild+95
	DD	imagerel $unwind$dbgAddChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$becomeRoot DD imagerel becomeRoot
	DD	imagerel becomeRoot+249
	DD	imagerel $unwind$becomeRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgBecomeRoot DD imagerel dbgBecomeRoot
	DD	imagerel dbgBecomeRoot+90
	DD	imagerel $unwind$dbgBecomeRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rulePostProcessing DD imagerel rulePostProcessing
	DD	imagerel rulePostProcessing+196
	DD	imagerel $unwind$rulePostProcessing
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addChildToken DD imagerel addChildToken
	DD	imagerel addChildToken+85
	DD	imagerel $unwind$addChildToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgAddChildToken DD imagerel dbgAddChildToken
	DD	imagerel dbgAddChildToken+126
	DD	imagerel $unwind$dbgAddChildToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$becomeRootToken DD imagerel becomeRootToken
	DD	imagerel becomeRootToken+68
	DD	imagerel $unwind$becomeRootToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgBecomeRootToken DD imagerel dbgBecomeRootToken
	DD	imagerel dbgBecomeRootToken+112
	DD	imagerel $unwind$dbgBecomeRootToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTypeToken DD imagerel createTypeToken
	DD	imagerel createTypeToken+92
	DD	imagerel $unwind$createTypeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreateTypeToken DD imagerel dbgCreateTypeToken
	DD	imagerel dbgCreateTypeToken+83
	DD	imagerel $unwind$dbgCreateTypeToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTypeTokenText DD imagerel createTypeTokenText
	DD	imagerel createTypeTokenText+118
	DD	imagerel $unwind$createTypeTokenText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreateTypeTokenText DD imagerel dbgCreateTypeTokenText
	DD	imagerel dbgCreateTypeTokenText+93
	DD	imagerel $unwind$dbgCreateTypeTokenText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$createTypeText DD imagerel createTypeText
	DD	imagerel createTypeText+76
	DD	imagerel $unwind$createTypeText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbgCreateTypeText DD imagerel dbgCreateTypeText
	DD	imagerel dbgCreateTypeText+83
	DD	imagerel $unwind$dbgCreateTypeText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+15
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setType DD imagerel setType
	DD	imagerel setType+53
	DD	imagerel $unwind$setType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+49
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText DD imagerel setText
	DD	imagerel setText+48
	DD	imagerel $unwind$setText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText8 DD imagerel setText8
	DD	imagerel setText8+48
	DD	imagerel $unwind$setText8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChild DD imagerel getChild
	DD	imagerel getChild+54
	DD	imagerel $unwind$getChild
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChildCount DD imagerel getChildCount
	DD	imagerel getChildCount+49
	DD	imagerel $unwind$getChildCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getUniqueID DD imagerel getUniqueID
	DD	imagerel getUniqueID+17
	DD	imagerel $unwind$getUniqueID
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isNilNode DD imagerel isNilNode
	DD	imagerel isNilNode+37
	DD	imagerel $unwind$isNilNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$makeDot DD imagerel makeDot
	DD	imagerel makeDot+625
	DD	imagerel $unwind$makeDot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defineDotNodes DD imagerel defineDotNodes
	DD	imagerel defineDotNodes+629
	DD	imagerel $unwind$defineDotNodes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defineDotEdges DD imagerel defineDotEdges
	DD	imagerel defineDotEdges+981
	DD	imagerel $unwind$defineDotEdges
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$simulateTreeConstruction DD imagerel simulateTreeConstruction
	DD	imagerel simulateTreeConstruction+188
	DD	imagerel $unwind$simulateTreeConstruction
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement getChildCount()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement getChild()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement setText()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement getText()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement setType()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@
CONST	SEGMENT
??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@ DB 'More tha'
	DB	'n one node as root! TODO: Create tree exception handling', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHLIKEIA@?6?$HN@
CONST	SEGMENT
??_C@_02JHLIKEIA@?6?$HN@ DB 0aH, '}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@
CONST	SEGMENT
??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@ DB 'n0[label='
	DB	'"EMPTY TREE"]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@
CONST	SEGMENT
??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@ DB 'di'
	DB	'graph {', 0aH, 0aH, 09H, 'ordering=out;', 0aH, 09H, 'ranksep='
	DB	'.4;', 0aH, 09H, 'bgcolor="lightgrey";  node [shape=box, fixed'
	DB	'size=false, fontsize=12, fontname="Helvetica-bold", fontcolor'
	DB	'="blue"', 0aH, 09H, 'width=.25, height=.25, color="black", fi'
	DB	'llcolor="white", style="filled, solid, bold"];', 0aH, 0aH, 09H
	DB	'edge [arrowsize=.5, color="black", style="bold"]', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BBDFLMDN@?5?9?$DO?5@
CONST	SEGMENT
??_C@_04BBDFLMDN@?5?9?$DO?5@ DB ' -> ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@
CONST	SEGMENT
??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@ DB 09H, 09H, 'n%'
	DB	'p -> n%p', 09H, 09H, '// ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EKALBCDP@?$CC?$FN?6@
CONST	SEGMENT
??_C@_03EKALBCDP@?$CC?$FN?6@ DB '"]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC@ DB '\"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@
CONST	SEGMENT
??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@ DB 09H, 'n%p[label="', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$simulateTreeConstruction DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	03bcH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defineDotEdges DD 034219H
	DD	01e0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
defineDotEdges$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+11
defineDotEdges$rtcVarDesc DD 040H
	DD	080H
	DQ	FLAT:defineDotEdges$rtcName$0
	ORG $+48
defineDotEdges$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:defineDotEdges$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	025cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defineDotNodes DD 034219H
	DD	0160117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
defineDotNodes$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+11
defineDotNodes$rtcVarDesc DD 040H
	DD	040H
	DQ	FLAT:defineDotNodes$rtcName$0
	ORG $+48
defineDotNodes$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:defineDotNodes$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	0258H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$makeDot DD 033d19H
	DD	0160112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
makeDot$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+11
makeDot$rtcVarDesc DD 040H
	DD	040H
	DQ	FLAT:makeDot$rtcName$0
	ORG $+48
makeDot$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:makeDot$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isNilNode DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getUniqueID DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChildCount DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChild DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText8 DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setType DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreateTypeText DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTypeText DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreateTypeTokenText DD 021801H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTypeTokenText DD 021801H
	DD	070143218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgCreateTypeToken DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$createTypeToken DD 021301H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgBecomeRootToken DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$becomeRootToken DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgAddChildToken DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChildToken DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rulePostProcessing DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgBecomeRoot DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$becomeRoot DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgAddChild DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addChild DD 021401H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTreeTT DD 021401H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgDupTree DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dupTree DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbgNil DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nilNode DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BaseTreeAdaptorInit DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT simulateTreeConstruction
_TEXT	SEGMENT
n$ = 32
i$ = 36
child$ = 40
adaptor$ = 64
tree$ = 72
simulateTreeConstruction PROC				; COMDAT

; 501  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 502  : 	ANTLR3_UINT32		n;
; 503  : 	ANTLR3_UINT32		i;
; 504  : 	pANTLR3_BASE_TREE	child;
; 505  : 
; 506  : 	// Send the create node event
; 507  : 	//
; 508  : 	adaptor->debugger->createNode(adaptor->debugger, tree);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00014	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00022	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00026	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 509  : 
; 510  : 	n = adaptor->getChildCount(adaptor, tree);

  0002c	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003b	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  00041	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 511  : 	for	(i = 0; i < n; i++)

  00045	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004d	eb 0a		 jmp	 SHORT $LN4@simulateTr
$LN2@simulateTr:
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00053	ff c0		 inc	 eax
  00055	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@simulateTr:
  00059	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0005d	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00061	73 53		 jae	 SHORT $LN3@simulateTr

; 512  : 	{
; 513  : 		child = adaptor->getChild(adaptor, tree, i);

  00063	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  00068	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00077	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0007d	48 89 44 24 28	 mov	 QWORD PTR child$[rsp], rax

; 514  : 		simulateTreeConstruction(adaptor, child);

  00082	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0008c	e8 00 00 00 00	 call	 simulateTreeConstruction

; 515  : 		adaptor->debugger->addChild(adaptor->debugger, tree, child);

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00096	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0009a	4c 8b 44 24 28	 mov	 r8, QWORD PTR child$[rsp]
  0009f	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000a9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000ad	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
  000b3	90		 npad	 1

; 516  : 	}

  000b4	eb 99		 jmp	 SHORT $LN2@simulateTr
$LN3@simulateTr:

; 517  : }

  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
simulateTreeConstruction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT defineDotEdges
_TEXT	SEGMENT
nCount$ = 32
i$ = 36
child$4 = 40
buff$5 = 64
text$6 = 200
j$7 = 208
tv95 = 224
tv161 = 228
__$ArrayPad$ = 232
adaptor$ = 256
t$ = 264
dotSpec$ = 272
defineDotEdges PROC					; COMDAT

; 241  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR [rsp+256]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 242  : 	// How many nodes are we talking about?
; 243  : 	//
; 244  : 	int	nCount;
; 245  : 	int i;
; 246  : 
; 247  : 	if	(t == NULL)

  00042	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR t$[rsp], 0
  0004b	75 05		 jne	 SHORT $LN15@defineDotE

; 248  : 	{
; 249  : 		// No tree, so do nothing
; 250  : 		//
; 251  : 		return;

  0004d	e9 5b 03 00 00	 jmp	 $LN1@defineDotE
$LN15@defineDotE:

; 252  : 	}
; 253  : 
; 254  : 	// Count the nodes
; 255  : 	//
; 256  : 	nCount = adaptor->getChildCount(adaptor, t);

  00052	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0005a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00062	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006a	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  00070	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 257  : 
; 258  : 	if	(nCount == 0)

  00074	83 7c 24 20 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00079	75 05		 jne	 SHORT $LN16@defineDotE

; 259  : 	{
; 260  : 		// This will already have been included as a child of another node
; 261  : 		// so there is nothing to add.
; 262  : 		//
; 263  : 		return;

  0007b	e9 2d 03 00 00	 jmp	 $LN1@defineDotE
$LN16@defineDotE:

; 264  : 	}
; 265  : 
; 266  : 	// For each child, define an edge from this parent, then process
; 267  : 	// and children of this child in the same way
; 268  : 	//
; 269  : 	for	(i=0; i<nCount; i++)

  00080	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00088	eb 0a		 jmp	 SHORT $LN4@defineDotE
$LN2@defineDotE:
  0008a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0008e	ff c0		 inc	 eax
  00090	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@defineDotE:
  00094	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  00098	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0009c	0f 8d 0b 03 00
	00		 jge	 $LN3@defineDotE

; 270  : 	{
; 271  : 		pANTLR3_BASE_TREE child;
; 272  : 		char	buff[128];
; 273  :         pANTLR3_STRING text;
; 274  :         int                 j;
; 275  : 
; 276  : 		// Next child
; 277  : 		//
; 278  : 		child	= adaptor->getChild(adaptor, t, i);

  000a2	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  000a7	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  000af	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000b7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000bf	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000c5	48 89 44 24 28	 mov	 QWORD PTR child$4[rsp], rax

; 279  : 
; 280  : 		// Create the edge relation
; 281  : 		//
; 282  : 		sprintf(buff, "\t\tn%p -> n%p\t\t// ",  t, child);

  000ca	4c 8b 4c 24 28	 mov	 r9, QWORD PTR child$4[rsp]
  000cf	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR t$[rsp]
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@
  000de	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buff$5[rsp]
  000e3	e8 00 00 00 00	 call	 sprintf

; 283  :         
; 284  : 		dotSpec->append8(dotSpec, buff);

  000e8	48 8d 54 24 40	 lea	 rdx, QWORD PTR buff$5[rsp]
  000ed	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  000f5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  000fd	ff 50 38	 call	 QWORD PTR [rax+56]

; 285  : 
; 286  : 		// Document the relationship
; 287  : 		//
; 288  :         text = adaptor->getText(adaptor, t);

  00100	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00108	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00110	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00118	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  0011e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR text$6[rsp], rax

; 289  : 		for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  00126	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$7[rsp], 0
  00131	eb 10		 jmp	 SHORT $LN7@defineDotE
$LN5@defineDotE:
  00133	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR j$7[rsp]
  0013a	ff c0		 inc	 eax
  0013c	89 84 24 d0 00
	00 00		 mov	 DWORD PTR j$7[rsp], eax
$LN7@defineDotE:
  00143	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  0014b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0014e	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR j$7[rsp], eax
  00155	0f 8d d3 00 00
	00		 jge	 $LN6@defineDotE

; 290  :         {
; 291  :                 switch(text->charAt(text, j))

  0015b	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  00162	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  0016a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00172	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00178	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv95[rsp], eax
  0017f	83 bc 24 e0 00
	00 00 0a	 cmp	 DWORD PTR tv95[rsp], 10
  00187	74 33		 je	 SHORT $LN18@defineDotE
  00189	83 bc 24 e0 00
	00 00 0d	 cmp	 DWORD PTR tv95[rsp], 13
  00191	74 46		 je	 SHORT $LN19@defineDotE
  00193	83 bc 24 e0 00
	00 00 22	 cmp	 DWORD PTR tv95[rsp], 34	; 00000022H
  0019b	74 02		 je	 SHORT $LN17@defineDotE
  0019d	eb 57		 jmp	 SHORT $LN20@defineDotE
$LN17@defineDotE:

; 292  :                 {
; 293  :                     case '"':
; 294  : 
; 295  :                         dotSpec->append8(dotSpec, "\\\"");

  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC@
  001a6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001ae	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001b6	ff 50 38	 call	 QWORD PTR [rax+56]
  001b9	90		 npad	 1

; 296  :                         break;

  001ba	eb 6d		 jmp	 SHORT $LN8@defineDotE
$LN18@defineDotE:

; 297  : 
; 298  :                     case '\n':
; 299  : 
; 300  :                         dotSpec->append8(dotSpec, "\\n");

  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n@
  001c3	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001cb	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001d3	ff 50 38	 call	 QWORD PTR [rax+56]
  001d6	90		 npad	 1

; 301  :                         break;

  001d7	eb 50		 jmp	 SHORT $LN8@defineDotE
$LN19@defineDotE:

; 302  : 
; 303  :                     case '\r':
; 304  : 
; 305  :                         dotSpec->append8(dotSpec, "\\r");

  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r@
  001e0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001e8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001f0	ff 50 38	 call	 QWORD PTR [rax+56]
  001f3	90		 npad	 1

; 306  :                         break;

  001f4	eb 33		 jmp	 SHORT $LN8@defineDotE
$LN20@defineDotE:

; 307  : 
; 308  :                     default:
; 309  : 
; 310  :                         dotSpec->addc(dotSpec, text->charAt(text, j));

  001f6	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  001fd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  00205	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  0020d	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00213	8b d0		 mov	 edx, eax
  00215	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0021d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00225	ff 50 70	 call	 QWORD PTR [rax+112]
  00228	90		 npad	 1
$LN8@defineDotE:

; 311  :                         break;
; 312  :                 }
; 313  :         }

  00229	e9 05 ff ff ff	 jmp	 $LN5@defineDotE
$LN6@defineDotE:

; 314  : 
; 315  :         dotSpec->append8(dotSpec, " -> ");

  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BBDFLMDN@?5?9?$DO?5@
  00235	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0023d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00245	ff 50 38	 call	 QWORD PTR [rax+56]

; 316  : 
; 317  :         text = adaptor->getText(adaptor, child);

  00248	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$4[rsp]
  0024d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00255	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  0025d	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00263	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR text$6[rsp], rax

; 318  :         for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  0026b	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$7[rsp], 0
  00276	eb 10		 jmp	 SHORT $LN12@defineDotE
$LN10@defineDotE:
  00278	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR j$7[rsp]
  0027f	ff c0		 inc	 eax
  00281	89 84 24 d0 00
	00 00		 mov	 DWORD PTR j$7[rsp], eax
$LN12@defineDotE:
  00288	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00290	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00293	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR j$7[rsp], eax
  0029a	0f 8d d3 00 00
	00		 jge	 $LN11@defineDotE

; 319  :         {
; 320  :                 switch(text->charAt(text, j))

  002a0	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  002a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  002af	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  002b7	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  002bd	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  002c4	83 bc 24 e4 00
	00 00 0a	 cmp	 DWORD PTR tv161[rsp], 10
  002cc	74 33		 je	 SHORT $LN22@defineDotE
  002ce	83 bc 24 e4 00
	00 00 0d	 cmp	 DWORD PTR tv161[rsp], 13
  002d6	74 46		 je	 SHORT $LN23@defineDotE
  002d8	83 bc 24 e4 00
	00 00 22	 cmp	 DWORD PTR tv161[rsp], 34 ; 00000022H
  002e0	74 02		 je	 SHORT $LN21@defineDotE
  002e2	eb 57		 jmp	 SHORT $LN24@defineDotE
$LN21@defineDotE:

; 321  :                 {
; 322  :                     case '"':
; 323  : 
; 324  :                         dotSpec->append8(dotSpec, "\\\"");

  002e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC@
  002eb	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  002f3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  002fb	ff 50 38	 call	 QWORD PTR [rax+56]
  002fe	90		 npad	 1

; 325  :                         break;

  002ff	eb 6d		 jmp	 SHORT $LN13@defineDotE
$LN22@defineDotE:

; 326  : 
; 327  :                     case '\n':
; 328  : 
; 329  :                         dotSpec->append8(dotSpec, "\\n");

  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n@
  00308	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00310	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00318	ff 50 38	 call	 QWORD PTR [rax+56]
  0031b	90		 npad	 1

; 330  :                         break;

  0031c	eb 50		 jmp	 SHORT $LN13@defineDotE
$LN23@defineDotE:

; 331  : 
; 332  :                     case '\r':
; 333  : 
; 334  :                         dotSpec->append8(dotSpec, "\\r");

  0031e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r@
  00325	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0032d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00335	ff 50 38	 call	 QWORD PTR [rax+56]
  00338	90		 npad	 1

; 335  :                         break;

  00339	eb 33		 jmp	 SHORT $LN13@defineDotE
$LN24@defineDotE:

; 336  : 
; 337  :                     default:
; 338  : 
; 339  :                         dotSpec->addc(dotSpec, text->charAt(text, j));

  0033b	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR j$7[rsp]
  00342	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR text$6[rsp]
  0034a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR text$6[rsp]
  00352	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00358	8b d0		 mov	 edx, eax
  0035a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00362	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0036a	ff 50 70	 call	 QWORD PTR [rax+112]
  0036d	90		 npad	 1
$LN13@defineDotE:

; 340  :                         break;
; 341  :                 }
; 342  :         }

  0036e	e9 05 ff ff ff	 jmp	 $LN10@defineDotE
$LN11@defineDotE:

; 343  : 		dotSpec->append8(dotSpec, "\n");

  00373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
  0037a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00382	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0038a	ff 50 38	 call	 QWORD PTR [rax+56]

; 344  : 
; 345  :         
; 346  : 		// Define edges for this child
; 347  : 		//
; 348  : 		defineDotEdges(adaptor, child, dotSpec);

  0038d	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR dotSpec$[rsp]
  00395	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$4[rsp]
  0039a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  003a2	e8 00 00 00 00	 call	 defineDotEdges
  003a7	90		 npad	 1

; 349  : 	}

  003a8	e9 dd fc ff ff	 jmp	 $LN2@defineDotE
$LN3@defineDotE:
$LN1@defineDotE:

; 350  : 
; 351  : 	// Done
; 352  : 	//
; 353  : 	return;
; 354  : }

  003ad	48 8b cc	 mov	 rcx, rsp
  003b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:defineDotEdges$rtcFrameData
  003b7	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  003bc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c4	48 33 cc	 xor	 rcx, rsp
  003c7	e8 00 00 00 00	 call	 __security_check_cookie
  003cc	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  003d3	5f		 pop	 rdi
  003d4	c3		 ret	 0
defineDotEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT defineDotNodes
_TEXT	SEGMENT
nCount$ = 32
i$ = 36
child$ = 40
buff$ = 64
text$ = 136
j$ = 144
tv93 = 160
__$ArrayPad$ = 168
adaptor$ = 192
t$ = 200
dotSpec$ = 208
defineDotNodes PROC					; COMDAT

; 161  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+192]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 162  : 	// How many nodes are we talking about?
; 163  : 	//
; 164  : 	int	nCount;
; 165  : 	int i;
; 166  :     pANTLR3_BASE_TREE child;
; 167  : 	char	buff[64];
; 168  : 	pANTLR3_STRING	text;
; 169  : 	int		j;
; 170  : 
; 171  : 
; 172  : 
; 173  : 
; 174  : 
; 175  : 	// Count the nodes
; 176  : 	//
; 177  : 	nCount = adaptor->getChildCount(adaptor, t);

  00042	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0004a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00052	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005a	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  00060	89 44 24 20	 mov	 DWORD PTR nCount$[rsp], eax

; 178  : 
; 179  : 	if	(nCount == 0)

  00064	83 7c 24 20 00	 cmp	 DWORD PTR nCount$[rsp], 0
  00069	75 05		 jne	 SHORT $LN10@defineDotN

; 180  : 	{
; 181  : 		// This will already have been included as a child of another node
; 182  : 		// so there is nothing to add.
; 183  : 		//
; 184  : 		return;

  0006b	e9 dd 01 00 00	 jmp	 $LN1@defineDotN
$LN10@defineDotN:

; 185  : 	}
; 186  : 
; 187  : 	// For each child of the current tree, define a node using the
; 188  : 	// memory address of the node to name it
; 189  : 	//
; 190  : 	for	(i = 0; i<nCount; i++)

  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00078	eb 0a		 jmp	 SHORT $LN4@defineDotN
$LN2@defineDotN:
  0007a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0007e	ff c0		 inc	 eax
  00080	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@defineDotN:
  00084	8b 44 24 20	 mov	 eax, DWORD PTR nCount$[rsp]
  00088	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0008c	0f 8d bb 01 00
	00		 jge	 $LN3@defineDotN

; 191  : 	{
; 192  : 
; 193  : 		// Pick up a pointer for the child
; 194  : 		//
; 195  : 		child = adaptor->getChild(adaptor, t, i);

  00092	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  00097	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0009f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000af	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000b5	48 89 44 24 28	 mov	 QWORD PTR child$[rsp], rax

; 196  : 
; 197  : 		// Name the node
; 198  : 		//
; 199  : 		sprintf(buff, "\tn%p[label=\"", child);

  000ba	4c 8b 44 24 28	 mov	 r8, QWORD PTR child$[rsp]
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@
  000c6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buff$[rsp]
  000cb	e8 00 00 00 00	 call	 sprintf

; 200  : 		dotSpec->append8(dotSpec, buff);

  000d0	48 8d 54 24 40	 lea	 rdx, QWORD PTR buff$[rsp]
  000d5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  000dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  000e5	ff 50 38	 call	 QWORD PTR [rax+56]

; 201  : 		text = adaptor->getText(adaptor, child);

  000e8	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  000ed	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000f5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000fd	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  00103	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR text$[rsp], rax

; 202  : 		for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  0010b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00116	eb 10		 jmp	 SHORT $LN7@defineDotN
$LN5@defineDotN:
  00118	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0011f	ff c0		 inc	 eax
  00121	89 84 24 90 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN7@defineDotN:
  00128	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  00130	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00133	39 84 24 90 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  0013a	0f 8d d3 00 00
	00		 jge	 $LN6@defineDotN

; 203  : 		{
; 204  :             switch(text->charAt(text, j))

  00140	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  00147	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  0014f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  00157	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0015d	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
  00164	83 bc 24 a0 00
	00 00 0a	 cmp	 DWORD PTR tv93[rsp], 10
  0016c	74 33		 je	 SHORT $LN12@defineDotN
  0016e	83 bc 24 a0 00
	00 00 0d	 cmp	 DWORD PTR tv93[rsp], 13
  00176	74 46		 je	 SHORT $LN13@defineDotN
  00178	83 bc 24 a0 00
	00 00 22	 cmp	 DWORD PTR tv93[rsp], 34	; 00000022H
  00180	74 02		 je	 SHORT $LN11@defineDotN
  00182	eb 57		 jmp	 SHORT $LN14@defineDotN
$LN11@defineDotN:

; 205  :             {
; 206  :                 case '"':
; 207  : 
; 208  :                     dotSpec->append8(dotSpec, "\\\"");

  00184	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC@
  0018b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00193	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0019b	ff 50 38	 call	 QWORD PTR [rax+56]
  0019e	90		 npad	 1

; 209  :                     break;

  0019f	eb 6d		 jmp	 SHORT $LN8@defineDotN
$LN12@defineDotN:

; 210  : 
; 211  :                 case '\n':
; 212  : 
; 213  :                     dotSpec->append8(dotSpec, "\\n");

  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n@
  001a8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001b0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001b8	ff 50 38	 call	 QWORD PTR [rax+56]
  001bb	90		 npad	 1

; 214  :                     break;

  001bc	eb 50		 jmp	 SHORT $LN8@defineDotN
$LN13@defineDotN:

; 215  : 
; 216  :                 case '\r':
; 217  : 
; 218  :                     dotSpec->append8(dotSpec, "\\r");

  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r@
  001c5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001cd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001d5	ff 50 38	 call	 QWORD PTR [rax+56]
  001d8	90		 npad	 1

; 219  :                     break;

  001d9	eb 33		 jmp	 SHORT $LN8@defineDotN
$LN14@defineDotN:

; 220  : 
; 221  :                 default:
; 222  : 
; 223  :                     dotSpec->addc(dotSpec, text->charAt(text, j));

  001db	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  001e2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  001ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  001f2	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  001f8	8b d0		 mov	 edx, eax
  001fa	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00202	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0020a	ff 50 70	 call	 QWORD PTR [rax+112]
  0020d	90		 npad	 1
$LN8@defineDotN:

; 224  :                     break;
; 225  :             }
; 226  : 		}

  0020e	e9 05 ff ff ff	 jmp	 $LN5@defineDotN
$LN6@defineDotN:

; 227  : 		dotSpec->append8(dotSpec, "\"]\n");

  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EKALBCDP@?$CC?$FN?6@
  0021a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00222	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0022a	ff 50 38	 call	 QWORD PTR [rax+56]

; 228  : 
; 229  : 		// And now define the children of this child (if any)
; 230  : 		//
; 231  : 		defineDotNodes(adaptor, child, dotSpec);

  0022d	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR dotSpec$[rsp]
  00235	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  0023a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00242	e8 00 00 00 00	 call	 defineDotNodes
  00247	90		 npad	 1

; 232  : 	}

  00248	e9 2d fe ff ff	 jmp	 $LN2@defineDotN
$LN3@defineDotN:
$LN1@defineDotN:

; 233  : 	
; 234  : 	// Done
; 235  : 	//
; 236  : 	return;
; 237  : }

  0024d	48 8b cc	 mov	 rcx, rsp
  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:defineDotNodes$rtcFrameData
  00257	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0025c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00264	48 33 cc	 xor	 rcx, rsp
  00267	e8 00 00 00 00	 call	 __security_check_cookie
  0026c	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00273	5f		 pop	 rdi
  00274	c3		 ret	 0
defineDotNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT makeDot
_TEXT	SEGMENT
dotSpec$ = 32
buff$ = 64
text$ = 136
j$ = 144
tv91 = 160
__$ArrayPad$ = 168
adaptor$ = 192
theTree$ = 200
makeDot	PROC						; COMDAT

; 360  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00012	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00017	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+192]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 361  : 	// The string we are building up
; 362  : 	//
; 363  : 	pANTLR3_STRING		dotSpec;
; 364  : 	char                buff[64];
; 365  : 	pANTLR3_STRING      text;
; 366  : 	int                 j;
; 367  : 
; 368  : 	dotSpec = adaptor->strFactory->newStr8

  0003d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  00045	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@
  00050	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00058	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005c	ff 50 38	 call	 QWORD PTR [rax+56]
  0005f	48 89 44 24 20	 mov	 QWORD PTR dotSpec$[rsp], rax

; 369  : 		
; 370  : 		(
; 371  : 			adaptor->strFactory,
; 372  : 
; 373  : 			// Default look and feel
; 374  : 			//
; 375  : 			(pANTLR3_UINT8)
; 376  : 			"digraph {\n\n"
; 377  : 			"\tordering=out;\n"
; 378  : 			"\tranksep=.4;\n"
; 379  : 			"\tbgcolor=\"lightgrey\";  node [shape=box, fixedsize=false, fontsize=12, fontname=\"Helvetica-bold\", fontcolor=\"blue\"\n"
; 380  : 			"\twidth=.25, height=.25, color=\"black\", fillcolor=\"white\", style=\"filled, solid, bold\"];\n\n"
; 381  : 			"\tedge [arrowsize=.5, color=\"black\", style=\"bold\"]\n\n"
; 382  : 		);
; 383  : 
; 384  :     if	(theTree == NULL)

  00064	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR theTree$[rsp], 0
  0006d	75 1e		 jne	 SHORT $LN7@makeDot

; 385  : 	{
; 386  : 		// No tree, so create a blank spec
; 387  : 		//
; 388  : 		dotSpec->append8(dotSpec, "n0[label=\"EMPTY TREE\"]\n");

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00080	ff 50 38	 call	 QWORD PTR [rax+56]

; 389  : 		return dotSpec;

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00088	e9 b6 01 00 00	 jmp	 $LN1@makeDot
$LN7@makeDot:

; 390  : 	}
; 391  : 
; 392  :     sprintf(buff, "\tn%p[label=\"", theTree);

  0008d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR theTree$[rsp]
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@
  0009c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buff$[rsp]
  000a1	e8 00 00 00 00	 call	 sprintf

; 393  : 	dotSpec->append8(dotSpec, buff);

  000a6	48 8d 54 24 40	 lea	 rdx, QWORD PTR buff$[rsp]
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  000b5	ff 50 38	 call	 QWORD PTR [rax+56]

; 394  :     text = adaptor->getText(adaptor, theTree);

  000b8	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR theTree$[rsp]
  000c0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR adaptor$[rsp]
  000d0	ff 90 b8 00 00
	00		 call	 QWORD PTR [rax+184]
  000d6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR text$[rsp], rax

; 395  :     for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  000de	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  000e9	eb 10		 jmp	 SHORT $LN4@makeDot
$LN2@makeDot:
  000eb	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  000f2	ff c0		 inc	 eax
  000f4	89 84 24 90 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN4@makeDot:
  000fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  00103	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00106	39 84 24 90 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  0010d	0f 8d bb 00 00
	00		 jge	 $LN3@makeDot

; 396  :     {
; 397  :             switch(text->charAt(text, j))

  00113	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  0011a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  00122	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  0012a	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  00130	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv91[rsp], eax
  00137	83 bc 24 a0 00
	00 00 0a	 cmp	 DWORD PTR tv91[rsp], 10
  0013f	74 2d		 je	 SHORT $LN9@makeDot
  00141	83 bc 24 a0 00
	00 00 0d	 cmp	 DWORD PTR tv91[rsp], 13
  00149	74 3a		 je	 SHORT $LN10@makeDot
  0014b	83 bc 24 a0 00
	00 00 22	 cmp	 DWORD PTR tv91[rsp], 34	; 00000022H
  00153	74 02		 je	 SHORT $LN8@makeDot
  00155	eb 45		 jmp	 SHORT $LN11@makeDot
$LN8@makeDot:

; 398  :             {
; 399  :                 case '"':
; 400  : 
; 401  :                     dotSpec->append8(dotSpec, "\\\"");

  00157	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MCKKLHBJ@?2?$CC@
  0015e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00163	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00168	ff 50 38	 call	 QWORD PTR [rax+56]
  0016b	90		 npad	 1

; 402  :                     break;

  0016c	eb 5b		 jmp	 SHORT $LN5@makeDot
$LN9@makeDot:

; 403  : 
; 404  :                 case '\n':
; 405  : 
; 406  :                     dotSpec->append8(dotSpec, "\\n");

  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JOGGLHBA@?2n@
  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0017f	ff 50 38	 call	 QWORD PTR [rax+56]
  00182	90		 npad	 1

; 407  :                     break;

  00183	eb 44		 jmp	 SHORT $LN5@makeDot
$LN10@makeDot:

; 408  : 
; 409  :                 case '\r':
; 410  : 
; 411  :                     dotSpec->append8(dotSpec, "\\r");

  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HIBBOKEN@?2r@
  0018c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00191	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  00196	ff 50 38	 call	 QWORD PTR [rax+56]
  00199	90		 npad	 1

; 412  :                     break;

  0019a	eb 2d		 jmp	 SHORT $LN5@makeDot
$LN11@makeDot:

; 413  : 
; 414  :                 default:
; 415  : 
; 416  :                     dotSpec->addc(dotSpec, text->charAt(text, j));

  0019c	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  001a3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR text$[rsp]
  001ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR text$[rsp]
  001b3	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  001b9	8b d0		 mov	 edx, eax
  001bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001c5	ff 50 70	 call	 QWORD PTR [rax+112]
  001c8	90		 npad	 1
$LN5@makeDot:

; 417  :                     break;
; 418  :             }
; 419  :     }

  001c9	e9 1d ff ff ff	 jmp	 $LN2@makeDot
$LN3@makeDot:

; 420  : 	dotSpec->append8(dotSpec, "\"]\n");

  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EKALBCDP@?$CC?$FN?6@
  001d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  001da	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  001df	ff 50 38	 call	 QWORD PTR [rax+56]

; 421  : 
; 422  : 	// First produce the node defintions
; 423  : 	//
; 424  : 	defineDotNodes(adaptor, theTree, dotSpec);

  001e2	4c 8b 44 24 20	 mov	 r8, QWORD PTR dotSpec$[rsp]
  001e7	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR theTree$[rsp]
  001ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  001f7	e8 00 00 00 00	 call	 defineDotNodes

; 425  : 	dotSpec->append8(dotSpec, "\n");

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
  00203	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00208	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0020d	ff 50 38	 call	 QWORD PTR [rax+56]

; 426  : 	defineDotEdges(adaptor, theTree, dotSpec);

  00210	4c 8b 44 24 20	 mov	 r8, QWORD PTR dotSpec$[rsp]
  00215	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR theTree$[rsp]
  0021d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00225	e8 00 00 00 00	 call	 defineDotEdges

; 427  : 	
; 428  : 	// Terminate the spec
; 429  : 	//
; 430  : 	dotSpec->append8(dotSpec, "\n}");

  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JHLIKEIA@?6?$HN@
  00231	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dotSpec$[rsp]
  00236	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
  0023b	ff 50 38	 call	 QWORD PTR [rax+56]

; 431  : 
; 432  : 	// Result
; 433  : 	//
; 434  : 	return dotSpec;

  0023e	48 8b 44 24 20	 mov	 rax, QWORD PTR dotSpec$[rsp]
$LN1@makeDot:

; 435  : }

  00243	48 8b f8	 mov	 rdi, rax
  00246	48 8b cc	 mov	 rcx, rsp
  00249	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:makeDot$rtcFrameData
  00250	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00255	48 8b c7	 mov	 rax, rdi
  00258	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00260	48 33 cc	 xor	 rcx, rsp
  00263	e8 00 00 00 00	 call	 __security_check_cookie
  00268	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  0026f	5f		 pop	 rdi
  00270	c3		 ret	 0
makeDot	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT isNilNode
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
isNilNode PROC						; COMDAT

; 907  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 908  : 	return t->isNilNode(t);

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  00014	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00019	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]

; 909  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
isNilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getUniqueID
_TEXT	SEGMENT
adaptor$ = 16
node$ = 24
getUniqueID PROC					; COMDAT

; 901  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 902  : 	return	ANTLR3_UINT32_CAST(node);

  0000b	8b 44 24 18	 mov	 eax, DWORD PTR node$[rsp]

; 903  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
getUniqueID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getChildCount
_TEXT	SEGMENT
adaptor$ = 48
tree$ = 56
getChildCount PROC					; COMDAT

; 891  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 892  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getChildCount()\n");

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fprintf

; 893  : 	return 0;

  00029	33 c0		 xor	 eax, eax

; 894  : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getChild
_TEXT	SEGMENT
adaptor$ = 48
tree$ = 56
i$ = 64
getChild PROC						; COMDAT

; 884  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 885  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getChild()\n");

  00014	b9 02 00 00 00	 mov	 ecx, 2
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 fprintf

; 886  : 	return NULL;

  0002e	33 c0		 xor	 eax, eax

; 887  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT setText8
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
setText8 PROC						; COMDAT

; 878  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 879  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setText()\n");

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fprintf
  00029	90		 npad	 1

; 880  : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
setText8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT setText
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
setText	PROC						; COMDAT

; 871  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 872  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setText()\n");

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fprintf
  00029	90		 npad	 1

; 873  : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
setText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getText
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
getText	PROC						; COMDAT

; 862  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 863  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getText()\n");

  0000f	b9 02 00 00 00	 mov	 ecx, 2
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fprintf

; 864  : 	return	NULL;

  00029	33 c0		 xor	 eax, eax

; 865  : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT setType
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
type$ = 64
setType	PROC						; COMDAT

; 854  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 855  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setType()\n");

  00014	b9 02 00 00 00	 mov	 ecx, 2
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 fprintf
  0002e	90		 npad	 1

; 856  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
setType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT getType
_TEXT	SEGMENT
adaptor$ = 16
t$ = 24
getType	PROC						; COMDAT

; 846  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 847  : 	return	0;

  0000b	33 c0		 xor	 eax, eax

; 848  : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgCreateTypeText
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tokenType$ = 72
text$ = 80
dbgCreateTypeText PROC					; COMDAT

; 832  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 833  : 	pANTLR3_BASE_TREE t;
; 834  : 
; 835  : 	t = createTypeText(adaptor, tokenType, text);

  00013	4c 8b 44 24 50	 mov	 r8, QWORD PTR text$[rsp]
  00018	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00021	e8 00 00 00 00	 call	 createTypeText
  00026	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 836  : 
; 837  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00030	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00034	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0003e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00042	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 838  : 
; 839  : 	return t;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 840  : 
; 841  : }

  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
dbgCreateTypeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT createTypeText
_TEXT	SEGMENT
fromToken$ = 32
adaptor$ = 64
tokenType$ = 72
text$ = 80
createTypeText PROC					; COMDAT

; 819  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 820  : 	pANTLR3_COMMON_TOKEN	fromToken;
; 821  : 
; 822  : 	/* Create the new token
; 823  : 	 */
; 824  : 	fromToken = adaptor->createToken(adaptor, tokenType, text);

  00013	4c 8b 44 24 50	 mov	 r8, QWORD PTR text$[rsp]
  00018	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00026	ff 90 08 01 00
	00		 call	 QWORD PTR [rax+264]
  0002c	48 89 44 24 20	 mov	 QWORD PTR fromToken$[rsp], rax

; 825  : 
; 826  : 	/* Return a new node based upon this token
; 827  : 	 */
; 828  : 	return	adaptor->create(adaptor, fromToken);

  00031	48 8b 54 24 20	 mov	 rdx, QWORD PTR fromToken$[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00040	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 829  : }

  00046	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
createTypeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgCreateTypeTokenText
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tokenType$ = 72
fromToken$ = 80
text$ = 88
dbgCreateTypeTokenText PROC				; COMDAT

; 807  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 808  : 	pANTLR3_BASE_TREE t;
; 809  : 
; 810  : 	t = createTypeTokenText(adaptor, tokenType, fromToken, text);

  00018	4c 8b 4c 24 58	 mov	 r9, QWORD PTR text$[rsp]
  0001d	4c 8b 44 24 50	 mov	 r8, QWORD PTR fromToken$[rsp]
  00022	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002b	e8 00 00 00 00	 call	 createTypeTokenText
  00030	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 811  : 
; 812  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003e	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00048	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0004c	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 813  : 
; 814  : 	return t;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 815  : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
dbgCreateTypeTokenText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT createTypeTokenText
_TEXT	SEGMENT
adaptor$ = 48
tokenType$ = 56
fromToken$ = 64
text$ = 72
createTypeTokenText PROC				; COMDAT

; 788  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 789  : 	/* Create the new token
; 790  : 	 */
; 791  : 	fromToken = adaptor->createTokenFromToken(adaptor, fromToken);

  00018	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00027	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]
  0002d	48 89 44 24 40	 mov	 QWORD PTR fromToken$[rsp], rax

; 792  : 
; 793  : 	/* Set the type of the new token to that supplied
; 794  : 	 */
; 795  : 	fromToken->setType(fromToken, tokenType);

  00032	8b 54 24 38	 mov	 edx, DWORD PTR tokenType$[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fromToken$[rsp]
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR fromToken$[rsp]
  00040	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 796  : 
; 797  : 	/* Set the text of the token accordingly
; 798  : 	 */
; 799  : 	fromToken->setText8(fromToken, text);

  00046	48 8b 54 24 48	 mov	 rdx, QWORD PTR text$[rsp]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR fromToken$[rsp]
  00055	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 800  : 
; 801  : 	/* Return a new node based upon this token
; 802  : 	 */
; 803  : 	return	adaptor->create(adaptor, fromToken);

  0005b	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00065	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006a	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 804  : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
createTypeTokenText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgCreateTypeToken
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tokenType$ = 72
fromToken$ = 80
dbgCreateTypeToken PROC					; COMDAT

; 776  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 777  : 	pANTLR3_BASE_TREE t;
; 778  : 
; 779  : 	t = createTypeToken(adaptor, tokenType, fromToken);

  00013	4c 8b 44 24 50	 mov	 r8, QWORD PTR fromToken$[rsp]
  00018	8b 54 24 48	 mov	 edx, DWORD PTR tokenType$[rsp]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00021	e8 00 00 00 00	 call	 createTypeToken
  00026	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 780  : 
; 781  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00030	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00034	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0003e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00042	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 782  : 
; 783  : 	return t;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 784  : }

  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
dbgCreateTypeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT createTypeToken
_TEXT	SEGMENT
adaptor$ = 48
tokenType$ = 56
fromToken$ = 64
createTypeToken PROC					; COMDAT

; 761  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 762  : 	/* Create the new token
; 763  : 	 */
; 764  : 	fromToken = adaptor->createTokenFromToken(adaptor, fromToken);

  00013	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00022	ff 90 10 01 00
	00		 call	 QWORD PTR [rax+272]
  00028	48 89 44 24 40	 mov	 QWORD PTR fromToken$[rsp], rax

; 765  : 
; 766  : 	/* Set the type of the new token to that supplied
; 767  : 	 */
; 768  : 	fromToken->setType(fromToken, tokenType);

  0002d	8b 54 24 38	 mov	 edx, DWORD PTR tokenType$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fromToken$[rsp]
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR fromToken$[rsp]
  0003b	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 769  : 
; 770  : 	/* Return a new node based upon this token
; 771  : 	 */
; 772  : 	return	adaptor->create(adaptor, fromToken);

  00041	48 8b 54 24 40	 mov	 rdx, QWORD PTR fromToken$[rsp]
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00050	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 773  : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
createTypeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgBecomeRootToken
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
newRoot$ = 72
oldRoot$ = 80
dbgBecomeRootToken PROC					; COMDAT

; 746  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 747  : 	pANTLR3_BASE_TREE	t;
; 748  : 
; 749  : 	t =	adaptor->becomeRoot(adaptor, adaptor->create(adaptor, newRoot), oldRoot);

  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR newRoot$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00023	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00029	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRoot$[rsp]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003b	ff 50 68	 call	 QWORD PTR [rax+104]
  0003e	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 750  : 
; 751  : 	adaptor->debugger->becomeRoot(adaptor->debugger,t, oldRoot);

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00048	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004c	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRoot$[rsp]
  00051	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0005b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0005f	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 752  : 
; 753  : 	return t;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 754  : }

  0006a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
dbgBecomeRootToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT becomeRootToken
_TEXT	SEGMENT
adaptor$ = 48
newRoot$ = 56
oldRoot$ = 64
becomeRootToken PROC					; COMDAT

; 741  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 742  : 	return	adaptor->becomeRoot(adaptor, adaptor->create(adaptor, newRoot), oldRoot);

  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR newRoot$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00023	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00029	4c 8b 44 24 40	 mov	 r8, QWORD PTR oldRoot$[rsp]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003b	ff 50 68	 call	 QWORD PTR [rax+104]

; 743  : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
becomeRootToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgAddChildToken
_TEXT	SEGMENT
tc$ = 32
adaptor$ = 64
t$ = 72
child$ = 80
dbgAddChildToken PROC					; COMDAT

; 576  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 577  : 	pANTLR3_BASE_TREE	tc;
; 578  : 
; 579  : 	if	(t != NULL && child != NULL)

  00014	48 83 7c 24 48
	00		 cmp	 QWORD PTR t$[rsp], 0
  0001a	74 5c		 je	 SHORT $LN2@dbgAddChil
  0001c	48 83 7c 24 50
	00		 cmp	 QWORD PTR child$[rsp], 0
  00022	74 54		 je	 SHORT $LN2@dbgAddChil

; 580  : 	{
; 581  : 		tc = adaptor->create(adaptor, child);

  00024	48 8b 54 24 50	 mov	 rdx, QWORD PTR child$[rsp]
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00033	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00039	48 89 44 24 20	 mov	 QWORD PTR tc$[rsp], rax

; 582  : 		adaptor->addChild(adaptor, t, tc);

  0003e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tc$[rsp]
  00043	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00052	ff 50 38	 call	 QWORD PTR [rax+56]

; 583  : 		adaptor->debugger->addChild(adaptor->debugger, t, tc);

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tc$[rsp]
  00063	48 8b 54 24 48	 mov	 rdx, QWORD PTR t$[rsp]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0006d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00071	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
  00077	90		 npad	 1
$LN2@dbgAddChil:

; 584  : 	}
; 585  : }

  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
dbgAddChildToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT addChildToken
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
child$ = 64
addChildToken PROC					; COMDAT

; 568  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 569  : 	if	(t != NULL && child != NULL)

  00014	48 83 7c 24 38
	00		 cmp	 QWORD PTR t$[rsp], 0
  0001a	74 33		 je	 SHORT $LN2@addChildTo
  0001c	48 83 7c 24 40
	00		 cmp	 QWORD PTR child$[rsp], 0
  00022	74 2b		 je	 SHORT $LN2@addChildTo

; 570  : 	{
; 571  : 		adaptor->addChild(adaptor, t, adaptor->create(adaptor, child));

  00024	48 8b 54 24 40	 mov	 rdx, QWORD PTR child$[rsp]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00033	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00039	4c 8b c0	 mov	 r8, rax
  0003c	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  00041	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004b	ff 50 38	 call	 QWORD PTR [rax+56]
  0004e	90		 npad	 1
$LN2@addChildTo:

; 572  : 	}
; 573  : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
addChildToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT rulePostProcessing
_TEXT	SEGMENT
saveRoot$ = 32
adaptor$ = 64
root$ = 72
rulePostProcessing PROC					; COMDAT

; 705  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 706  :     pANTLR3_BASE_TREE saveRoot;
; 707  : 
; 708  :     // Keep track of the root we are given. If it is a nilNode, then we
; 709  :     // can reuse it rather than orphaning it!
; 710  :     //
; 711  :     saveRoot = root;

  0000f	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00014	48 89 44 24 20	 mov	 QWORD PTR saveRoot$[rsp], rax

; 712  : 
; 713  : 	if (root != NULL && root->isNilNode(root))

  00019	48 83 7c 24 48
	00		 cmp	 QWORD PTR root$[rsp], 0
  0001f	0f 84 94 00 00
	00		 je	 $LN2@rulePostPr
  00025	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  0002f	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00035	0f b6 c0	 movzx	 eax, al
  00038	85 c0		 test	 eax, eax
  0003a	74 7d		 je	 SHORT $LN2@rulePostPr

; 714  : 	{
; 715  : 		if	(root->getChildCount(root) == 0)

  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00041	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00046	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0004c	85 c0		 test	 eax, eax
  0004e	75 0b		 jne	 SHORT $LN3@rulePostPr

; 716  : 		{
; 717  : 			root = NULL;

  00050	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR root$[rsp], 0

; 718  : 		}

  00059	eb 5e		 jmp	 SHORT $LN4@rulePostPr
$LN3@rulePostPr:

; 719  : 		else if	(root->getChildCount(root) == 1)

  0005b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00065	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0006b	83 f8 01	 cmp	 eax, 1
  0006e	75 49		 jne	 SHORT $LN5@rulePostPr

; 720  : 		{
; 721  : 			root = root->getChild(root, 0);

  00070	33 d2		 xor	 edx, edx
  00072	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00077	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  0007c	ff 50 70	 call	 QWORD PTR [rax+112]
  0007f	48 89 44 24 48	 mov	 QWORD PTR root$[rsp], rax

; 722  : 			root->setParent(root, NULL);

  00084	33 d2		 xor	 edx, edx
  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  0008b	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  00090	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]

; 723  : 			root->setChildIndex(root, -1);

  00096	ba ff ff ff ff	 mov	 edx, -1
  0009b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]
  000a5	ff 50 78	 call	 QWORD PTR [rax+120]

; 724  : 
; 725  :             // The root we were given was a nil node, wiht one child, which means it has
; 726  :             // been abandoned and would be lost in the node factory. However
; 727  :             // nodes can be flagged as resuable to prevent this terrible waste
; 728  :             //
; 729  :             saveRoot->reuse(saveRoot);

  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR saveRoot$[rsp]
  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR saveRoot$[rsp]
  000b2	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  000b8	90		 npad	 1
$LN5@rulePostPr:
$LN4@rulePostPr:
$LN2@rulePostPr:

; 730  : 		}
; 731  : 	}
; 732  : 
; 733  : 	return root;

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR root$[rsp]

; 734  : }

  000be	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
rulePostProcessing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgBecomeRoot
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
newRootTree$ = 72
oldRootTree$ = 80
dbgBecomeRoot PROC					; COMDAT

; 692  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 693  : 	pANTLR3_BASE_TREE t;
; 694  : 	
; 695  : 	t = becomeRoot(adaptor, newRootTree, oldRootTree);

  00014	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRootTree$[rsp]
  00019	48 8b 54 24 48	 mov	 rdx, QWORD PTR newRootTree$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00023	e8 00 00 00 00	 call	 becomeRoot
  00028	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 696  : 
; 697  : 	adaptor->debugger->becomeRoot(adaptor->debugger, newRootTree, oldRootTree);

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00032	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00036	4c 8b 44 24 50	 mov	 r8, QWORD PTR oldRootTree$[rsp]
  0003b	48 8b 54 24 48	 mov	 rdx, QWORD PTR newRootTree$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00045	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00049	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]

; 698  : 
; 699  : 	return t;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 700  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
dbgBecomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT becomeRoot
_TEXT	SEGMENT
saveRoot$ = 32
adaptor$ = 64
newRootTree$ = 72
oldRootTree$ = 80
becomeRoot PROC						; COMDAT

; 621  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 622  :     pANTLR3_BASE_TREE saveRoot;
; 623  : 
; 624  : 	/* Protect against tree rewrites if we are in some sort of error
; 625  : 	 * state, but have tried to recover. In C we can end up with a null pointer
; 626  : 	 * for a tree that was not produced.
; 627  : 	 */
; 628  : 	if	(newRootTree == NULL)

  00014	48 83 7c 24 48
	00		 cmp	 QWORD PTR newRootTree$[rsp], 0
  0001a	75 0a		 jne	 SHORT $LN2@becomeRoot

; 629  : 	{
; 630  : 		return	oldRootTree;

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR oldRootTree$[rsp]
  00021	e9 cd 00 00 00	 jmp	 $LN1@becomeRoot
$LN2@becomeRoot:

; 631  : 	}
; 632  : 
; 633  : 	/* root is just the new tree as is if there is no
; 634  : 	 * current root tree.
; 635  : 	 */
; 636  : 	if	(oldRootTree == NULL)

  00026	48 83 7c 24 50
	00		 cmp	 QWORD PTR oldRootTree$[rsp], 0
  0002c	75 0a		 jne	 SHORT $LN3@becomeRoot

; 637  : 	{
; 638  : 		return	newRootTree;

  0002e	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00033	e9 bb 00 00 00	 jmp	 $LN1@becomeRoot
$LN3@becomeRoot:

; 639  : 	}
; 640  : 
; 641  : 	/* Produce ^(nil real-node)
; 642  : 	 */
; 643  : 	if	(newRootTree->isNilNode(newRootTree))

  00038	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00042	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 65		 je	 SHORT $LN4@becomeRoot

; 644  : 	{
; 645  : 		if	(newRootTree->getChildCount(newRootTree) > 1)

  0004f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  00054	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00059	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0005f	83 f8 01	 cmp	 eax, 1
  00062	76 21		 jbe	 SHORT $LN5@becomeRoot

; 646  : 		{
; 647  : 			/* TODO: Handle tree exceptions 
; 648  : 			 */
; 649  : 			ANTLR3_FPRINTF(stderr, "More than one node as root! TODO: Create tree exception handling\n");

  00064	b9 02 00 00 00	 mov	 ecx, 2
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 fprintf

; 650  : 			return newRootTree;

  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  00083	eb 6e		 jmp	 SHORT $LN1@becomeRoot
$LN5@becomeRoot:

; 651  : 		}
; 652  : 
; 653  : 		/* The new root is the first child, keep track of the original newRoot
; 654  :          * because if it was a Nil Node, then we can reuse it now.
; 655  : 		 */
; 656  :         saveRoot    = newRootTree;

  00085	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  0008a	48 89 44 24 20	 mov	 QWORD PTR saveRoot$[rsp], rax

; 657  : 		newRootTree = newRootTree->getChild(newRootTree, 0);

  0008f	33 d2		 xor	 edx, edx
  00091	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  00096	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  0009b	ff 50 70	 call	 QWORD PTR [rax+112]
  0009e	48 89 44 24 48	 mov	 QWORD PTR newRootTree$[rsp], rax

; 658  : 
; 659  :         // Reclaim the old nilNode()
; 660  :         //
; 661  :         saveRoot->reuse(saveRoot);

  000a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR saveRoot$[rsp]
  000a8	48 8b 44 24 20	 mov	 rax, QWORD PTR saveRoot$[rsp]
  000ad	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  000b3	90		 npad	 1
$LN4@becomeRoot:

; 662  : 	}
; 663  : 
; 664  : 	/* Add old root into new root. addChild takes care of the case where oldRoot
; 665  : 	 * is a flat list (nill rooted tree). All children of oldroot are added to
; 666  : 	 * new root.
; 667  : 	 */
; 668  : 	newRootTree->addChild(newRootTree, oldRootTree);

  000b4	48 8b 54 24 50	 mov	 rdx, QWORD PTR oldRootTree$[rsp]
  000b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newRootTree$[rsp]
  000be	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
  000c3	ff 50 30	 call	 QWORD PTR [rax+48]

; 669  : 
; 670  :     // If the oldroot tree was a nil node, then we know at this point
; 671  :     // it has become orphaned by the rewrite logic, so we tell it to do
; 672  :     // whatever it needs to do to be reused.
; 673  :     //
; 674  :     if  (oldRootTree->isNilNode(oldRootTree))

  000c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR oldRootTree$[rsp]
  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR oldRootTree$[rsp]
  000d0	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	85 c0		 test	 eax, eax
  000db	74 11		 je	 SHORT $LN6@becomeRoot

; 675  :     {
; 676  :         // We have taken an old Root Tree and appended all its children to the new
; 677  :         // root. In addition though it was a nil node, which means the generated code
; 678  :         // will not reuse it again, so we will reclaim it here. First we want to zero out
; 679  :         // any pointers it was carrying around. We are just the baseTree handler so we
; 680  :         // don't know necessarilly know how to do this for the real node, we just ask the tree itself
; 681  :         // to do it.
; 682  :         //
; 683  :         oldRootTree->reuse(oldRootTree);

  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR oldRootTree$[rsp]
  000e2	48 8b 44 24 50	 mov	 rax, QWORD PTR oldRootTree$[rsp]
  000e7	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  000ed	90		 npad	 1
$LN6@becomeRoot:

; 684  :     }
; 685  : 	/* Always returns new root structure
; 686  : 	 */
; 687  : 	return	newRootTree;

  000ee	48 8b 44 24 48	 mov	 rax, QWORD PTR newRootTree$[rsp]
$LN1@becomeRoot:

; 688  : 
; 689  : }

  000f3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f7	5f		 pop	 rdi
  000f8	c3		 ret	 0
becomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgAddChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
child$ = 64
dbgAddChild PROC					; COMDAT

; 557  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 558  : 	if	(t != NULL && child != NULL)

  00014	48 83 7c 24 38
	00		 cmp	 QWORD PTR t$[rsp], 0
  0001a	74 3d		 je	 SHORT $LN2@dbgAddChil
  0001c	48 83 7c 24 40
	00		 cmp	 QWORD PTR child$[rsp], 0
  00022	74 35		 je	 SHORT $LN2@dbgAddChil

; 559  : 	{
; 560  : 		t->addChild(t, child);

  00024	48 8b 54 24 40	 mov	 rdx, QWORD PTR child$[rsp]
  00029	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  0002e	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00033	ff 50 30	 call	 QWORD PTR [rax+48]

; 561  : 		adaptor->debugger->addChild(adaptor->debugger, t, child);

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003f	4c 8b 44 24 40	 mov	 r8, QWORD PTR child$[rsp]
  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0004e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00052	ff 90 30 01 00
	00		 call	 QWORD PTR [rax+304]
  00058	90		 npad	 1
$LN2@dbgAddChil:

; 562  : 	}
; 563  : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
dbgAddChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT addChild
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
child$ = 64
addChild PROC						; COMDAT

; 549  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 550  : 	if	(t != NULL && child != NULL)

  00014	48 83 7c 24 38
	00		 cmp	 QWORD PTR t$[rsp], 0
  0001a	74 1b		 je	 SHORT $LN2@addChild
  0001c	48 83 7c 24 40
	00		 cmp	 QWORD PTR child$[rsp], 0
  00022	74 13		 je	 SHORT $LN2@addChild

; 551  : 	{
; 552  : 		t->addChild(t, child);

  00024	48 8b 54 24 40	 mov	 rdx, QWORD PTR child$[rsp]
  00029	48 8b 4c 24 38	 mov	 rcx, QWORD PTR t$[rsp]
  0002e	48 8b 44 24 38	 mov	 rax, QWORD PTR t$[rsp]
  00033	ff 50 30	 call	 QWORD PTR [rax+48]
  00036	90		 npad	 1
$LN2@addChild:

; 553  : 	}
; 554  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dupTreeTT
_TEXT	SEGMENT
newTree$ = 32
child$ = 40
newSubTree$ = 48
n$ = 56
i$ = 60
adaptor$ = 80
t$ = 88
parent$ = 96
dupTreeTT PROC						; COMDAT

; 468  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 469  : 	pANTLR3_BASE_TREE	newTree;
; 470  : 	pANTLR3_BASE_TREE	child;
; 471  : 	pANTLR3_BASE_TREE	newSubTree;
; 472  : 	ANTLR3_UINT32		n;
; 473  : 	ANTLR3_UINT32		i;
; 474  : 
; 475  : 	if	(t == NULL)

  00014	48 83 7c 24 58
	00		 cmp	 QWORD PTR t$[rsp], 0
  0001a	75 07		 jne	 SHORT $LN5@dupTreeTT

; 476  : 	{
; 477  : 		return NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	e9 e2 00 00 00	 jmp	 $LN1@dupTreeTT
$LN5@dupTreeTT:

; 478  : 	}
; 479  : 	newTree = t->dupNode(t);

  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t$[rsp]
  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR t$[rsp]
  0002d	ff 50 58	 call	 QWORD PTR [rax+88]
  00030	48 89 44 24 20	 mov	 QWORD PTR newTree$[rsp], rax

; 480  : 
; 481  : 	// Ensure new subtree root has parent/child index set
; 482  : 	//
; 483  : 	adaptor->setChildIndex		(adaptor, newTree, t->getChildIndex(t));

  00035	48 8b 4c 24 58	 mov	 rcx, QWORD PTR t$[rsp]
  0003a	48 8b 44 24 58	 mov	 rax, QWORD PTR t$[rsp]
  0003f	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  00045	44 8b c0	 mov	 r8d, eax
  00048	48 8b 54 24 20	 mov	 rdx, QWORD PTR newTree$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  00057	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]

; 484  : 	adaptor->setParent			(adaptor, newTree, parent);

  0005d	4c 8b 44 24 60	 mov	 r8, QWORD PTR parent$[rsp]
  00062	48 8b 54 24 20	 mov	 rdx, QWORD PTR newTree$[rsp]
  00067	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  00071	ff 50 48	 call	 QWORD PTR [rax+72]

; 485  : 	n = adaptor->getChildCount	(adaptor, t);

  00074	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  00083	ff 90 f8 00 00
	00		 call	 QWORD PTR [rax+248]
  00089	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 486  : 
; 487  : 	for	(i=0; i < n; i++)

  0008d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN4@dupTreeTT
$LN2@dupTreeTT:
  00097	8b 44 24 3c	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 3c	 mov	 DWORD PTR i$[rsp], eax
$LN4@dupTreeTT:
  000a1	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  000a5	39 44 24 3c	 cmp	 DWORD PTR i$[rsp], eax
  000a9	73 55		 jae	 SHORT $LN3@dupTreeTT

; 488  : 	{
; 489  : 		child = adaptor->getChild		(adaptor, t, i);

  000ab	44 8b 44 24 3c	 mov	 r8d, DWORD PTR i$[rsp]
  000b0	48 8b 54 24 58	 mov	 rdx, QWORD PTR t$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  000bf	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  000c5	48 89 44 24 28	 mov	 QWORD PTR child$[rsp], rax

; 490  : 		newSubTree = adaptor->dupTreeTT	(adaptor, child, t);

  000ca	4c 8b 44 24 58	 mov	 r8, QWORD PTR t$[rsp]
  000cf	48 8b 54 24 28	 mov	 rdx, QWORD PTR child$[rsp]
  000d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000d9	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  000de	ff 50 30	 call	 QWORD PTR [rax+48]
  000e1	48 89 44 24 30	 mov	 QWORD PTR newSubTree$[rsp], rax

; 491  : 		adaptor->addChild				(adaptor, newTree, newSubTree);

  000e6	4c 8b 44 24 30	 mov	 r8, QWORD PTR newSubTree$[rsp]
  000eb	48 8b 54 24 20	 mov	 rdx, QWORD PTR newTree$[rsp]
  000f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR adaptor$[rsp]
  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR adaptor$[rsp]
  000fa	ff 50 38	 call	 QWORD PTR [rax+56]
  000fd	90		 npad	 1

; 492  : 	}

  000fe	eb 97		 jmp	 SHORT $LN2@dupTreeTT
$LN3@dupTreeTT:

; 493  : 	return	newTree;

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR newTree$[rsp]
$LN1@dupTreeTT:

; 494  : }

  00105	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
dupTreeTT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgDupTree
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
tree$ = 72
dbgDupTree PROC						; COMDAT

; 521  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 522  : 	pANTLR3_BASE_TREE t;
; 523  : 
; 524  : 	// Call the normal dup tree mechanism first
; 525  : 	//
; 526  : 	t = adaptor->dupTreeTT(adaptor, tree, NULL);

  0000f	45 33 c0	 xor	 r8d, r8d
  00012	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00021	ff 50 30	 call	 QWORD PTR [rax+48]
  00024	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 527  : 
; 528  : 	// In order to tell the debugger what we have just done, we now
; 529  : 	// simulate the tree building mechanism. THis will fire
; 530  : 	// lots of debugging events to the client and look like we
; 531  : 	// duped the tree..
; 532  : 	//
; 533  : 	simulateTreeConstruction(adaptor, t);

  00029	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00033	e8 00 00 00 00	 call	 simulateTreeConstruction

; 534  : 
; 535  : 	return t;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 536  : }

  0003d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
dbgDupTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dupTree
_TEXT	SEGMENT
adaptor$ = 48
t$ = 56
dupTree	PROC						; COMDAT

; 462  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 463  : 	return	adaptor->dupTreeTT(adaptor, t, NULL);

  0000f	45 33 c0	 xor	 r8d, r8d
  00012	48 8b 54 24 38	 mov	 rdx, QWORD PTR t$[rsp]
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00021	ff 50 30	 call	 QWORD PTR [rax+48]

; 464  : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
dupTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT dbgNil
_TEXT	SEGMENT
t$ = 32
adaptor$ = 64
dbgNil	PROC						; COMDAT

; 448  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 449  : 	pANTLR3_BASE_TREE t;
; 450  : 
; 451  : 	t = adaptor->create				(adaptor, NULL);

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00016	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]
  0001c	48 89 44 24 20	 mov	 QWORD PTR t$[rsp], rax

; 452  : 	adaptor->debugger->createNode	(adaptor->debugger, t);

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR adaptor$[rsp]
  00026	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002a	48 8b 54 24 20	 mov	 rdx, QWORD PTR t$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00034	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00038	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 453  : 
; 454  : 	return	t;

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR t$[rsp]

; 455  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
dbgNil	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT nilNode
_TEXT	SEGMENT
adaptor$ = 48
nilNode	PROC						; COMDAT

; 442  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 443  : 	return	adaptor->create(adaptor, NULL);

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR adaptor$[rsp]
  00016	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 444  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
nilNode	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\TBG\source\repos\SPO_LAB3\Nix_LabN1\libantlr3c-3.4\src\antlr3basetreeadaptor.c
;	COMDAT antlr3BaseTreeAdaptorInit
_TEXT	SEGMENT
adaptor$ = 16
debugger$ = 24
antlr3BaseTreeAdaptorInit PROC				; COMDAT

; 81   : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 82   : 	// Initialize the interface
; 83   : 	//
; 84   : 	if	(debugger == NULL)

  0000b	48 83 7c 24 18
	00		 cmp	 QWORD PTR debugger$[rsp], 0
  00011	0f 85 9e 00 00
	00		 jne	 $LN2@antlr3Base

; 85   : 	{
; 86   : 		adaptor->nilNode				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR)) 								

  00017	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:nilNode
  00023	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 87   : 																				nilNode;
; 88   : 		adaptor->addChild				= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))								

  00027	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChild
  00033	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 89   : 																				addChild;
; 90   : 		adaptor->becomeRoot				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))				

  00037	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:becomeRoot
  00043	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 91   : 																				becomeRoot;
; 92   : 		adaptor->addChildToken			= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN))	

  00047	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addChildToken
  00053	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 93   : 																				addChildToken;
; 94   : 		adaptor->becomeRootToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  00057	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:becomeRootToken
  00063	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 95   : 																				becomeRootToken;
; 96   : 		adaptor->createTypeToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN))

  00067	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTypeToken
  00073	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 97   : 																				createTypeToken;
; 98   : 		adaptor->createTypeTokenText	= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN, pANTLR3_UINT8))

  0007a	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTypeTokenText
  00086	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 99   : 																				createTypeTokenText;
; 100  : 		adaptor->createTypeText			= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_UINT8))

  0008d	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:createTypeText
  00099	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 101  : 																				createTypeText;
; 102  : 		adaptor->dupTree				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))		 				

  000a0	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTree
  000ac	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 103  : 																				dupTree;
; 104  : 	}

  000b0	e9 a7 00 00 00	 jmp	 $LN3@antlr3Base
$LN2@antlr3Base:

; 105  : 	else
; 106  : 	{
; 107  : 		adaptor->nilNode				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR))

  000b5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgNil
  000c1	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 108  :                                                                                 dbgNil;
; 109  : 		adaptor->addChild				= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000c5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgAddChild
  000d1	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 110  :                                                                                 dbgAddChild;
; 111  : 		adaptor->becomeRoot				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000d5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgBecomeRoot
  000e1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 112  : 																				dbgBecomeRoot;
; 113  : 		adaptor->addChildToken			= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN))

  000e5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgAddChildToken
  000f1	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 114  :                                                                                 dbgAddChildToken;
; 115  : 		adaptor->becomeRootToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000f5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgBecomeRootToken
  00101	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 116  :                                                                                 dbgBecomeRootToken;
; 117  : 		adaptor->createTypeToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN))

  00105	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreateTypeToken
  00111	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 118  :                                                                                 dbgCreateTypeToken;
; 119  : 		adaptor->createTypeTokenText	= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN, pANTLR3_UINT8))

  00118	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreateTypeTokenText
  00124	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 120  :                                                                                 dbgCreateTypeTokenText;
; 121  : 		adaptor->createTypeText			= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_UINT8))

  0012b	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgCreateTypeText
  00137	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 122  :                                                                                 dbgCreateTypeText;
; 123  : 		adaptor->dupTree				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0013e	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dbgDupTree
  0014a	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 124  :                                                                                 dbgDupTree;
; 125  : 		debugger->adaptor				= adaptor;

  0014e	48 8b 44 24 18	 mov	 rax, QWORD PTR debugger$[rsp]
  00153	48 8b 4c 24 10	 mov	 rcx, QWORD PTR adaptor$[rsp]
  00158	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN3@antlr3Base:

; 126  : 	}
; 127  : 
; 128  : 	adaptor->dupTreeTT				=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dupTreeTT
  00168	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 129  :                                                                                 dupTreeTT;
; 130  : 	adaptor->rulePostProcessing		=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0016c	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:rulePostProcessing
  00178	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 131  :                                                                                 rulePostProcessing;
; 132  : 	adaptor->getType				=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0017c	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  00188	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 133  :                                                                                 getType;
; 134  : 	adaptor->setType				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  0018f	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setType
  0019b	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 135  : 																				setType;
; 136  : 	adaptor->getText				=  (pANTLR3_STRING (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  001a2	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  001ae	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 137  :                                                                                 getText;
; 138  : 	adaptor->setText8				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_UINT8))

  001b5	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText8
  001c1	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 139  : 																				setText8;
; 140  : 	adaptor->setText				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_STRING))

  001c8	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText
  001d4	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 141  :                                                                                 setText;
; 142  : 	adaptor->getChild				=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  001db	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChild
  001e7	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 143  :                                                                                 getChild;
; 144  : 	adaptor->getChildCount			=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  001ee	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChildCount
  001fa	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 145  :                                                                                 getChildCount;
; 146  : 	adaptor->getUniqueID			=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00201	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getUniqueID
  0020d	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 147  :                                                                                 getUniqueID;
; 148  : 	adaptor->isNilNode				=  (ANTLR3_BOOLEAN (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00214	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:isNilNode
  00220	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 149  :                                                                                 isNilNode;
; 150  : 
; 151  : 	adaptor->makeDot				=  (pANTLR3_STRING  (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00224	48 8b 44 24 10	 mov	 rax, QWORD PTR adaptor$[rsp]
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:makeDot
  00230	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 152  : 																				makeDot;
; 153  : 	
; 154  : 	/* Remaining functions filled in by the caller.
; 155  : 	 */
; 156  : 	return;
; 157  : }

  00237	5f		 pop	 rdi
  00238	c3		 ret	 0
antlr3BaseTreeAdaptorInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004b	e8 00 00 00 00	 call	 _vsprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00019	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00023	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00028	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002d	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 83 c8 01	 or	 rax, 1
  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0002a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003e	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00043	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00051	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00055	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0005a	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00064	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00066	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0006a	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006e	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00072	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Stream$ = 96
_Format$ = 104
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Stream$[rsp]
  0004b	e8 00 00 00 00	 call	 _vfprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 842  :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 843  :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 844  :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002d	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00037	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
